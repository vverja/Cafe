////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции планирования
//  
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

#Область ПроцедурыКроссТаблиц

// Преобразование Таблицы в Кросс-таблицу с переносом значений реквизитов периода в колонки кросс-таблицы.
//
// Параметры:
//  КроссТаблица - ДанныеФормы.Коллекция - Кросс-таблица в форме
//  Таблица      - ДанныеФормы.Коллекция - Табличная часть объекта
//  Параметры    - Структура - Дополнительные настройки, передаваемые в процедуру:
//                            ТаблицаПериоды, Периодичность, СтруктураРеквизитовПериода, СтруктураРеквизитов, 
//                            ПоляГруппировки
//
Процедура ЗаполнитьКроссТаблицуИзТаблицы(КроссТаблица, Таблица, Параметры) Экспорт
	
	ТаблицаПериоды             = Параметры.ТаблицаПериоды;
	Периодичность              = Параметры.Периодичность;
	СтруктураРеквизитовПериода = Параметры.СтруктураРеквизитовПериода;
	СтруктураРеквизитов        = Параметры.СтруктураРеквизитов;
	ПоляГруппировки            = Параметры.ПоляГруппировки;
	
	СтруктураИтоговыхРеквизитов = Неопределено;
	Если НЕ Параметры.Свойство("СтруктураИтоговыхРеквизитов", СтруктураИтоговыхРеквизитов) Тогда
		СтруктураИтоговыхРеквизитов = Новый Структура;
	КонецЕсли;
	
	КроссТаблица.Очистить();
	
	СтрокаИсключений = "";
	Для каждого ИтоговыйРеквизит Из СтруктураИтоговыхРеквизитов Цикл
		СтрокаИсключений = СтрокаИсключений + ?(ПустаяСтрока(СтрокаИсключений), "", ", ") + ИтоговыйРеквизит.Ключ;
	КонецЦикла;
	
	Для каждого СтрокаТаблицы Из Таблица Цикл
		Отбор = Новый Структура;
		Отбор.Вставить("Активная", Истина);
		Для каждого Элемент Из СтруктураРеквизитовПериода Цикл
			Если Элемент.Ключ = "ДатаОкончания" Тогда
				Отбор.Вставить(
					Элемент.Ключ, 
					ПланированиеКлиентСерверПовтИсп.РассчитатьДатуОкончанияПериода(СтрокаТаблицы[Элемент.Значение], Периодичность));
			Иначе
				Отбор.Вставить(
					Элемент.Ключ, 
					ПланированиеКлиентСерверПовтИсп.РассчитатьДатуНачалаПериода(СтрокаТаблицы[Элемент.Значение], Периодичность));
			КонецЕсли;
		КонецЦикла;
		
		НайденныеСтрокиПериодов = ТаблицаПериоды.НайтиСтроки(Отбор);
		
		Если НЕ ПустаяСтрока(ПоляГруппировки) Тогда
			Отбор = Новый Структура(ПоляГруппировки);
			ЗаполнитьЗначенияСвойств(Отбор, СтрокаТаблицы);
			НайденныеСтроки = КроссТаблица.НайтиСтроки(Отбор);
			Если НайденныеСтроки.Количество()=0 Тогда
				НоваяСтрока = КроссТаблица.Добавить();
			Иначе
				НоваяСтрока = НайденныеСтроки[0];
			КонецЕсли;
		Иначе
			НоваяСтрока = КроссТаблица.Добавить();
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаТаблицы,,СтрокаИсключений);
		
		Если НайденныеСтрокиПериодов.Количество() = 0 Тогда 
			Продолжить;
		КонецЕсли;
		СтрокаПериода = НайденныеСтрокиПериодов[0];
		
		Для каждого Элемент Из СтруктураРеквизитов Цикл
			Если СтруктураИтоговыхРеквизитов.Свойство(Элемент.Значение) Тогда
				НоваяСтрока[Элемент.Ключ + СтрокаПериода.ИмяКолонки] = НоваяСтрока[Элемент.Ключ + СтрокаПериода.ИмяКолонки] + СтрокаТаблицы[Элемент.Значение];
			Иначе
				НоваяСтрока[Элемент.Ключ + СтрокаПериода.ИмяКолонки] = СтрокаТаблицы[Элемент.Значение];
			КонецЕсли;
		КонецЦикла;
		
		Для каждого Элемент Из СтруктураИтоговыхРеквизитов Цикл
			НоваяСтрока[Элемент.Значение] = НоваяСтрока[Элемент.Значение] + СтрокаТаблицы[Элемент.Ключ];
		КонецЦикла;
		
	КонецЦикла;
			
КонецПроцедуры

// Заполнить таблицу из кросс-таблицы с переносом значений из колонок кросс-таблицы в реквизиты таблицы.
//
// Параметры:
//  КроссТаблица         - ДанныеФормы.Коллекция - Кросс-таблица в форме
//  Таблица              - ДанныеФормы.Коллекция - Табличная часть объекта
//  Параметры            - Структура - Дополнительные настройки, передаваемые в процедуру:
//                                     ТаблицаПериоды, СтруктураРеквизитовПериода, СтруктураРеквизитов
//  СтруктураДействий    - Структура - Структура действий, выполняемых со строками ТЧ
//  КэшированныеЗначения - Структура - Кэшированные значения
//
Процедура ЗаполнитьТаблицуИзКроссТаблицы(Таблица, КроссТаблица, Параметры, СтруктураДействий = Неопределено, 
	КэшированныеЗначения = Неопределено) Экспорт
	
	ТаблицаПериоды             = Параметры.ТаблицаПериоды;
	СтруктураРеквизитовПериода = Параметры.СтруктураРеквизитовПериода;
	СтруктураРеквизитов        = Параметры.СтруктураРеквизитов;
	
	Если СтруктураДействий = Неопределено Тогда
		СтруктураДействий = Новый Структура;
	КонецЕсли;
	
	Таблица.Очистить();
	
	Для каждого СтрокаКроссТаблицы Из КроссТаблица Цикл
		
		Для каждого СтрокаПериод Из ТаблицаПериоды Цикл
			
			Если НЕ СтрокаПериод.Активная или СтрокаПериод.НомерКолонки = 0 Тогда 
				Продолжить 
			КонецЕсли;
			
			НоваяСтрока = Таблица.Добавить();
			
			ЗаполнитьЗначенияСвойств(НоваяСтрока,СтрокаКроссТаблицы);
			
			Для каждого Элемент Из СтруктураРеквизитовПериода Цикл
			    НоваяСтрока[Элемент.Значение] = СтрокаПериод[Элемент.Ключ];
			КонецЦикла;
			
			Для каждого Элемент Из СтруктураРеквизитов Цикл
				
				НоваяСтрока[Элемент.Значение] = СтрокаКроссТаблицы[Элемент.Ключ + СтрокаПериод.ИмяКолонки];
				
			КонецЦикла;
			
			#Если Клиент Или ТолстыйКлиентУправляемоеПриложение Тогда
				ОбработкаТабличнойЧастиКлиент.ОбработатьСтрокуТЧ(НоваяСтрока, СтруктураДействий, КэшированныеЗначения);
			#КонецЕсли

		КонецЦикла;
		
	КонецЦикла;
	
	#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
		ОбработкаТабличнойЧастиСервер.ОбработатьТЧ(Таблица, СтруктураДействий, КэшированныеЗначения);
	#КонецЕсли
		
КонецПроцедуры 

// Процедура рассчитывает добавленное поле "Номер строки" для кросс-таблицы
//
// Параметры:
//  Форма                    - УправляемаяФорма - Форма в которой есть кросс-таблица
//  ИмяРеквизитаКроссТаблицы - Строка - Имя кросс-таблицы в форме
//
Процедура РассчитатьНомерСтрокиКроссТаблицы(Форма, Знач ИмяРеквизитаКроссТаблицы) Экспорт 

	КроссТаблица = Форма[ИмяРеквизитаКроссТаблицы];
	НомерСтроки = 0;
	Для каждого СтрокаТЧ Из КроссТаблица Цикл
		
		НомерСтроки = НомерСтроки + 1;
		СтрокаТЧ.НомерСтроки = НомерСтроки;
	
	КонецЦикла; 

КонецПроцедуры
 
#КонецОбласти 

#Область  ПроцедурыИФункцииОбщегоНазначенияДляПланирования

// Расчет дат начала и окончания периода планирования с заданной периодичностью
//
// Параметры:
//  Периодичность  	- ПеречислениеСсылка.Периодичность - Периодичность с которой нужно рассчитать даты
//  НачалоПериода  	- Дата - Дата начала периода
//  ОкончаниеПериода  	- Дата - Дата окончания периода
//
Процедура УстановитьНачалоОкончаниеПериодаПлана(Знач Периодичность, НачалоПериода, ОкончаниеПериода) Экспорт 
	
	Если НЕ ЗначениеЗаполнено(Периодичность) Тогда
		
		Возврат;
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(НачалоПериода) Тогда
		
		НачалоПериода = ОбщегоНазначенияУТКлиентСервер.РассчитатьДатуНачалаБлижайшегоПериода(НачалоПериода, Периодичность);
		
	Иначе
		
		НачалоПериода = ОбщегоНазначенияУТКлиентСервер.РассчитатьДатуНачалаБлижайшегоПериода(ТекущаяДата(), Периодичность);
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ОкончаниеПериода) И Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") И ОкончаниеПериода > НачалоПериода Тогда
		// Перерасчет даты окончания не нужен
	ИначеЕсли ЗначениеЗаполнено(ОкончаниеПериода) И ОкончаниеПериода > НачалоПериода Тогда
		
		НачалоПоследнегоПериода = ОбщегоНазначенияУТКлиентСервер.РассчитатьДатуНачалаБлижайшегоПериода(ОкончаниеПериода, Периодичность);
		ОкончаниеПериода = ОбщегоНазначенияУТКлиентСервер.РассчитатьДатуОкончанияПериода(НачалоПоследнегоПериода, Периодичность, 0);
		
	Иначе
		
		ОкончаниеПериода = ОбщегоНазначенияУТКлиентСервер.РассчитатьДатуОкончанияПериода(НачалоПериода, Периодичность, 1);
		
	КонецЕсли;
	
КонецПроцедуры

// Формирует заголовок для интервала дат с заданной периодичностью (День, неделя, декада, месяц и т.д.)
//
// Параметры:
//  Периодичность 	- ПеречислениеСсылка.Периодичность - Периодичность для которой нужно сформировать заголовок
//  ДатаНачала 		- Дата - Дата начала периода
//  ДатаОкончания 	- Дата - Дата окончания периода
//  ОтображатьНомерПериода  - Булево - Флаг отображения заголовка по номеру периода в пределах года
//
// Возвращаемое значение:
//  Строка - Текстовое представление заголовка периода
//
Функция СформироватьЗаголовокПериода(Знач Периодичность, Знач ДатаНачала, Знач ДатаОкончания, Знач ОтображатьНомерПериода = Ложь) Экспорт
	
	Заголовок = "";
	
	КодЯзыкаИнтерфейса = Локализация.КодЯзыкаИнтерфейса(); 
	КодЯзыкаДляФормат = Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыкаИнтерфейса);
	
	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда
		Если ОтображатьНомерПериода Тогда
			Заголовок = Формат(ДеньГода(ДатаНачала), "ЧДЦ=0; ЧГ=0;Л="+КодЯзыкаДляФормат) + " " + НСтр("ru='день';uk='день'");
		Иначе
			Заголовок = Формат(ДатаНачала, "ДЛФ=D;Л="+КодЯзыкаДляФормат);
		КонецЕсли;
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда
		Если ОтображатьНомерПериода Тогда
			Заголовок = НСтр("ru='%НомерНедели% неделя';uk='%НомерНедели% тиждень'");
			Если Год(ДатаНачала) <> Год(ДатаОкончания) Тогда
				НомерНедели = Формат(НеделяГода(ДатаНачала), "ЧДЦ=0; ЧГ=0;Л="+КодЯзыкаДляФормат) + "/" +  Формат(НеделяГода(ДатаОкончания), "ЧДЦ=0; ЧГ=0");
			Иначе
				НомерНедели = Формат(НеделяГода(ДатаНачала), "ЧДЦ=0; ЧГ=0;Л="+КодЯзыкаДляФормат);
			КонецЕсли; 
			Заголовок = СтрЗаменить(Заголовок, "%НомерНедели%", НомерНедели);
		Иначе
			ТекстДатаНачала = Формат(НачалоДня(ДатаНачала)+1, "ДФ=dd.MM;Л="+КодЯзыкаДляФормат); 
			ТекстДатаОкончания = Формат(ДатаОкончания, "ДФ=dd.MM;Л="+КодЯзыкаДляФормат);
			Заголовок   = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='%1 - %2';uk='%1 - %2'"), ТекстДатаНачала, ТекстДатаОкончания);
		КонецЕсли;
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада") Тогда
		ТекстДатаНачала = Формат(НачалоДня(ДатаНачала)+1, "ДФ=dd.MM;Л="+КодЯзыкаДляФормат); 
		ТекстДатаОкончания = Формат(ДатаОкончания, "ДФ=dd.MM;Л="+КодЯзыкаДляФормат);
		Заголовок   = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='%1 - %2';uk='%1 - %2'"), ТекстДатаНачала, ТекстДатаОкончания);
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Месяц") Тогда
		Если ОтображатьНомерПериода Тогда
			Заголовок = Формат(Месяц(НачалоДня(ДатаНачала)+1), "ЧДЦ=0; ЧГ=0;Л="+КодЯзыкаДляФормат) + " " + НСтр("ru='месяц';uk='місяць'");
		Иначе
			Заголовок = Формат(НачалоДня(ДатаНачала)+1, "ДФ='MMMM yyyy';Л="+КодЯзыкаДляФормат);
		КонецЕсли;
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал") Тогда
		Если ОтображатьНомерПериода Тогда
			Заголовок = Формат(ДатаНачала, "ДФ='q';Л="+КодЯзыкаДляФормат) + " " + НСтр("ru='квартал';uk='квартал'");
		Иначе
			ТекстДатаНачала = Формат(ДатаНачала, "ДФ='q';Л="+КодЯзыкаДляФормат);
			ТекстДатаОкончания = Формат(ДатаНачала, "ДФ=yyyy"); 
			Заголовок   = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='%1 кв. %2';uk='%1 кв. %2'"), ТекстДатаНачала, ТекстДатаОкончания);
		КонецЕсли;
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие") Тогда
		Если ОтображатьНомерПериода Тогда
			Заголовок = ?(ДатаНачала=НачалоГода(ДатаНачала),"1", "2");
		Иначе
			ТекстДатаНачала = ?(ДатаНачала=НачалоГода(ДатаНачала),"1", "2");
			ТекстДатаОкончания = Формат(ДатаНачала, "ДФ=yyyy"); 
			Заголовок   = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='%1 полугодие %2';uk='%1 півріччя %2'"), ТекстДатаНачала, ТекстДатаОкончания);
		КонецЕсли;
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год") Тогда
 		Заголовок = Формат(ДатаНачала,НСтр("ru='ДФ=''yyyy """"г.""""''';uk='ДФ=''yyyy """"р.""""'''"));
	Иначе 
		Заголовок = Строка(ДатаНачала);
	КонецЕсли;
	
	Возврат Заголовок;

КонецФункции

// Рассчитывает дату начала периода по указанной дате и периодичности
//
// Параметры:
// Дата          	   - дата, к которой будет рассчитана дата начала периода
// Периодичность       - значение перечисления "Периодичность"
//
// Возвращаемое значение:
// Дата - Дата начала периода
//
Функция РассчитатьДатуНачалаПериода(Знач Дата, Знач Периодичность) Экспорт
	
	ОдинДень = 86400;
	
	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда
		
		ДатаНачала = НачалоДня(Дата);
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда
		
		ДатаНачала = НачалоНедели(Дата);
				
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада")) Тогда
		
		ДеньМесяца   = День(Дата);
		НачалоМесяца = НачалоМесяца(Дата);
		
		Если ДеньМесяца = 1 Или ДеньМесяца = 11 Или ДеньМесяца = 21 Тогда
			ДатаНачала = Дата;
		ИначеЕсли ДеньМесяца <= 10 Тогда // Первая декада
			ДатаНачала = НачалоМесяца
		ИначеЕсли ДеньМесяца <= 20 Тогда // Вторая декада
			ДатаНачала = НачалоМесяца + ОдинДень * 10;
		Иначе // Третья декада
			ДатаНачала = НачалоМесяца + ОдинДень * 20;
		КонецЕсли;
		
	ИначеЕсли (Периодичность= ПредопределенноеЗначение("Перечисление.Периодичность.Месяц")) Тогда
		
		ДатаНачала = НачалоМесяца(Дата);
		
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал")) Тогда
		
		ДатаНачала = НачалоКвартала(Дата);

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие")) Тогда
		
		НачалоГода      = НачалоГода(Дата);
		НачалоПолугодия = ДобавитьМесяц(НачалоГода,6);
		
		Если Дата >= НачалоПолугодия Тогда
			ДатаНачала = НачалоПолугодия;
		Иначе
			ДатаНачала = НачалоГода;
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год")) Тогда
		
		ДатаНачала = НачалоГода(Дата);
		
	КонецЕсли;
	
	Возврат ДатаНачала;
	
КонецФункции

// Рассчитывает дату окончания периода по указанной дате и периодичности
//
// Параметры:
// Дата          	   - дата, к которой будет рассчитана дата окончания периода
// Периодичность       - значение перечисления "Периодичность"
//
// Возвращаемое значение:
// Дата - Дата окончания периода
//
Функция РассчитатьДатуОкончанияПериода(Знач Дата, Знач Периодичность) Экспорт
	
	ОдинДень = 86400;
	
	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда
		
		ДатаОкончания = КонецДня(Дата);
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда
		
		ДатаОкончания = КонецНедели(Дата);
				
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада")) Тогда
		
		ДеньМесяца   = День(Дата);
		КонецМесяца = КонецМесяца(Дата);
		НачалоМесяца = НачалоМесяца(Дата);
		
		Если ДеньМесяца = 10 Или ДеньМесяца = 20 Или ДеньМесяца = День(КонецМесяца) Тогда
			ДатаОкончания = КонецДня(Дата);
		ИначеЕсли ДеньМесяца <= 9 Тогда // Первая декада
			ДатаОкончания = НачалоМесяца - 1 + ОдинДень * 10
		ИначеЕсли ДеньМесяца <= 19 Тогда // Вторая декада
			ДатаОкончания = НачалоМесяца - 1 + ОдинДень * 20;
		Иначе // Третья декада
			ДатаОкончания = КонецМесяца;
		КонецЕсли;
		
	ИначеЕсли (Периодичность= ПредопределенноеЗначение("Перечисление.Периодичность.Месяц")) Тогда
		
		ДатаОкончания = КонецМесяца(Дата);
		
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал")) Тогда
		
		ДатаОкончания = КонецКвартала(Дата);

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие")) Тогда
		
		КонецГода      = КонецГода(Дата);
		КонецПолугодия = ДобавитьМесяц(КонецГода,-6);
		
		Если Дата < КонецПолугодия Тогда
			ДатаОкончания = КонецПолугодия;
		Иначе
			ДатаОкончания = КонецГода;
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год")) Тогда
		
		ДатаОкончания = КонецГода(Дата);
		
	КонецЕсли;
	
	Возврат ДатаОкончания;
	
КонецФункции

// Проверяет даты периода в табличной части соответствуют границам периода планирования
//
// Параметры:
//  Объект    - ДокументОбъект - документ плана, в котором проверяют даты периода
//  Отказ     - Булево - Присваивается Истина, если операция выполнена не успешно
//  Параметры - Структура - Дополнительные параметры (ДатаНачала, ДатаОкончания и т.д.)
//
Процедура ПроверитьДатуПериодаТЧ(Объект, Отказ, Параметры) Экспорт 

	Если ЗначениеЗаполнено(Параметры.Периодичность) И ЗначениеЗаполнено(Параметры.ДатаНачала) И ЗначениеЗаполнено(Параметры.ДатаОкончания) Тогда
		
		ПрефиксПутиКТЧ = "";
		Если Параметры.Свойство("ПрефиксПутиКТЧ") Тогда
			ПрефиксПутиКТЧ = Параметры.ПрефиксПутиКТЧ;
		КонецЕсли;
		
		Если ТипЗнч(Объект) = Тип("ДанныеФормыСтруктура") Тогда
			КлючДанных = Объект.Ссылка;
		Иначе
			КлючДанных = Объект;
		КонецЕсли;
		
		ШаблонАдреса = НСтр("ru=' в строке %НомерСтроки% списка ""%ПредставлениеТЧ%""';uk=' у рядку %НомерСтроки% списку ""%ПредставлениеТЧ%""'");
		ШаблонАдреса = СтрЗаменить(ШаблонАдреса,"%ПредставлениеТЧ%", Параметры.ПредставлениеТЧ);
		
		ТекстОшибки = НСтр("ru='%1 должна соответствовать периоду плана ""%2"" - ""%3""';uk='%1 повинна відповідати періоду плану ""%2"" - ""%3""'");
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстОшибки, Параметры.ПредставлениеДатыПериода,
			Формат(Параметры.ДатаНачала, "ДЛФ=DD"), Формат(Параметры.ДатаОкончания, "ДЛФ=DD"));
		
		Для Каждого СтрокаТЧ Из Объект[Параметры.ИмяТЧ] Цикл
			
			АдресОшибки = СтрЗаменить(ШаблонАдреса,"%НомерСтроки%", СтрокаТЧ.НомерСтроки);

			ДатаПериода = СтрокаТЧ[Параметры.ИмяПоляДатыПериода];
			
			Если ЗначениеЗаполнено(ДатаПериода) И (ДатаПериода < Параметры.ДатаНачала ИЛИ ДатаПериода > Параметры.ДатаОкончания) Тогда
				
				ПутьКТабличнойЧасти = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ПрефиксПутиКТЧ + Параметры.ИмяТЧ, 
					СтрокаТЧ.НомерСтроки, Параметры.ИмяПоляДатыПериода);
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
					ТекстОшибки + АдресОшибки,
					КлючДанных,
					ПутьКТабличнойЧасти,
					,
					Отказ);
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;

КонецПроцедуры

// Сравнивает измененные реквизиты, которые влияют на обновление интерфейса
//
// Параметры:
//  Объект               - ДокументОбъект или реквизит формы "Объект" в котором проверяются измененные реквизиты
//  Форма                - УправляемаяФорма - Форма документа
//  ИмяРеквизитаПроверки - Строка - Имя реквизита создаваемого на форме для сохранения значений реквизитов объекта
//
// Возвращаемое значение:
//  Булево - Истина, если интерфейс должен быть обновлен
//
Функция НеобходимоОбновитьИнтерфейс(Объект, Форма, Знач ИмяРеквизитаПроверки) Экспорт 

	ПроверяемыеРеквизиты = Новый Массив();
	ПроверяемыеРеквизиты.Добавить("Периодичность");
	ПроверяемыеРеквизиты.Добавить("ПланироватьПоСумме");
	ПроверяемыеРеквизиты.Добавить("НачалоПериода");
	ПроверяемыеРеквизиты.Добавить("ОкончаниеПериода");
	ПроверяемыеРеквизиты.Добавить("ВидПлана");
	
	РеквизитыПроверки = Форма[ИмяРеквизитаПроверки];
	Если ТипЗнч(РеквизитыПроверки) = Тип("Структура") Тогда
	
		Для каждого РеквизитПроверки Из РеквизитыПроверки Цикл
		
			Если ПроверяемыеРеквизиты.Найти(РеквизитПроверки.Ключ) <> Неопределено И РеквизитПроверки.Значение <> Объект[РеквизитПроверки.Ключ] Тогда
			
				Возврат Истина;
			
			КонецЕсли; 
		
		КонецЦикла; 
	
	КонецЕсли; 
	
	Возврат Ложь;
	
КонецФункции

// Сохраняет значения реквизитов объекта в структуру на форме для последующей проверки изменений
//
// Параметры:
// Объект               - ДокументОбъект или реквизит формы "Объект" в котором проверяются измененные реквизиты
// Форма                - Форма документа
// ИмяРеквизитаПроверки - Строка, Имя реквизита созданного на форме для сохранения значений реквизитов объекта
//
Процедура СохранитьЗначенияПроверяемыхРеквизитов(Объект, Форма, Знач ИмяРеквизитаПроверки) Экспорт 
	
	РеквизитыПроверки = Форма[ИмяРеквизитаПроверки];
	ЗаполнитьЗначенияСвойств(РеквизитыПроверки, Объект);
	
КонецПроцедуры

// Сохраняет значения реквизитов объекта в структуру на форме для последующей проверки изменений
//
// Параметры:
// Объект                 - ДокументОбъект или реквизит формы "Объект" в котором проверяются измененные реквизиты
// Форма                  - Форма документа
// ИмяРеквизитаПроверки   - Строка, Имя реквизита созданного на форме для сохранения значений реквизитов объекта
// ИменаРеквизитовОбъекта - Строка, Имена реквизитов объекта, в которые восстанавливаются значения
//
Процедура ВосстановитьЗначенияИзПроверяемыхРеквизитов(Объект, Форма, Знач ИмяРеквизитаПроверки, Знач ИменаРеквизитовОбъекта) Экспорт 
	
	РеквизитыПроверки = Форма[ИмяРеквизитаПроверки];
	ЗаполнитьЗначенияСвойств(Объект, РеквизитыПроверки, ИменаРеквизитовОбъекта);
	
КонецПроцедуры

// Функция возвращает значение типа плана по ссылки документа
//
// Параметры:
//  Ссылка  - ЛюбаяСсылка - Ссылка на документ плана для которого требуется определить тип
//
// Возвращаемое значение:
//   ПеречислениеСсылка.ТипыПланов   - Тип плана: план продаж, план закупок, план сборки (разборки) и т.д.
//
Функция ПолучитьТипПланаПоСсылке(Знач Ссылка) Экспорт 

	ТипЗначения = ТипЗнч(Ссылка);
	
	Если ТипЗначения = Тип("ДокументСсылка.ПланЗакупок") Тогда
	
		ТипПлана = ПредопределенноеЗначение("Перечисление.ТипыПланов.ПланЗакупок");
	
	ИначеЕсли ТипЗначения = Тип("ДокументСсылка.ПланПродаж") Тогда
	
		ТипПлана = ПредопределенноеЗначение("Перечисление.ТипыПланов.ПланПродаж");
	
	ИначеЕсли ТипЗначения = Тип("ДокументСсылка.ПланПродажПоКатегориям") Тогда
	
		ТипПлана = ПредопределенноеЗначение("Перечисление.ТипыПланов.ПланПродажПоКатегориям");
		
	ИначеЕсли ТипЗначения = Тип("ДокументСсылка.ПланСборкиРазборки") Тогда
	
		ТипПлана = ПредопределенноеЗначение("Перечисление.ТипыПланов.ПланСборкиРазборки");
	
	Иначе
	
		ТипПлана = ПредопределенноеЗначение("Перечисление.ТипыПланов.ПустаяСсылка");
	
	КонецЕсли; 

	Возврат ТипПлана;
	
КонецФункции 

// Функция - Получить текст выбираемых полей компоновки с учетом пользовательских настроек
//
// Параметры:
//  КомпоновщикНастроек			 - КомпоновщикНастроекКомпоновкиДанных 	 - компоновщик настроек, по которому получаются поля
//  УдалятьНеиспользуемыеПоля	 - Булево	 - Если Истина, то из пользовательских полей удаляются все не используемые поля
//  ИспользуемыеПоля			 - Массив	 - используемые для выборки поля
//
// Возвращаемое значение:
//  Строка - строковое перечисление выбираемых полей
//
Функция ПолучитьТекстВыбираемыхПолейКомпоновки(КомпоновщикНастроек, УдалятьНеиспользуемыеПоля = Ложь, ИспользуемыеПоля = Неопределено) Экспорт 
	
	ПоляЗаполнения = "";
	
	Если ИспользуемыеПоля = Неопределено Тогда
		ИспользуемыеПоля = Новый Массив;
	КонецЕсли; 
	
	ПоляГруппировки = ПолучитьПоляГруппировок(КомпоновщикНастроек);
	ПоляВыбора = ПолучитьПоляВыбора(КомпоновщикНастроек);
		
	Если ЗначениеЗаполнено(КомпоновщикНастроек.Настройки.Структура.ИдентификаторПользовательскойНастройки) Тогда
		НастройкаПользователя = КомпоновщикНастроек.ПользовательскиеНастройки.Элементы.Найти(
			КомпоновщикНастроек.Настройки.Структура.ИдентификаторПользовательскойНастройки);
		Если НастройкаПользователя <> Неопределено
			И НастройкаПользователя.Структура.Количество() > 0
			И НастройкаПользователя.Структура[0].Использование Тогда
			
			Если УдалятьНеиспользуемыеПоля Тогда
				Для каждого Поле Из ПоляГруппировки Цикл
					
					Если НЕ Поле.Использование Тогда
						Продолжить;
					КонецЕсли;
					
					Если ИспользуемыеПоля.Найти(Строка(Поле.Поле)) = Неопределено Тогда
					
						Поле.Использование = Ложь;
					
					КонецЕсли; 
				КонецЦикла; 
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(КомпоновщикНастроек.Настройки.Выбор.ИдентификаторПользовательскойНастройки) Тогда
		НастройкаПользователя = КомпоновщикНастроек.ПользовательскиеНастройки.Элементы.Найти(
			КомпоновщикНастроек.Настройки.Выбор.ИдентификаторПользовательскойНастройки);
		Если НастройкаПользователя <> Неопределено Тогда
			Если УдалятьНеиспользуемыеПоля Тогда
				Для каждого Поле Из ПоляВыбора Цикл
					
					Если НЕ Поле.Использование Тогда
						Продолжить;
					КонецЕсли;
					
					Если ИспользуемыеПоля.Найти(Строка(Поле.Поле)) = Неопределено Тогда
					
						Поле.Использование = Ложь;
					
					КонецЕсли; 
				КонецЦикла; 
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;

	Для каждого Поле Из ПоляГруппировки Цикл
		Если НЕ Поле.Использование Тогда
			Продолжить;
		КонецЕсли; 
		
		Если НЕ ПустаяСтрока(ПоляЗаполнения) Тогда
			ПоляЗаполнения = ПоляЗаполнения + ", ";
		КонецЕсли; 
		ПоляЗаполнения = ПоляЗаполнения + Строка(Поле.Поле);
		
	КонецЦикла; 
	Для каждого Поле Из ПоляВыбора Цикл
		Если НЕ Поле.Использование Тогда
			Продолжить;
		КонецЕсли; 
		Если НЕ ПустаяСтрока(ПоляЗаполнения) Тогда
			ПоляЗаполнения = ПоляЗаполнения + ", ";
		КонецЕсли; 
		ПоляЗаполнения = ПоляЗаполнения + Строка(Поле.Поле);
	КонецЦикла;
	
	Возврат ПоляЗаполнения;

КонецФункции 

// Возвращает поля группировки компоновщика настроек
//
// Параметры:
//  КомпоновщикНастроек  - КомпоновщикНастроекКомпоновкиДанных - компоновщик в котором необходимо получить поля группировки
//
// Возвращаемое значение:
//   Коллекция  - Коллекция элементов полей группировки
//
Функция ПолучитьПоляГруппировок(КомпоновщикНастроек) Экспорт 
	
	ПоляГруппировки = Новый Массив;
	
	Если НЕ ЗначениеЗаполнено(КомпоновщикНастроек.Настройки.Структура.ИдентификаторПользовательскойНастройки) Тогда
		Если КомпоновщикНастроек.Настройки.Структура.Количество() > 0 
			И КомпоновщикНастроек.Настройки.Структура[0].Использование Тогда
			ПоляГруппировки = КомпоновщикНастроек.Настройки.Структура[0].ПоляГруппировки.Элементы;
		КонецЕсли;
	Иначе
		ЭлементНастройки = КомпоновщикНастроек.ПользовательскиеНастройки.Элементы.Найти(
			КомпоновщикНастроек.Настройки.Структура.ИдентификаторПользовательскойНастройки);
		Если ЭлементНастройки <> Неопределено
			И ЭлементНастройки.Структура.Количество() > 0
			И ЭлементНастройки.Структура[0].Использование Тогда
			ПоляГруппировки = ЭлементНастройки.Структура[0].ПоляГруппировки.Элементы;
			
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПоляГруппировки;

КонецФункции 

// Возвращает поля выбора компоновщика настроек
//
// Параметры:
//  КомпоновщикНастроек  - КомпоновщикНастроекКомпоновкиДанных - компоновщик в котором необходимо получить поля выбора
//
// Возвращаемое значение:
//   Коллекция  - Коллекция элементов полей выбора
//
Функция ПолучитьПоляВыбора(КомпоновщикНастроек) Экспорт 
	
	ПоляВыбора = Новый Массив;
	
	Если НЕ ЗначениеЗаполнено(КомпоновщикНастроек.Настройки.Выбор.ИдентификаторПользовательскойНастройки) Тогда
		ПоляВыбора = КомпоновщикНастроек.Настройки.Выбор.Элементы;
	Иначе
		ЭлементНастройки = КомпоновщикНастроек.ПользовательскиеНастройки.Элементы.Найти(
			КомпоновщикНастроек.Настройки.Выбор.ИдентификаторПользовательскойНастройки);
		Если ЭлементНастройки <> Неопределено Тогда
			ПоляВыбора = ЭлементНастройки.Элементы;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПоляВыбора;

КонецФункции 

#КонецОбласти

#Область ПростоеЗаполнение

// Возвращает отбор для выборки состава номенклатуры
//
// Параметры:
// СтруктураНастроек    - Структура - Значение настроек документа
// Параметры            - Структура - Значение для отбора
//
// Возвращаемое значение:
// Структура - Структура отбора
//
Функция ОтборДляЗаполненияСостава(СтруктураНастроек, Параметры) Экспорт

	Отбор = Новый Структура();
	ВариантЗаполненияСостава = СтруктураНастроек.ВариантЗаполненияСостава;
	Формула = СтруктураНастроек.Формула;
	
	Если ВариантЗаполненияСостава = "Формула" Тогда
		
		Если СтрНайти(Формула, "ПланыПродажСОтбором") или СтрНайти(Формула, "ПланыЗакупокСОтбором") Тогда
			
			Отбор.Вставить("ОтборСклад", 		Параметры.Склад);
			Отбор.Вставить("ОтборПодразделение",Параметры.Подразделение);
			Отбор.Вставить("ОтборПартнер", 		Параметры.Партнер);
			Отбор.Вставить("ОтборСоглашение", 	Параметры.Соглашение);
			
		КонецЕсли;
		
		Если СтрНайти(Формула, "ФактыЗакупок") или СтрНайти(Формула, "ФактыПродаж") Тогда
			
			Отбор.Вставить("ОтборСклад", 		Параметры.Склад);
			Отбор.Вставить("ОтборПодразделение",Параметры.Подразделение);
			Отбор.Вставить("ОтборПартнер", 		Параметры.Партнер);
			
		КонецЕсли;
			
		Если СтрНайти(Формула,"ПланыПроизводстваСОтбором") или СтрНайти(Формула, "ПланыПроизводстваМатериалыСОтбором") Тогда
			
			Отбор.Вставить("ОтборПодразделение", Параметры.Подразделение);
			
		КонецЕсли;
		
		Если СтрНайти(Формула, "ПланыСборкиКомплектующиеСОтбором") или СтрНайти(Формула, "ПланыСборкиКомплектыСОтбором") 
																или СтрНайти(Формула, "ДоляДнейНаличияТовараНаОстатках")
																или СтрНайти(Формула, "ФактыСборкиКомплектующие")
																или СтрНайти(Формула, "ФактыСборкиКомплекты") Тогда
				
			Отбор.Вставить("ОтборСклад", Параметры.Склад);
			
		КонецЕсли;
		
	ИначеЕсли (ВариантЗаполненияСостава = "НоменклатураПоставщиков" 
		или ВариантЗаполненияСостава = "ТоварыПриобретенныеУПоставщика"
		или ВариантЗаполненияСостава = "ТоварыПриобретенныеКлиентом") и ЗначениеЗаполнено(Параметры.Партнер) Тогда
		
		Отбор.Вставить("ОтборПартнер", Параметры.Партнер);
		
	ИначеЕсли ВариантЗаполненияСостава = "АссортиментПродаж" Тогда
		
		Отбор.Вставить("ОтборФорматМагазина", Параметры.ФорматМагазина);
		Отбор.Вставить("ОтборСклад", Параметры.Склад);
		
	ИначеЕсли ВариантЗаполненияСостава = "АссортиментЗакупок" Тогда
		
		Отбор.Вставить("ОтборСклад", Параметры.Склад);
		
	КонецЕсли;
	
	Возврат Отбор;
	
КонецФункции

// Возвращает отбор для выборки показателей
//
// Параметры:
// ТипПлана             - ПеречислениеСсылка.ТипыПлана -  Значение перечисления типы плана
// Параметры            - Структура - Значение для отбора
// ПараметрыВидаПлана   - Структура - Значение реквизитов вида плана
//
// Возвращаемое значение:
// Структура - Структура отбора
//
Функция ОтборДляЗаполненияПоказателей(ТипПлана, Параметры, ПараметрыВидаПлана) Экспорт
	
	Отбор = Новый Структура();
	
	Если ТипПлана = ПредопределенноеЗначение("Перечисление.ТипыПланов.ПланЗакупок") Тогда
		
		Если ПараметрыВидаПлана.Свойство("ЗаполнятьСклад") И ПараметрыВидаПлана.ЗаполнятьСклад Тогда
			Отбор.Вставить("ОтборСклад", 		Параметры.Склад);
		КонецЕсли;
		
		Если ПараметрыВидаПлана.Свойство("ЗаполнятьПодразделение") И ПараметрыВидаПлана.ЗаполнятьПодразделение Тогда
			Отбор.Вставить("ОтборПодразделение",Параметры.Подразделение);
		КонецЕсли;
		
		Если ПараметрыВидаПлана.Свойство("ЗаполнятьПартнера") И ПараметрыВидаПлана.ЗаполнятьПартнера Тогда
			Отбор.Вставить("ОтборПартнер", 		Параметры.Партнер);
		КонецЕсли;
		
		Если ПараметрыВидаПлана.Свойство("ЗаполнятьСоглашение") И ПараметрыВидаПлана.ЗаполнятьСоглашение Тогда
			Отбор.Вставить("ОтборСоглашение", 	Параметры.Соглашение);
		КонецЕсли;
		
		Если ПараметрыВидаПлана.Свойство("ЗаполнятьСоглашение")
			И ПараметрыВидаПлана.ЗаполнятьСоглашение
			И Параметры.Свойство("ВидЦеныПоставщика") Тогда
			Отбор.Вставить("ОтборВидЦеныПоставщика",	Параметры.ВидЦеныПоставщика);
		КонецЕсли;
		
	КонецЕсли;
	
	Если ТипПлана = ПредопределенноеЗначение("Перечисление.ТипыПланов.ПланПродаж") Тогда
		
		Если ПараметрыВидаПлана.Свойство("ЗаполнятьСклад") и ПараметрыВидаПлана.ЗаполнятьСклад Тогда
			Отбор.Вставить("ОтборСклад", 		Параметры.Склад);
		КонецЕсли;
		
		Если ПараметрыВидаПлана.Свойство("ЗаполнятьПодразделение") и ПараметрыВидаПлана.ЗаполнятьПодразделение Тогда
			Отбор.Вставить("ОтборПодразделение",Параметры.Подразделение);
		КонецЕсли;
		
		Если ПараметрыВидаПлана.Свойство("ЗаполнятьПартнера") и ПараметрыВидаПлана.ЗаполнятьПартнера Тогда
			Отбор.Вставить("ОтборПартнер", 		Параметры.Партнер);
		КонецЕсли;
		
		Если ПараметрыВидаПлана.Свойство("ЗаполнятьСоглашение") и ПараметрыВидаПлана.ЗаполнятьСоглашение Тогда
			Отбор.Вставить("ОтборСоглашение", 	Параметры.Соглашение);
		КонецЕсли;
		
		Если ПараметрыВидаПлана.Свойство("ЗаполнятьМенеджера") и ПараметрыВидаПлана.ЗаполнятьМенеджера Тогда
			Отбор.Вставить("ОтборМенеджер", 	Параметры.Менеджер);
		КонецЕсли;
		
		Если ПараметрыВидаПлана.Свойство("ЗаполнятьФорматМагазина") и ПараметрыВидаПлана.ЗаполнятьФорматМагазина Тогда
			Отбор.Вставить("ОтборФорматМагазина", 	Параметры.ФорматМагазина);
		КонецЕсли;
		
	КонецЕсли;
	
	Если ТипПлана = ПредопределенноеЗначение("Перечисление.ТипыПланов.ПланПродажПоКатегориям") Тогда
		
		Если ПараметрыВидаПлана.Свойство("ЗаполнятьПодразделение") И ПараметрыВидаПлана.ЗаполнятьПодразделение Тогда
			Отбор.Вставить("ОтборПодразделение", Параметры.Подразделение);
		КонецЕсли;
		
		Если ПараметрыВидаПлана.Свойство("ЗаполнятьСклад") И ПараметрыВидаПлана.ЗаполнятьСклад Тогда
			Отбор.Вставить("ОтборСклад", Параметры.Склад);
		КонецЕсли;
		
		Если ПараметрыВидаПлана.Свойство("ЗаполнятьФорматМагазина") И ПараметрыВидаПлана.ЗаполнятьФорматМагазина Тогда
			Отбор.Вставить("ОтборФорматМагазина", Параметры.ФорматМагазина);
		КонецЕсли;
		
	КонецЕсли;
	
	Если ТипПлана = ПредопределенноеЗначение("Перечисление.ТипыПланов.ПланСборкиРазборки") 
					и ПараметрыВидаПлана.Свойство("ЗаполнятьСклад") и ПараметрыВидаПлана.ЗаполнятьСклад Тогда
		Отбор.Вставить("ОтборСклад",Параметры.Склад);
	КонецЕсли;
	
	
	Возврат Отбор;
	
КонецФункции

// Устанавливает представление формулы
//
// Параметры:
// Форма             - УправляемаяФорма - Форма документа
// ТекущаяСтрока     - ДанныеФормыЭлементКоллекции - Текущие данные табличной части
//
Процедура УстановитьПредставлениеФормулы(Форма, ТекущаяСтрока) Экспорт

	Если Форма.Объект.КроссТаблица Тогда
		
		АктивныеПериоды = Форма.Периоды.НайтиСтроки(Новый Структура("Активная", Истина));
		
		Для каждого Период Из АктивныеПериоды Цикл
			Если ТекущаяСтрока.Свойство("ФормулаВычисление_" + Период.ИмяКолонки) Тогда
				ТекущаяСтрока["ФормулаВычисление_" + Период.ИмяКолонки] = ?(Не ЗначениеЗаполнено(ТекущаяСтрока["ФормулаВычисление_" + Период.ИмяКолонки]), 
					ТекстУстановкиНовойФормулы(), ТекущаяСтрока["ФормулаВычисление_" + Период.ИмяКолонки]);
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		
		Если ТекущаяСтрока.Свойство("ФормулаВычисление") Тогда
			ТекущаяСтрока.ФормулаВычисление = ?(Не ЗначениеЗаполнено(ТекущаяСтрока.ФормулаВычисление), 
				ТекстУстановкиНовойФормулы(), ТекущаяСтрока.ФормулаВычисление);
		КонецЕсли;
	
	КонецЕсли;
	
КонецПроцедуры

// Очищает значение реквизита "ФормулаВычисление"
//
// Параметры:
// Форма             - УправляемаяФорма - Форма документа
//
Процедура ОчиститьЗначениеФормулы(Форма) Экспорт
	
	СтруктураПоиска = Новый Структура;
	СтруктураПоиска.Вставить("ФормулаВычисление", Неопределено);
	
	ЗаполнитьЗначенияСвойств(СтруктураПоиска, Форма);
	
	Если СтруктураПоиска.ФормулаВычисление <> Неопределено Тогда
		Форма.ФормулаВычисление = Неопределено;
	КонецЕсли;
	
КонецПроцедуры

// Вычисление по формуле
//
// Параметры:
// ИсходнаяФормула       - Строка - Значение исходной формулы
// ТекущиеДанные         - ДанныеФормыЭлементКоллекции - Значение текущих данных табличной части
// Постфикс              - Строка - Значение имени колонки из таблицы периодов
// Представление         - Строка - Значение пользовательского представления формулы
//
// Возвращаемое значение:
// Структура - Возвращает структуру с новыми параметрами представления формулы
//
Функция ВычислитьПоФормуле(Знач ИсходнаяФормула, Знач ТекущиеДанные, Постфикс = Неопределено, Знач Представление = Неопределено) Экспорт
	
	РасчетнаяФормула = ИсходнаяФормула;
	ВыводитьПромежуточныеВычисления = Ложь;
	
	МассивОперандов = РаботаСФормуламиКлиентСервер.ПолучитьМассивОперандовТекстовойФормулы(РасчетнаяФормула);
	
	Для каждого Операнд Из МассивОперандов Цикл
		
		Если Постфикс <> Неопределено Тогда
			ИмяОперанда = Операнд + "_" + Постфикс;
		Иначе
			ИмяОперанда = Операнд;
		КонецЕсли;
		
		Если Не ТекущиеДанные.Свойство(ИмяОперанда) Тогда
			Продолжить;
		КонецЕсли;
		
		ЗначениеОперанда = ТекущиеДанные[ИмяОперанда];
		Если НЕ ВыводитьПромежуточныеВычисления Тогда
			ВыводитьПромежуточныеВычисления = НЕ ПустаяСтрока(СтрЗаменить(РасчетнаяФормула, "["+Операнд+"]", ""))
		КонецЕсли; 
		РасчетнаяФормула = СтрЗаменить(РасчетнаяФормула, "["+Операнд+"]", Формат(ЗначениеОперанда, "ЧРД=.; ЧН=0; ЧГ=0"));
		
	КонецЦикла;
	
	Попытка
		#Если Сервер Тогда
			РезультатВычисления = Формат(РаботаВБезопасномРежиме.ВычислитьВБезопасномРежиме(РасчетнаяФормула),"ЧЦ=15; ЧДЦ=3; ЧН=0");
		#Иначе
			РезультатВычисления = Формат(Вычислить(РасчетнаяФормула),"ЧЦ=15; ЧДЦ=3; ЧН=0");
		#КонецЕсли
	Исключение
		РезультатВычисления = 0;
	КонецПопытки;
	
	Если ЗначениеЗаполнено(ИсходнаяФормула) и ИсходнаяФормула <> ТекстУстановкиНовойФормулы() Тогда
		Вычисление = ИсходнаяФормула + ?(ВыводитьПромежуточныеВычисления, " = " + РасчетнаяФормула, "") + " = " + РезультатВычисления;
	Иначе
		Вычисление = ТекстУстановкиНовойФормулы();
	КонецЕсли;
	
	Если ИсходнаяФормула <> ТекстУстановкиНовойФормулы() Тогда
		Представление = ?(ЗначениеЗаполнено(Представление),Представление,ИсходнаяФормула);
	Иначе
		Представление = "";
	КонецЕсли;
	
	Возврат Новый Структура("Вычисление,Результат,Представление", Вычисление,РезультатВычисления,Представление);

КонецФункции

// Заполняет значения дополнительных параметров
//
// Параметры:
// Форма           - УправляемаяФорма - Форма документа
// ДопРеквизиты    - Массив - Массив дополнительных реквизитов
// ИмяТЧ           - Строка - Имя табличной части
//
Процедура ОтобразитьЗначениеДополнительныхПараметров(Форма, ДопРеквизиты, ИмяТЧ) Экспорт
	
	ТекущиеДанные = Форма.Элементы[ИмяТЧ].ТекущиеДанные;
	ТекущийЭлементПолеФормы = Форма.Элементы[ИмяТЧ].ТекущийЭлемент;
	АктивныеПериоды = Форма.Периоды.НайтиСтроки(Новый Структура("Активная", Истина));
	
	Префикс = ИмяТЧ + "Количество_";
	
	Если ТекущиеДанные = Неопределено Тогда
		ПланированиеКлиентСервер.ОчиститьЗначениеФормулы(Форма);
		Возврат;
	КонецЕсли;
	
	Если ТекущийЭлементПолеФормы <> Неопределено Тогда
		
		Для каждого Период Из АктивныеПериоды Цикл
			
			Для каждого ДопРеквизит Из ДопРеквизиты Цикл
				
				ИмяКолонки = ДопРеквизит.Имя + "_" + Период.ИмяКолонки;
				
				Если ТекущиеДанные.Свойство(ИмяКолонки) Тогда
					Форма[ДопРеквизит.Имя] = ?(АктивныеПериоды.Количество() = 1, ТекущиеДанные[ИмяКолонки], Неопределено);
				КонецЕсли;
				
			КонецЦикла;
			
			Если ТекущийЭлементПолеФормы.Имя = Префикс + Период.ИмяКолонки Тогда
				
				Если ТекущиеДанные.Свойство("ФормулаВычисление_" + Период.ИмяКолонки) 
					И НЕ ЗначениеЗаполнено(ТекущиеДанные["ФормулаВычисление_" + Период.ИмяКолонки]) Тогда
					ТекущиеДанные["ФормулаВычисление_" + Период.ИмяКолонки] = ТекстУстановкиНовойФормулы();
				КонецЕсли;
				
				Для каждого ДопРеквизит Из ДопРеквизиты Цикл
					
					ИмяКолонки = ДопРеквизит.Имя + "_" + Период.ИмяКолонки;
					
					Если ТекущиеДанные.Свойство(ИмяКолонки) Тогда
						Форма[ДопРеквизит.Имя] = ТекущиеДанные[ИмяКолонки];
					КонецЕсли;
					
				КонецЦикла;
				
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Функция - возвращает текст установки новой формулы
// 
// Возвращаемое значение:
//  Строка - представление пустой формулы
//
Функция ТекстУстановкиНовойФормулы() Экспорт 

	Возврат НСтр("ru='Задать формулу';uk='Задати формулу'");

КонецФункции 

 
#КонецОбласти


#КонецОбласти
