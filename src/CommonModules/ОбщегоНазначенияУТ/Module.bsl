
#Область ПрограммныйИнтерфейс

#Область МетодыРаботыАвтозаполненияРеквизитовДокумента

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//  Неотрицательный - Булево, если Истина, то числа только положительные, если Ложь, то любые.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти, Неотрицательный = Ложь) Экспорт
	
	Если Неотрицательный Тогда
		Знак = ДопустимыйЗнак.Неотрицательный;
	Иначе
		Знак = ДопустимыйЗнак.Любой;
	КонецЕсли;
	
	Возврат Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, Знак));

КонецФункции // ПолучитьОписаниеТиповЧисла()

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт

	Возврат Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты));

КонецФункции // ПолучитьОписаниеТиповДаты()

//Дополняет одну таблицу значений строками другой таблицы значений
//
//Параметры:
//	Приемник			- произвольная коллекция, в которую добавляются строки
//	Источник 			- произвольная коллекция, из которой беруться добавляемые строки
//	СоответствиеПолей	- Соответствие - используется чтобы заполнить поля с разными названиями, 
//										ключ содержит имя поля приемника, значение содержит имя поля источника
//
Процедура ДобавитьСтрокиВТаблицу(Приемник, Источник, СоответствиеПолей = Неопределено) Экспорт

	Для каждого СтрокаИсточника Из Источник Цикл
		НоваяСтрока = Приемник.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаИсточника);
		Если СоответствиеПолей <> Неопределено Тогда
			Для каждого КлючИЗначение Из СоответствиеПолей Цикл
				НоваяСтрока[КлючИЗначение.Ключ] = СтрокаИсточника[КлючИЗначение.Значение];
			КонецЦикла; 
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры

//Заполняет колонку таблицы значений последовательными номерами
//Параметры:
//	Таблица - таблица значений, строки которой нужно пронумеровать
//	ИмяКолонкиНомераСтроки - колонка таблицы значений, в которой будут указаны номера строк
Процедура ПронумероватьТаблицуЗначений(Таблица, ИмяКолонкиНомераСтроки) Экспорт
	
	Если Таблица.Колонки.Найти(ИмяКолонкиНомераСтроки) = Неопределено Тогда
		Таблица.Колонки.Добавить(ИмяКолонкиНомераСтроки, ПолучитьОписаниеТиповЧисла(15, 0));
	КонецЕсли;
	
	КоличествоСтрок = Таблица.Количество() - 1;
	Для НомерСтроки = 0 По КоличествоСтрок Цикл
		Таблица[НомерСтроки][ИмяКолонкиНомераСтроки] = НомерСтроки;
	КонецЦикла;
	
КонецПроцедуры

// Выгружает таблицу значений из ДанныеФормыКоллекция и ТабличнаяЧасть
//
// Параметры:
// 		ТаблицаИсточник - ДанныеФормыКоллекция, ТабличнаяЧасть - Таблица источник выгрузки
// 		Строки - Массив, Структура - Массив строк для выгрузки или структура отбора
// 		Колонки - Строка - Перечисленные через запятую имена колонок для выгрузки
// 		КолонкиПоЗначению - Структура - Структура колонок для добавление в результирующую таблицу:
// 										Ключ - Имя новой колонки
// 										Значение - Значение для подстановки по все строки новой колонки
// 		НовыеИменаКолонок - Структура - Структура с данными о переименовании колонок в результирующей таблице:
// 										Ключ - Текущее имя колонки
// 										Значение - Новое имя колонки
//
// Возвращаемое значение:
// 		ТаблицаЗначений - Таблица результат выгрузки из таблицы источника с добавленными и переименоваными колонками
//
Функция ВыгрузитьТаблицуЗначений(ТаблицаИсточник, Строки=Неопределено, Колонки, Знач КолонкиПоЗначению=Неопределено, Знач НовыеИменаКолонок=Неопределено) Экспорт
	
	// Определение значений по умолчанию
	Если КолонкиПоЗначению = Неопределено Тогда
		КолонкиПоЗначению = Новый Структура;
	КонецЕсли;
	Если НовыеИменаКолонок = Неопределено Тогда
		НовыеИменаКолонок = Новый Структура;
	КонецЕсли;
	
	// Определить список выгружаемых колонок
	СтруктураДругихИменКолонок = Новый Структура;
	Для Каждого НовоеИмя Из НовыеИменаКолонок Цикл
		СтруктураДругихИменКолонок.Вставить(НовоеИмя.Значение, НовоеИмя.Ключ);
	КонецЦикла;
	ИменаКолонок = "";
	ИмяКолонки = "";
	СтруктураКолонок = Новый Структура(Колонки);
	Для Каждого Колонка Из СтруктураКолонок Цикл
		Если Не СтруктураДругихИменКолонок.Свойство(Колонка.Ключ, ИмяКолонки) Тогда
			ИмяКолонки = Колонка.Ключ;
		КонецЕсли;
		Если Не КолонкиПоЗначению.Свойство(ИмяКолонки) Тогда
			ИменаКолонок = ИменаКолонок + ", " + ИмяКолонки;
		КонецЕсли;
	КонецЦикла;
	
	// Выгрузить из таблицы источника
	Если ТипЗнч(ТаблицаИсточник) = Тип("ТаблицаЗначений") Тогда
		ТаблицаРезультата = ТаблицаИсточник.Скопировать(Строки, Сред(ИменаКолонок, 3));
	Иначе
		ТаблицаРезультата = ТаблицаИсточник.Выгрузить(Строки, Сред(ИменаКолонок, 3));
	КонецЕсли;
	
	// Добавить новые колонки в таблицу результата
	Если КолонкиПоЗначению <> Неопределено Тогда
		Для Каждого Колонка Из КолонкиПоЗначению Цикл
			МассивТипов = Новый Массив;
			МассивТипов.Добавить(ТипЗнч(Колонка.Значение));
			ТаблицаРезультата.Колонки.Добавить(Колонка.Ключ, Новый ОписаниеТипов(МассивТипов));
			ТаблицаРезультата.ЗаполнитьЗначения(Колонка.Значение, Колонка.Ключ);
		КонецЦикла;
	КонецЕсли;
	
	// Переименовать колонки в таблице результата
	Если НовыеИменаКолонок <> Неопределено Тогда
		Для Каждого Колонка Из НовыеИменаКолонок Цикл
			ТаблицаРезультата.Колонки[Колонка.Ключ].Имя = Колонка.Значение;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ТаблицаРезультата;
	
КонецФункции // ВыгрузитьТаблицуЗначений()

//Процедура делает запись в журнал регистрации и сообщает пользователю, если это сообщение об ошибке 
// Параметры:
//   ПараметрыЖурнала - Структура - параметры записи в журнал регистрации
//			Свойства:
//       		ГруппаСобытий - Строка - префикс для имени события журнала регистрации
//       		Метаданные - ОбъектМетаданных - метаданные для записи в журнал регистрации
//       		Данные - Произвольный - данные для записи в журнал регистрации
//   ИмяСобытия - Строка  - имя события (в журнал событие записывается в формате ГруппаСобытий.ИмяСобытия)
//   Уровень - УровеньЖурналаРегистрации  - Соответствует уровням журнала регистрации
//   Комментарий - Строка - комментарий о событии
//   ИнформацияОбОшибке - ИнформацияОбОшибке, Строка - Информация об ошибке, которую так же необходимо задокументировать в комментарии журнала регистрации
//
Процедура ЗаписатьВЖурналСообщитьПользователю(ПараметрыЖурнала, УровеньЖурнала, ИмяСобытия, Знач Комментарий = "", ИнформацияОбОшибке = Неопределено) Экспорт
	
	Если ТипЗнч(ИнформацияОбОшибке) = Тип("ИнформацияОбОшибке") Тогда
		Если Комментарий = "" Тогда
			ТестСообщенияПользователю = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
			Комментарий = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		Иначе
			ТестСообщенияПользователю = Комментарий + Символы.ПС + КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
			Комментарий = Комментарий + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		КонецЕсли;
	Иначе
		Если ТипЗнч(ИнформацияОбОшибке) = Тип("Строка") 
			И Не ПустаяСтрока(ИнформацияОбОшибке) Тогда
			Комментарий = Комментарий + Символы.ПС + ИнформацияОбОшибке;
		КонецЕсли;
		ТестСообщенияПользователю = Комментарий;
	КонецЕсли;
	
	// Журнал регистрации 
	УстановитьПривилегированныйРежим(Истина);
	ЗаписьЖурналаРегистрации(
		ПараметрыЖурнала.ГруппаСобытий + ?(ИмяСобытия = "", "", ". "+ ИмяСобытия), 
		УровеньЖурнала, 
		ПараметрыЖурнала.Метаданные, 
		ПараметрыЖурнала.Данные, 
		Комментарий);
	УстановитьПривилегированныйРежим(Ложь);
	
	Если УровеньЖурнала = УровеньЖурналаРегистрации.Ошибка 
		Или УровеньЖурнала = УровеньЖурналаРегистрации.Предупреждение Тогда
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СокрЛП(ТестСообщенияПользователю),ПараметрыЖурнала.Данные);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает ключ данных для подстановки в сообщение пользователю
// Ключ данных нужен при групповой обработке объектов - если он установлен, то при нажатии пользователем на сообщение
// будет открываться форма объекта
//
//	Параметры:
//		Объект - Произвольный - объект, для которого нужно получить ключ данных
//	
//	Возвращаемое значение
//		Ссылка - ссылка на объект информационной базы
//
Функция КлючДанныхДляСообщенияПользователю(Объект) Экспорт
	
	КлючДанных = Неопределено;
	XMLТипЗнч = XMLТипЗнч(Объект); 
	
	Если XMLТипЗнч <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч.ИмяТипа;
		Если СтрНайти(ТипЗначенияСтрокой, "Object.") > 0 Тогда
			КлючДанных = Объект.Ссылка;
		КонецЕсли;
	КонецЕсли;
	
	Возврат КлючДанных;
	
КонецФункции

// Вызывается из подписки ЗаполнитьРеквизитыОбъекта
// Проверет заполненность реквизитов формы, связанных с фукциональными опциями
// ИспользоватьНесколькоОрганизаций, ИспользоватьНесколькоСкладов, ИспользоватьНесколькоВалют
//
//	Параметры:
//		Объект - Произвольный - объект
//		ДанныеЗаполнения - Структура
//		СтандартнаяОбработка - Структура
//	
//	Возвращаемое значение
//		Ссылка - ссылка на объект информационной базы
//
Процедура ОбработкаЗаполнения(Объект, ДанныеЗаполнения, СтандартнаяОбработка) Экспорт
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоОрганизаций")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "Организация")
		И Не ЗначениеЗаполнено(Объект.Организация) Тогда
		Объект.Организация = ЗначениеНастроекПовтИсп.ПолучитьОрганизациюПоУмолчанию(Объект.Организация);
		Если Не ЗначениеЗаполнено(Объект.Организация) Тогда
			
			Запрос = Новый Запрос(
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
			|	Организации.Ссылка
			|ИЗ
			|	Справочник.Организации КАК Организации");
			
			Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
				ВызватьИсключение НСтр("ru='Не удалось заполнить поле ""Организация"". В информационной базе введено несколько организаций,
                |Включите опцию ""НСИ и администрирование""-""Предприятие""-""Несколько организаций""!'
                |;uk='Не вдалося заповнити поле ""Організація"". В інформаційній базі введено кілька організацій,
                |Увімкніть опцію ""НДІ і адміністрування""-""Підприємство""-""Кілька організацій""!'");
			Иначе
				ВызватьИсключение НСтр("ru='Не удалось заполнить поле ""Организация"". Возможно, в информационной базе не введено ни одной организации!
                |Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Сведения об организации"".'
                |;uk='Не вдалося заповнити поле ""Організація"". Можливо, в інформаційній базі не введено жодної організації!
                |Для настройки необхідно перейти в розділ ""НДІ і адміністрування""-""Відомості про підприємство""-""Відомості про організацію"".'");
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоСкладов")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "Склад")
		И Не ЗначениеЗаполнено(Объект.Склад) Тогда
		Объект.Склад = ЗначениеНастроекПовтИсп.ПолучитьСкладПоУмолчанию(Объект.Склад);
		Если Не ЗначениеЗаполнено(Объект.Склад) Тогда
			
			Запрос = Новый Запрос(
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
			|	Склады.Ссылка
			|ИЗ
			|	Справочник.Склады КАК Склады");
			
			Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
				ВызватьИсключение НСтр("ru='Не удалось заполнить поле ""Склад"". В информационной базе введено несколько складов,
                |Включите опцию ""НСИ и администрирование""-""Склад и доставка""-""Несколько складов""!'
                |;uk='Не вдалося заповнити поле ""Склад"". В інформаційній базі введено кілька складів,
                |Увімкніть опцію ""НДІ і адміністрування""-""Склад і доставка""-""Кілька складів""!'");
			Иначе
				ВызватьИсключение НСтр("ru='Не удалось заполнить поле ""Склад"". Возможно, в информационной базе не введено ни одного склада
                |Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Настройка складского учета"".'
                |;uk='Не вдалося заповнити поле ""Склад"". Можливо, в інформаційній базі не введено жодного складу
                |Для настройки необхідно перейти в розділ ""НДІ і адміністрування""-""Відомості про підприємство""-""Настройка складського обліку"".'");
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоВалют")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "Валюта")
		И Не ЗначениеЗаполнено(Объект.Валюта) Тогда
		Объект.Валюта = ДоходыИРасходыСервер.ПолучитьВалютуУправленческогоУчета(Объект.Валюта);
		Если Не ЗначениеЗаполнено(Объект.Валюта) Тогда
			ВызватьИсключение НСтр("ru='Не удалось заполнить поле ""Валюта"". Установите валюту управленческого учета!';uk='Не вдалося заповнити поле ""Валюта"". Встановіть валюту управлінського обліку!'");
		КонецЕсли;
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоВалют")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "ВалютаВзаиморасчетов")
		И Не ЗначениеЗаполнено(Объект.ВалютаВзаиморасчетов) Тогда
		Объект.ВалютаВзаиморасчетов = ДоходыИРасходыСервер.ПолучитьВалютуУправленческогоУчета(Объект.ВалютаВзаиморасчетов);
		Если Не ЗначениеЗаполнено(Объект.ВалютаВзаиморасчетов) Тогда
			ВызватьИсключение НСтр("ru='Не удалось заполнить поле ""ВалютаВзаиморасчетов"". Установите валюту управленческого учета!';uk='Не вдалося заповнити поле ""ВалютаВзаиморасчетов"". Встановіть валюту управлінського обліку!'");
		КонецЕсли;
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоКасс")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "Касса")
		И Не ЗначениеЗаполнено(Объект.Касса) Тогда
		
		Если Объект.ДополнительныеСвойства.Свойство("НеобходимостьЗаполненияКассыПриФОИспользоватьНесколькоКассЛожь") 
			И НЕ Объект.ДополнительныеСвойства.НеобходимостьЗаполненияКассыПриФОИспользоватьНесколькоКассЛожь Тогда
			// Не требуется заполнение кассы при не включенной опции "ИспользоватьНесколькоКасс"
		Иначе
			
			СтруктураПараметров = ДенежныеСредстваСервер.ПараметрыЗаполненияКассыОрганизацииПоУмолчанию();
			СтруктураПараметров.Касса 			= Объект.Касса;
			Объект.Касса = ЗначениеНастроекПовтИсп.ПолучитьКассуОрганизацииПоУмолчанию(СтруктураПараметров);
			Если Не ЗначениеЗаполнено(Объект.Касса) Тогда
				
				Запрос = Новый Запрос(
				"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
				|	Кассы.Ссылка
				|ИЗ
				|	Справочник.Кассы КАК Кассы
				|ГДЕ
				|	НЕ Кассы.ПометкаУдаления");
				
				Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
					ВызватьИсключение НСтр("ru='Не удалось заполнить поле ""Касса"". В информационной базе введено несколько касс,
                    |Включите опцию ""НСИ и администрирование""-""Казначейство""-""Несколько касс""!'
                    |;uk='Не вдалося заповнити поле ""Каса"". В інформаційній базі введено кілька кас,
                    |Увімкніть опцію ""НДІ і адміністрування""-""Казначейство""-""Кілька кас""!'");
				Иначе
					ВызватьИсключение НСтр("ru='Не удалось заполнить поле ""Касса"". Возможно, в информационной базе не введено ни одной кассы!
                    |Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Настройка кассы"".'
                    |;uk='Не вдалося заповнити поле ""Каса"". Можливо, в інформаційній базі не введено жодної каси!
                    |Для настройки необхідно перейти в розділ ""НДІ і адміністрування""-""Відомості про підприємство""-""Настройка каси"".'");
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоРасчетныхСчетов")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "БанковскийСчет")
		И Не ЗначениеЗаполнено(Объект.БанковскийСчет) Тогда
		
		Если Объект.ДополнительныеСвойства.Свойство("НеобходимостьЗаполненияСчетаПриФОИспользоватьНесколькоСчетовЛожь") 
			И НЕ Объект.ДополнительныеСвойства.НеобходимостьЗаполненияСчетаПриФОИспользоватьНесколькоСчетовЛожь Тогда
			// Не требуется заполнение расчетного счета при не включенной опции "ИспользоватьНесколькоРасчетныхСчетов"
		Иначе
			
			СтруктураПараметров = ДенежныеСредстваСервер.ПараметрыЗаполненияБанковскогоСчетаОрганизацииПоУмолчанию();
			СтруктураПараметров.БанковскийСчет = Объект.БанковскийСчет;  
			Объект.БанковскийСчет = ЗначениеНастроекПовтИсп.ПолучитьБанковскийСчетОрганизацииПоУмолчанию(СтруктураПараметров);
			
			Если Не ЗначениеЗаполнено(Объект.БанковскийСчет) Тогда
				
				Запрос = Новый Запрос(
				"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
				|	БанковскиеСчетаОрганизаций.Ссылка
				|ИЗ
				|	Справочник.БанковскиеСчетаОрганизаций КАК БанковскиеСчетаОрганизаций");
				
				Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
					ВызватьИсключение НСтр("ru='Не удалось заполнить поле ""Банковский счет"". В информационной базе введено несколько банковских счетов организаций,
                    |Включите опцию ""НСИ и администрирование""-""Казначейство""-""Несколько банковских счетов""!'
                    |;uk='Не вдалося заповнити поле ""Банківський рахунок"". В інформаційній базі введено кілька банківських рахунків організацій,
                    |Увімкніть опцію ""НДІ і адміністрування""-""Казначейство""-""Кілька банківських рахунків""!'");
				Иначе
					ВызватьИсключение НСтр("ru='Не удалось заполнить поле ""Банковский счет"". Возможно, в информационной базе не введено ни одного банковского счета организации!
                    |Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Настройка банковского счета"".'
                    |;uk='Не вдалося заповнити поле ""Банківський рахунок"". Можливо, в інформаційній базі не введено жодного банківського рахунку організації!
                    |Для настройки необхідно перейти в розділ ""НДІ і адміністрування""-""Відомості про підприємство""-""Настройка банківського рахунку"".'");
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Функция возвращает изменения документа, относительно записанного в базе
// 
// Параметры:
// 	Объект - ДокументОбъект - Документ, измение которого необходимо проанализировать
// 	РеквизитыИсключения - Структура - Структура имен реквизитов, изменение которых проверять не требуется
// 	ТабличныеЧастиИсключения - Структура - Структура имен табличных частей, изменение которых проверять не требуется
//
// Возвращаемое значение:
// 	Структура - Структура - Содержит изменения объекта:
// 								- по ключу "Реквизиты" - таблица измененных реквизитов
// 								- по ключу "ТабличныеЧасти" - структура низменных табличных частей
Функция ИзмененияДокумента(Объект, РеквизитыИсключения = Неопределено, ТабличныеЧастиИсключения = Неопределено) Экспорт
	
	Результат = Новый Структура;
	
	Если РеквизитыИсключения = Неопределено Тогда
		РеквизитыИсключения = Новый Структура;
	КонецЕсли;
	
	Если ТабличныеЧастиИсключения = Неопределено Тогда
		ТабличныеЧастиИсключения = Новый Структура;
	КонецЕсли;
	
	МетаданныеДокумента = Объект.Метаданные();
	
	ПолноеИмя = МетаданныеДокумента.ПолноеИмя();
	
	СтрокаНеограниченнойДлинны = Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(0));
	
	РеквизитыДокумента = Новый Структура;
	РеквизитыДокумента.Вставить("Дата");
	Для каждого Реквизит Из МетаданныеДокумента.Реквизиты Цикл
		Если СтрНайти(Реквизит.Имя, "Удалить") = 1 Тогда
			Продолжить;
		КонецЕсли;
		Если Реквизит.Тип = СтрокаНеограниченнойДлинны Тогда
			Продолжить;
		КонецЕсли;
		Если РеквизитыИсключения.Свойство(Реквизит.Имя) Тогда
			Продолжить;
		КонецЕсли;
		РеквизитыДокумента.Вставить(Реквизит.Имя);
	КонецЦикла;
	
	ТабличныеЧастиДокумента = Новый Структура;
	Для каждого ТабличнаяЧасть Из МетаданныеДокумента.ТабличныеЧасти Цикл
		Если СтрНайти(ТабличнаяЧасть.Имя, "Удалить") = 1 Тогда
			Продолжить;
		КонецЕсли;
		Если ТабличныеЧастиИсключения.Свойство(ТабличнаяЧасть.Имя) Тогда
			Продолжить;
		КонецЕсли;
		РеквизитыТабличнойЧасти = Новый Структура;
		Для каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл
			Если Реквизит.Тип = СтрокаНеограниченнойДлинны Тогда
				Продолжить;
			КонецЕсли; 
			РеквизитыТабличнойЧасти.Вставить(Реквизит.Имя);
		КонецЦикла;
		ТабличныеЧастиДокумента.Вставить(ТабличнаяЧасть.Имя, РеквизитыТабличнойЧасти);
	КонецЦикла;
	
	ТекстЗапроса= "ВЫБРАТЬ
		|	Таблица.Проведен КАК Проведен";
		ШаблонРеквизит = ",
		|	Таблица.%1 КАК %1";
	Для каждого Реквизит Из РеквизитыДокумента Цикл
		ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ); 
	КонецЦикла;
	
	ШаблонПоместить = "
	|ИЗ
	|	%1 КАК Таблица
	|ГДЕ
	|	Таблица.Ссылка = &Ссылка
	|";
	ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонПоместить, ПолноеИмя);
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка); 
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий(); 
	
	ТаблицаИзмененыхРеквизитов = Новый ТаблицаЗначений;
	ТаблицаИзмененыхРеквизитов.Колонки.Добавить("Имя");
	ТаблицаИзмененыхРеквизитов.Колонки.Добавить("НовоеЗначение");
	ТаблицаИзмененыхРеквизитов.Колонки.Добавить("СтароеЗначение");
	Для каждого Реквизит Из РеквизитыДокумента Цикл
		Если Выборка[Реквизит.Ключ] <> Объект[Реквизит.Ключ] Тогда
			НоваяСтрока = ТаблицаИзмененыхРеквизитов.Добавить();
			НоваяСтрока.Имя = Реквизит.Ключ;
			НоваяСтрока.НовоеЗначение = Объект[Реквизит.Ключ];
			НоваяСтрока.СтароеЗначение = Выборка[Реквизит.Ключ];
		КонецЕсли;
	КонецЦикла;
	
	Если ТаблицаИзмененыхРеквизитов.Количество() > 0 Тогда
		Результат.Вставить("Реквизиты", ТаблицаИзмененыхРеквизитов);
	КонецЕсли;
	
	Для каждого ТабличнаяЧасть Из ТабличныеЧастиДокумента Цикл
		
		ТекстЗапроса = "ВЫБРАТЬ
		|	Таблица.НомерСтроки КАК НомерСтроки";
		ШаблонРеквизит = ",
		|	Таблица.%1 КАК %1";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
		КонецЦикла;
		
		ШаблонПоместить = "
		|ПОМЕСТИТЬ НоваяТаблица%1
		|ИЗ
		|	&%1 КАК Таблица
		|;
		|
		|////////////////////////////
		|";
		ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонПоместить, ТабличнаяЧасть.Ключ);
		
		ТекстОбъединенияНовая =
		"ВЫБРАТЬ
		|	Таблица.НомерСтроки КАК НомерСтроки";
		
		ТекстОбъединенияСтарая =
		"ВЫБРАТЬ
		|	-Таблица.НомерСтроки КАК НомерСтроки";
		
		ШаблонРеквизит = ",
		|	Таблица.%1 КАК %1";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстОбъединенияНовая  = ТекстОбъединенияНовая + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
			ТекстОбъединенияСтарая = ТекстОбъединенияСтарая + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
		КонецЦикла;
		
		ШаблонИзНовая = "
		|ИЗ
		|	НоваяТаблица%1 КАК Таблица";
		ТекстОбъединенияНовая = ТекстОбъединенияНовая + СтрШаблон(ШаблонИзНовая, ТабличнаяЧасть.Ключ);
		
		ШаблонИзСтарая = "
		|ИЗ
		|	%1.%2 КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка = &Ссылка";
		ТекстОбъединенияСтарая = ТекстОбъединенияСтарая + СтрШаблон(ШаблонИзСтарая, ПолноеИмя, ТабличнаяЧасть.Ключ);
		
		ТекстЗапроса = ТекстЗапроса + 
		"ВЫБРАТЬ
		|	СУММА(ВложенныйЗапрос.НомерСтроки) КАК НомерСтроки";
		ШаблонРеквизит = ",
		|	ВложенныйЗапрос.%1 КАК %1";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстЗапроса  = ТекстЗапроса + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
		КонецЦикла;
		ТекстЗапроса = ТекстЗапроса + "
		|ИЗ 
		|(" 
		+ Символы.ПС + ТекстОбъединенияНовая 
		+ Символы.ПС + " ОБЪЕДИНИТЬ ВСЕ "
		+ Символы.ПС + ТекстОбъединенияСтарая + ") КАК ВложенныйЗапрос
		|
		|СГРУППИРОВАТЬ ПО";
		
		ШаблонСгруппировать = "
		|	ВложенныйЗапрос.%1,";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстЗапроса  = ТекстЗапроса + СтрШаблон(ШаблонСгруппировать, Реквизит.Ключ);
		КонецЦикла;
		ТекстЗапроса = ТекстЗапроса + "ИСТИНА
		|ИМЕЮЩИЕ 
		|	СУММА(ВложенныйЗапрос.НомерСтроки) <> 0";
		
		Запрос = Новый Запрос;
		Запрос.Текст = ТекстЗапроса;
		Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка);
		Запрос.УстановитьПараметр(ТабличнаяЧасть.Ключ, Объект[ТабличнаяЧасть.Ключ]);
		
		РезультатЗапроса = Запрос.Выполнить();
		Если НЕ РезультатЗапроса.Пустой() Тогда
			Если НЕ Результат.Свойство("ТабличныеЧасти") Тогда
				Результат.Вставить("ТабличныеЧасти", Новый Структура);
			КонецЕсли;
			Результат.ТабличныеЧасти.Вставить(ТабличнаяЧасть.Ключ, РезультатЗапроса.Выгрузить());
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляПолученияПредставленияДанных

//Возвращает строковое представление документа для отображения в сообщениях
//Параметры
// 		Ссылка - ссылка на документ
// 		Номер - номер документа
// 		Дата - дата документа
Функция ПолучитьПредставлениеДокумента(Ссылка, Номер, Дата) Экспорт
	
	Возврат Ссылка.Метаданные().Синоним + 
		?(ЗначениеЗаполнено(Номер), " " + Номер, "") + 
		?(ЗначениеЗаполнено(Дата), " от " + Формат(Дата,"ДЛФ=D"), "");
	
КонецФункции

#КонецОбласти

#Область ПрочиеПроцедурыИФункции

// Возвращает метаданные объекта по полному имени объекта метаданных
//
// Не обрабатываются точки маршрутов бизнес-процессов
//
// Параметры:
//  ПолноеИмя    - Строка, полное имя объекта метаданных,
//                 например, "Справочник.Организации"
//
// Возвращаемое значение:
//  КоллекцияОбъектовМетаданных
// 
Функция МетаданныеОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".");
	
	КлассОМ = ЧастиИмени[0];
	ИмяОМ   = ЧастиИмени[1];
	
	Если      ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
		Возврат Метаданные.ПланыОбмена[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
		Возврат Метаданные.Справочники[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
		Возврат Метаданные.Документы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЖУРНАЛДОКУМЕНТОВ" Тогда
		Возврат Метаданные.ЖурналыДокументов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
		Возврат Метаданные.Перечисления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОТЧЕТ" Тогда
		Возврат Метаданные.Отчеты[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
		Возврат Метаданные.Обработки[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Возврат Метаданные.ПланыВидовХарактеристик[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
		Возврат Метаданные.ПланыСчетов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Возврат Метаданные.ПланЫВидовРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРСВЕДЕНИЙ" Тогда
		Возврат Метаданные.РегистрыСведений[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРНАКОПЛЕНИЯ" Тогда
		Возврат Метаданные.РегистрыНакопления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРБУХГАЛТЕРИИ" Тогда
		Возврат Метаданные.РегистрыБухгалтерии[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРРАСЧЕТА" Тогда
		Возврат Метаданные.РегистрыРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
		Возврат Метаданные.БизнесПроцессы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
		Возврат Метаданные.Задачи[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "КОНСТАНТА" Тогда
		Возврат Метаданные.Константы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПОСЛЕДОВАТЕЛЬНОСТЬ" Тогда
		Возврат Метаданные.Последовательности[ИмяОМ];
		
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Неизвестный тип объекта метаданных (%1)';uk='Невідомий тип об''єкта метаданих (%1)'"), КлассОМ);
	КонецЕсли;
	
КонецФункции

// Процедура устанавливает блокировку документа для редактирования.
//
// Параметры:
//	ДокументСсылка - документ, на который устанавливается блокировка
//	ОтменятьТранзакцию - Булево - Признак необходимости отмены транзакции
//
Процедура ЗаблокироватьДокументДляРедактирования(ДокументСсылка, ОтменятьТранзакцию = Ложь) Экспорт
	
	Попытка
		ЗаблокироватьДанныеДляРедактирования(ДокументСсылка);
	Исключение
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Не удалось заблокировать %1. %2';uk='Не вдалося заблокувати %1. %2'"),
			ДокументСсылка,
			КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		Если ОтменятьТранзакцию Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
КонецПроцедуры // ЗаблокироватьДокументДляРедактирования()

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// 		Объект                      - ДокументОбъект, СправочникОбъект - Проверяемый объект.
// 		МассивПроверяемыхРеквизитов - Массив - массив проверяемых реквизитов.
//
// Возвращаемое значение:
// 		Булево - Истина, если значение хотя бы одного реквизита не заполнено, иначе Ложь
//
Функция ПроверитьЗаполнениеРеквизитовОбъекта(Объект, МассивПроверяемыхРеквизитов) Экспорт
	
	Перем ПроверяемыеРеквизитыТЧ;
	Отказ = Ложь;
	
	// Получение метаданных объекта
	МетаданныеОбъекта = Объект.Ссылка.Метаданные();
	
	// Создание структуры стандартных реквизитов
	СтандартныеРеквизиты = Новый Структура;
	Для Каждого Реквизит Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		СтандартныеРеквизиты.Вставить(Реквизит.Имя, ?(ЗначениеЗаполнено(Реквизит.Синоним), Реквизит.Синоним, Реквизит.Имя));
	КонецЦикла;
	
	// Создание структуры для хранения имен табличных частей и проверяемых реквизитов в них.
	// 		Ключ -  Имя табличной части
	// 		Значение - Массив - Массив строк, реквизитов этой табличной части для проверки
	ТабличныеЧасти = Новый Структура;
	
	// Создание шаблонов сообщений об ошибках не заполненных реквизитов и реквизитов табличных частей
	ШаблонОшибкиРеквизита = НСтр("ru='Поле ""%ИмяРеквизита%"" не заполнено';uk='Поле ""%ИмяРеквизита%"" не заповнено'");
	ШаблонОшибкиТЧ = НСтр("ru='Не введено ни одной строки в список ""%ИмяРеквизита%""';uk='Не введено жодного рядка в список ""%ИмяРеквизита%""'");
	ШаблонОшибкиРеквизитаТЧ = НСтр("ru='Не заполнена колонка ""%ИмяРеквизита%"" в строке %НомерСтроки% списка ""%ИмяТабличнойЧасти%""';uk='Не заповнена колонка ""%ИмяРеквизита%"" в рядку %НомерСтроки% списку ""%ИмяТабличнойЧасти%""'");
	
	// Проверка реквизитов объекта и заполнение структуры по реквизитам табличных частей
	Для Каждого Реквизит Из МассивПроверяемыхРеквизитов Цикл
		
		ПозицияТочки = СтрНайти(Реквизит,".");
		
		Если ПозицияТочки > 0 Тогда // В случае если указан реквизит табличной части
			
			ДлинаСтроки       = СтрДлина(Реквизит);
			ИмяТабличнойЧасти = Лев(Реквизит, ПозицияТочки-1);
			ИмяРеквизита      = Прав(Реквизит, ДлинаСтроки - ПозицияТочки);
			
			// Сохранение проверяемого реквизита табличной части в структуру
			Если НЕ ТабличныеЧасти.Свойство(ИмяТабличнойЧасти, ПроверяемыеРеквизитыТЧ) Тогда
				ПроверяемыеРеквизитыТЧ = Новый Массив;
				ТабличныеЧасти.Вставить(ИмяТабличнойЧасти, ПроверяемыеРеквизитыТЧ);
			КонецЕсли;
			ПроверяемыеРеквизитыТЧ.Добавить(ИмяРеквизита);
			
		Иначе // В случае если указан реквизит объекта
			
			Если Не ЗначениеЗаполнено(Объект[Реквизит]) Тогда
				
				Если МетаданныеОбъекта.Реквизиты.Найти(Реквизит) <> Неопределено Тогда // Если указано имя реквизита
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизита, "%ИмяРеквизита%",
						МетаданныеОбъекта.Реквизиты[Реквизит].Синоним);
				ИначеЕсли СтандартныеРеквизиты.Свойство(Реквизит) Тогда // Если указано имя стандартного реквизита
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизита, "%ИмяРеквизита%",
						СтандартныеРеквизиты[Реквизит]);
				Иначе // Если указано имя табличной части
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиТЧ, "%ИмяРеквизита%",
						МетаданныеОбъекта.ТабличныеЧасти[Реквизит].Синоним);
				КонецЕсли;
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
					ТекстОшибки,
					Объект,
					Реквизит,
					,
					Отказ);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Проверка реквизитов в табличных частях
	Для Каждого ТабличнаяЧасть Из ТабличныеЧасти Цикл
		
		ИмяТабличнойЧасти = ТабличнаяЧасть.Ключ;
		ТабличнаяЧастьОбъекта = Объект[ТабличнаяЧасть.Ключ];
		МассивРеквизитов = ТабличнаяЧасть.Значение;
		
		// Цикл по всем строкам табличной части.
		Для НомерСтроки=0 По ТабличнаяЧастьОбъекта.Количество()-1 Цикл
			
			// Цикл по всем проверяемым реквизитам для текущей табличной части.
			Для НомерРеквизита=0 По МассивРеквизитов.Количество()-1 Цикл
				
				ИмяРеквизита = МассивРеквизитов[НомерРеквизита];
				
				Если Не ЗначениеЗаполнено(ТабличнаяЧастьОбъекта[НомерСтроки][ИмяРеквизита]) Тогда
					
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизитаТЧ, "%ИмяРеквизита%", МетаданныеОбъекта.ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты[ИмяРеквизита].Синоним);
					ТекстОшибки = СтрЗаменить(ТекстОшибки, "%НомерСтроки%", Формат(НомерСтроки+1, "ЧГ=0"));
					ТекстОшибки = СтрЗаменить(ТекстОшибки, "%ИмяТабличнойЧасти%", МетаданныеОбъекта.ТабличныеЧасти[ИмяТабличнойЧасти].Синоним);
					
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
						ТекстОшибки,
						Объект,
						ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТабличнойЧасти, НомерСтроки+1, ИмяРеквизита),
						,
						Отказ);
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	МассивПроверяемыхРеквизитов.Очистить();
	
	Возврат Отказ;
	
КонецФункции // ПроверитьЗаполнениеРеквизитовОбъекта()

// Осуществляет проверку соответствия организации документа и хозяйственной операции.
//
Процедура ПроверитьПравильностьУказанияХозяйственнойОперации(ДокументОбъект, Отказ) Экспорт
	
	Если ДокументОбъект.Организация = Справочники.Организации.УправленческаяОрганизация
	   И (ДокументОбъект.ХозяйственнаяОперация = Перечисления.ХозяйственныеОперации.РеализацияКлиентуРеглУчет
	 ИЛИ ДокументОбъект.ХозяйственнаяОперация = Перечисления.ХозяйственныеОперации.ЗакупкаУПоставщикаРеглУчет) Тогда
	 
		Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='В документе нельзя указывать операцию %1 и управленческую организацию';uk='В документі не можна вказувати операцію %1 і управлінську організацію'"),
			ДокументОбъект.ХозяйственнаяОперация);
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
			Текст,
			ДокументОбъект,
			"ХозяйственнаяОперация",
			,
			Отказ);
	 
	КонецЕсли;
	
КонецПроцедуры // ПроверитьПравильностьУказанияХозяйственнойОперации()

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// Документ           - ДокументСсылка - Документ, на основании которого осуществляется ввод
// Статус             - Статус документ, на основании которого осуществляется ввод
// ЕстьОшибкиПроведен - Булево - Если Истина - документ, на основании которого осуществляется ввод, не проведен
// ЕстьОшибкиСтатус   - Булево - Если Истина - документ, на основании которого осуществляется ввод, имеет некорректный статус
// СоглашениеДоступноВнешнемуПользователю Булево - Если Истина - документ на основаннии которого осуществляется ввод имеет соглашение
//                                                               доступное внешнему пользователю.
//
Процедура ПроверитьВозможностьВводаНаОсновании(Документ,
	                                           Статус = Неопределено,
	                                           ЕстьОшибкиПроведен = Ложь,
	                                           ЕстьОшибкиСтатус = Ложь,
	                                           МассивДопустимыхСтатусов = Неопределено,
	                                           СоглашениеДоступноВнешнемуПользователю = Неопределено) Экспорт
	
	Если ЕстьОшибкиПроведен Тогда
		
		ТекстОшибки = НСтр("ru='Документ %Документ% не проведен. Ввод на основании непроведенного документа запрещен.';uk='Документ %Документ% не проведено. Введення на підставі непроведенного документа заборонене.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
	
		ВызватьИсключение ТекстОшибки;
		
	ИначеЕсли ЕстьОшибкиСтатус Тогда
		
		Если МассивДопустимыхСтатусов = Неопределено Тогда
			ТекстОшибки = НСтр("ru='Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании запрещен.';uk='Документ %Документ% знаходиться в статусі ""%Статус%"". Введення на підставі заборонене.'");
		ИначеЕсли ТипЗнч(МассивДопустимыхСтатусов) = Тип("Массив") Тогда
			
			ТекстОшибки = НСтр("ru='Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании разрешен в %СтрокаДопустимыхСтатусов%.';uk='Документ %Документ% знаходиться в статусі ""%Статус%"". Введення на підставі дозволене в %СтрокаДопустимыхСтатусов%.'");
			СтрокаДопустимыхСтатусов = "";
			
			Для Каждого ДопустимыйСтатус Из МассивДопустимыхСтатусов Цикл
				СтрокаДопустимыхСтатусов = СтрокаДопустимыхСтатусов + """"+ ДопустимыйСтатус + """, ";
			КонецЦикла;
			
			СтрокаДопустимыхСтатусов = Лев(СтрокаДопустимыхСтатусов, СтрДлина(СтрокаДопустимыхСтатусов)-2);
			
			Если МассивДопустимыхСтатусов.Количество() = 0 Тогда
				ТекстОшибки = НСтр("ru='Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании запрещен.';uk='Документ %Документ% знаходиться в статусі ""%Статус%"". Введення на підставі заборонене.'");
			ИначеЕсли МассивДопустимыхСтатусов.Количество() = 1 Тогда
				ТекстОшибки = НСтр("ru='Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании разрешен только в статусе %СтрокаДопустимыхСтатусов%.';uk='Документ %Документ% знаходиться в статусі ""%Статус%"". Введення на підставі дозволений тільки в статусі %СтрокаДопустимыхСтатусов%.'");
				ТекстОшибки = СтрЗаменить(ТекстОшибки, "%СтрокаДопустимыхСтатусов%", СтрокаДопустимыхСтатусов);
			Иначе
				ТекстОшибки = НСтр("ru='Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании разрешен только в статусах %СтрокаДопустимыхСтатусов%.';uk='Документ %Документ% знаходиться в статусі ""%Статус%"". Введення на підставі дозволене тільки в статусах %СтрокаДопустимыхСтатусов%.'");
				ТекстОшибки = СтрЗаменить(ТекстОшибки, "%СтрокаДопустимыхСтатусов%", СтрокаДопустимыхСтатусов);
			КонецЕсли;
			
		КонецЕсли;
		
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Статус%",   Статус);
	
		ВызватьИсключение ТекстОшибки;
		
	ИначеЕсли ОбщегоНазначенияУТКлиентСервер.АвторизованВнешнийПользователь() И НЕ СоглашениеДоступноВнешнемуПользователю = Истина Тогда
		
		ТекстОшибки = НСтр("ru='Соглашение документа %Документ% недоступно для работы при самообслуживании. Ввод на основании запрещен.';uk='Оферта документа %Документ% недоступна для роботи при самообслуговуванні. Введення на підставі заборонений.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
		
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьВозможностьВводаНаОсновании()

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// Документ                            - ДокументСсылка - Документ, на основании которого осуществляется ввод
// ЕстьОшибкиПроведен                  - Булево - Если Истина - документ, на основании которого осуществляется ввод, не проведен
// ЕстьОшибкиВернутьМногооборотнуюТару - Булево - Если Истина - по документу, на основании которого осуществляется ввод, тара не возвратная
//
Процедура ПроверитьВозможностьВводаНаОснованииВыкупаТары(Документ, ЕстьОшибкиПроведен, ЕстьОшибкиВернутьМногооборотнуюТару) Экспорт
	
	Если ЕстьОшибкиПроведен Тогда
		
		ТекстОшибки = НСтр("ru='Документ %Документ% не проведен. Ввод на основании непроведенного документа запрещен.';uk='Документ %Документ% не проведено. Введення на підставі непроведенного документа заборонене.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
	
		ВызватьИсключение ТекстОшибки;
		
	ИначеЕсли ЕстьОшибкиВернутьМногооборотнуюТару Тогда
		
		ТекстОшибки = НСтр("ru='В документе %Документ% не стоит признак возврата многооборотной тары. Ввод на основании запрещен.';uk='У документі %Документ% не встановлена ознака повернення багатооборотної тари. Введення на підставі заборонене.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// ЕстьОшибкиТиповое  - Булево - Если Истина - соглашение, на основании которого осуществляется ввод - типовое
// ЭтоАгентскиеУслуги  - Булево - Если Истина - соглашение, на основании которого осуществляется ввод - соглашение по оказанию агентских услуг
//
Процедура ПроверитьВозможностьВводаНаОснованииСоглашения(ЕстьОшибкиТиповое = Ложь, ЭтоАгентскиеУслуги = Ложь) Экспорт
	
	Если ЕстьОшибкиТиповое Тогда
		
		ТекстОшибки = НСтр("ru='Ввод на основании типового соглашения с клиентом запрещен.';uk='Введення на підставі типової оферти з клієнтом заборонене.'");
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
	Если ЭтоАгентскиеУслуги Тогда
		
		ТекстОшибки = НСтр("ru='Ввод на основании типового соглашения по оказанию агентских услуг запрещен.';uk='Введення на підставі типової оферти з надання агентських послуг заборонене.'");
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьВозможностьВводаНаОснованииСоглашения()

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// Партнер - СправочникСсылка.Партнеры - Партнер из сделки по продаже
//
Процедура ПроверитьВозможностьВводаНаОснованииСделкиПоПродаже(Партнер) Экспорт
	
	Если Не ЗначениеЗаполнено(Партнер) Тогда
		
		ТекстОшибки = НСтр("ru='В сделке не указан партнер, ввод на основании запрещен.';uk='В угоді не вказано партнер, введення на підставі заборонене.'");
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьВозможностьВводаНаОснованииСделкиПоПродаже()

// Устанавливает или сбрасывает флаг Согласован у справочника.
// Вызывается из процедуры ПередЗаписью документа.
//
// Параметры:
// ДокументОбъект     - СправочникОбъект - Справочник, в котором необходимо изменить флаг Согласован
// СтатусНеСогласован - Статус документа, в котором флаг Согласован должен быть сброшен
//
Процедура ИзменитьПризнакСогласованностиСправочника(СправочникОбъект, Знач СтатусНеСогласован = Неопределено) Экспорт
	
	// Справочник не имеет статуса
	Если СтатусНеСогласован = Неопределено Тогда
		
		Если Не СправочникОбъект.Согласован Тогда
			СправочникОбъект.Согласован = Истина;
		КонецЕсли;
		
	// Справочник имеет статус, в котором проведенный справочник не согласован
	Иначе
		
		Если СправочникОбъект.Статус = СтатусНеСогласован И СправочникОбъект.Согласован Тогда
			СправочникОбъект.Согласован = Ложь;
		ИначеЕсли СправочникОбъект.Статус <> СтатусНеСогласован И Не СправочникОбъект.Согласован Тогда
			СправочникОбъект.Согласован = Истина;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры // ИзменитьПризнакСогласованностиСправочника()

// Устанавливает или сбрасывает флаг Согласован у документа.
// Вызывается из процедуры ПередЗаписью документа.
//
// Параметры:
// ДокументОбъект     - ДокументОбъект - Документ, в котором необходимо изменить флаг Согласован
// РежимЗаписи        - Режим записи документа
// СтатусНеСогласован - Статус документа, в котором флаг Согласован должен быть сброшен
//
Процедура ИзменитьПризнакСогласованностиДокумента(ДокументОбъект, Знач РежимЗаписи, Знач СтатусНеСогласован = Неопределено) Экспорт
	
	Если РежимЗаписи = РежимЗаписиДокумента.Запись Или
		 РежимЗаписи = РежимЗаписиДокумента.ОтменаПроведения Тогда
		
		Если ДокументОбъект.Согласован Тогда
			ДокументОбъект.Согласован = Ложь;
		КонецЕсли;
		
	ИначеЕсли РежимЗаписи = РежимЗаписиДокумента.Проведение Тогда
		
		// Документ не имеет статуса
		Если СтатусНеСогласован = Неопределено Тогда
		
			Если Не ДокументОбъект.Согласован Тогда
				ДокументОбъект.Согласован = Истина;
			КонецЕсли;
			
		// Документ имеет статус из массива, в которых проведенный документ не согласован
		ИначеЕсли ТипЗнч(СтатусНеСогласован) = Тип("Массив") Тогда
			
			Если ДокументОбъект.Согласован Тогда
				
				Для Каждого ТекСтатус Из СтатусНеСогласован Цикл
					
					Если ДокументОбъект.Статус = ТекСтатус Тогда
						
						ДокументОбъект.Согласован = Ложь;
						Прервать;
						
					КонецЕсли;
					
				КонецЦикла;
				
			Иначе
				
				ДокументСогласован = Истина;
				
				Для Каждого ТекСтатус Из СтатусНеСогласован Цикл
					
					Если ДокументОбъект.Статус = ТекСтатус Тогда
						ДокументСогласован = Ложь;
					КонецЕсли;
					
				КонецЦикла;
				
				Если ДокументСогласован Тогда
					ДокументОбъект.Согласован = Истина;
				КонецЕсли;
				
			КонецЕсли;
			
		// Документ имеет статус, в котором проведенный документ не согласован
		Иначе
			
			Если ДокументОбъект.Статус = СтатусНеСогласован И ДокументОбъект.Согласован Тогда
				ДокументОбъект.Согласован = Ложь;
			ИначеЕсли ДокументОбъект.Статус <> СтатусНеСогласован И Не ДокументОбъект.Согласован Тогда
				ДокументОбъект.Согласован = Истина;
			КонецЕсли;
			
		КонецЕсли;

	КонецЕсли;
	
КонецПроцедуры // ИзменитьПризнакСогласованностиДокумента()

// Настраивает подключаемое оборудование в форме,
// устанавливает флаг ИспользоватьПодключаемоеОборудование в форме
// Параметры:
//   Форма - Форма, в которой необходимо настроить подключаемое оборудование
//
Процедура НастроитьПодключаемоеОборудование(Форма, ПрефиксыЭлементовФормы = "Товары") Экспорт
	
	ТипыПодключенногоОборудования = ПодключаемоеОборудованиеУТПовтИсп.ТипыПодключенногоОборудования();
	
	Форма.ИспользоватьПодключаемоеОборудование = ИспользоватьПодключаемоеОборудование(ТипыПодключенногоОборудования);
	
	ЕстьТСД  =
		ТипыПодключенногоОборудования <> Неопределено
		И ТипыПодключенногоОборудования.Найти(Перечисления.ТипыПодключаемогоОборудования.ТерминалСбораДанных) <> Неопределено;
	ЕстьВесы =
		ТипыПодключенногоОборудования <> Неопределено
		И ТипыПодключенногоОборудования.Найти(Перечисления.ТипыПодключаемогоОборудования.ЭлектронныеВесы) <> Неопределено;
		
	Если ЗначениеЗаполнено(ПрефиксыЭлементовФормы) Тогда
		МассивПрефиксыЭлементовФормы = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПрефиксыЭлементовФормы, ",");
	Иначе
		МассивПрефиксыЭлементовФормы = Новый Массив;
		МассивПрефиксыЭлементовФормы.Добавить(ПрефиксыЭлементовФормы);
	КонецЕсли;
	
	Для Каждого Префикс Из МассивПрефиксыЭлементовФормы Цикл
		
		ОбщегоНазначенияУТКлиентСервер.УстановитьСвойствоЭлементаФормы(
			Форма.Элементы,
			Префикс + "ЗагрузитьДанныеИзТСД",
			"Видимость",
			Форма.ИспользоватьПодключаемоеОборудование И ЕстьТСД);
		
		ОбщегоНазначенияУТКлиентСервер.УстановитьСвойствоЭлементаФормы(
			Форма.Элементы,
			Префикс + "ВыгрузитьДанныеВТСД",
			"Видимость",
			Форма.ИспользоватьПодключаемоеОборудование И ЕстьТСД);
		
		ОбщегоНазначенияУТКлиентСервер.УстановитьСвойствоЭлементаФормы(
			Форма.Элементы,
			Префикс + "ПолучитьВес",
			"Видимость",
			Форма.ИспользоватьПодключаемоеОборудование И ЕстьВесы);
		
	КонецЦикла;
	
КонецПроцедуры

// Проверяет, что включена ф.о "Использовать подключаемое оборудование",
// настроено ли оборудование и авторизовался пользователь,
// а не внешний пользователь.
Функция ИспользоватьПодключаемоеОборудование(ТипыПодключенногоОборудования = Неопределено) Экспорт
	
	ИспользоватьПодключаемоеОборудование = ПолучитьФункциональнуюОпцию("ИспользоватьПодключаемоеОборудование");
	ПользовательАвторизовался 			 = ТипЗнч(Пользователи.АвторизованныйПользователь()) = Тип("СправочникСсылка.Пользователи");
	
	Если ТипыПодключенногоОборудования = Неопределено Тогда
		ТипыПодключенногоОборудования = ПодключаемоеОборудованиеУТПовтИсп.ТипыПодключенногоОборудования();
	КонецЕсли;
	
	Возврат
		ИспользоватьПодключаемоеОборудование
		И ПользовательАвторизовался
		И ТипыПодключенногоОборудования <> Неопределено
		И ТипыПодключенногоОборудования.Количество() > 0;
												 
КонецФункции

// Возвращает список пользователей, имеющих роли, указанные в качестве параметра
//
// Параметры:
// 		МассивРолей - Массив - массив с именами ролей
// 		ПредставлениеТекущегоПользователя - Строка - представление текущего пользователя
// 
//	Возвращаемое значение:
//		СписокЗначений с элементами СправочникСсылка.Пользователи
//
Функция ПолучитьСписокПользователейПоМассивуРолей(МассивРолей, ПредставлениеТекущегоПользователя = Неопределено) Экспорт
	
	СписокПользователей = Новый СписокЗначений;
	Если ПредставлениеТекущегоПользователя = Неопределено Тогда
		ПредставлениеТекущегоПользователя = НСтр("ru='<Мои документы>';uk='<Мої документи>'");
	КонецЕсли;
	
	// Запрос получения списка всех пользователей. Выполняется в привилегированном режиме
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ПрофилиГруппДоступаРоли.Ссылка КАК Ссылка
	|ПОМЕСТИТЬ ПрофилиГруппДоступа
	|ИЗ
	|	Справочник.ПрофилиГруппДоступа.Роли КАК ПрофилиГруппДоступаРоли
	|ГДЕ
	|	ПрофилиГруппДоступаРоли.Роль.Имя В(&МассивРолей)
	|
	|СГРУППИРОВАТЬ ПО
	|	ПрофилиГруппДоступаРоли.Ссылка
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Ссылка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ЕСТЬNULL(ГруппыПользователейСостав.Пользователь, ГруппыДоступаПользователи.Пользователь) КАК Пользователь
	|ИЗ
	|	Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ГруппыПользователей.Состав КАК ГруппыПользователейСостав
	|		ПО ГруппыДоступаПользователи.Пользователь = ГруппыПользователейСостав.Ссылка
	|ГДЕ
	|	ГруппыДоступаПользователи.Ссылка.Профиль В
	|			(ВЫБРАТЬ
	|				ПрофилиГруппДоступа.Ссылка
	|			ИЗ
	|				ПрофилиГруппДоступа КАК ПрофилиГруппДоступа)
	|
	|СГРУППИРОВАТЬ ПО
	|	ЕСТЬNULL(ГруппыПользователейСостав.Пользователь, ГруппыДоступаПользователи.Пользователь)";
	
	Запрос.УстановитьПараметр("МассивРолей", МассивРолей);
	
	МассивВсехПользователей = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Пользователь");
	
	УстановитьПривилегированныйРежим(Ложь);
	
	// Запрос получения списка "разрешенных" пользователей
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Пользователи.Ссылка КАК Пользователь
	|ИЗ
	|	Справочник.Пользователи КАК Пользователи
	|ГДЕ
	|	Пользователи.Ссылка В(&МассивПользователей)
	|	И Пользователи.ПометкаУдаления = ЛОЖЬ
	|	И Пользователи.Недействителен = ЛОЖЬ
	|
	|УПОРЯДОЧИТЬ ПО
	|	Пользователи.Наименование";
	Запрос.УстановитьПараметр("МассивПользователей", МассивВсехПользователей);
	
	ТекущийПользователь = Пользователи.ТекущийПользователь();
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если ТекущийПользователь = Выборка.Пользователь Тогда
			СписокПользователей.Вставить(0, Выборка.Пользователь, ПредставлениеТекущегоПользователя);
		Иначе
			СписокПользователей.Добавить(Выборка.Пользователь);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СписокПользователей;
	
КонецФункции

// Возвращает список пользователей, имеющих право на изменение объекта метаданных
//
// Параметры:
// 		ОбъектМетаданных - Метаданные - объект метаданных, на которые проверяются права доступа
// 		ПредставлениеТекущегоПользователя - Строка - представление текущего пользователя
// 
//	Возвращаемое значение:
//		СписокЗначений с элементами СправочникСсылка.Пользователи
//
Функция ПолучитьСписокПользователейСПравомДобавления(ОбъектМетаданных, ПредставлениеТекущегоПользователя = Неопределено) Экспорт
	
	ИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
	МассивРолей = ПраваПользователяПовтИсп.ИменаРолейСПравомДобавления(ИмяОбъектаМетаданных);
	
	Если НЕ ЗначениеЗаполнено(МассивРолей) Тогда
		Возврат Новый СписокЗначений;
	КонецЕсли;
	
	Возврат ПолучитьСписокПользователейПоМассивуРолей(МассивРолей, ПредставлениеТекущегоПользователя);;
	
КонецФункции

Функция СвернутьТаблицуЗначенийПоРеквизиту(ТаблицаРеквизитыДокументов, ИмяРеквизита) Экспорт
	
	Таблица = ТаблицаРеквизитыДокументов.Скопировать();
	Таблица.Свернуть(ИмяРеквизита);
	Возврат Таблица;
	
КонецФункции // СвернутьТаблицуЗначенийПоРеквизиту()

// Функция проверяет наличие согласующего по указанной роли в регистре сведений Исполнители задач
//
//Параметры:
//	ПроверяемаяРоль - Ссылка на роль исполнителя - Элемент справочника РолиИсполнителей
//
Функция ПроверитьСогласующегоБизнесПроцесс(ПроверяемаяРоль) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ИсполнителиЗадач.Исполнитель КАК ЕстьИсполнитель
		|ИЗ
		|	РегистрСведений.ИсполнителиЗадач КАК ИсполнителиЗадач
		|ГДЕ
		|	ИсполнителиЗадач.РольИсполнителя =&РольИсполнителя";

	Запрос.УстановитьПараметр("РольИсполнителя", ПроверяемаяРоль);
	Результат = Запрос.Выполнить();
	ВыборкаДетальныеЗаписи = Результат.Выбрать();

	Если ВыборкаДетальныеЗаписи.Следующий() Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
КонецФункции // ПроверитьСогласующегоБизнесПроцесс()

//Фукнция раскладывает переданный массив сслылок в соотвествие по типам этих ссылок
//
//	Параметры:
//		МассивСсылок - Массив - массив ссылок на объекты информационной базы
//  Возвращаемое значение:
//		Соотвествие:
//			Ключ - полное имя типа ссылки
//	        Значение - массив ссылок этого типа
//
Функция СоответствиеМассивовПоТипамОбъектов(МассивСсылок) Экспорт
	
	СоответствиеТипов = Новый Соответствие;
	
	Для Каждого Объект Из МассивСсылок Цикл
		
		ТипОбъекта = Объект.Метаданные().ПолноеИмя();
		ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта);
		
		Если ТекущийТипОбъекта = Неопределено Тогда
			СоответствиеТипов.Вставить(ТипОбъекта, Новый Массив);
			ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта);
		КонецЕсли;
		ТекущийТипОбъекта.Добавить(Объект);
		
	КонецЦикла;
	
	Возврат СоответствиеТипов;
	
КонецФункции

// Возвращает разницу между двумя датами (в днях)
//
// Параметры
//  ДатаНачала 		- Дата - начальная дата периода
//  ДатаОкончания	- Дата - конечная дата периода
//
// Возвращаемое значение:
//   Число	 - количество дней между двумя датами
//
Функция РазностьДат(ДатаНачала, ДатаОкончания, Периодичность) Экспорт
	
	СекундВМинуте = 60;
	МинутВЧасе = 60;
	ЧасовВДне = 24;
	
	Если Периодичность = Перечисления.Периодичность.Год Тогда
		Возврат Год(ДатаОкончания) - Год(ДатаНачала);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Полугодие Тогда
		Возврат ?(Месяц(ДатаОкончания)>6, 2, 1) - ?(Месяц(ДатаНачала)>6, 2, 1) + 2*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
		Возврат Цел(Месяц(НачалоКвартала(ДатаОкончания))/3) - Цел(Месяц(НачалоКвартала(ДатаНачала))/3) + 4*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
		Возврат Месяц(ДатаОкончания) - Месяц(ДатаНачала) + 12*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Декада Тогда
		Возврат Цел((ДатаОкончания - ДатаНачала)/(10 * СекундВМинуте*МинутВЧасе*ЧасовВДне));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
		Возврат Цел((НачалоНедели(ДатаОкончания) - НачалоНедели(ДатаНачала))/(7 * СекундВМинуте*МинутВЧасе*ЧасовВДне));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.День Тогда
		Возврат (ДатаОкончания - ДатаНачала)/(СекундВМинуте*МинутВЧасе*ЧасовВДне);
		
	КонецЕсли;
	
КонецФункции

// Проверяет использование объекта
//
// Параметры:
//  Параметры		- Структура - содержит объект использование которого нужно проверить
//  АдресХранилища	- Строка - адрес хранилища в которое будут помещен результат проверки
//
Процедура ПроверитьИспользованиеОбъекта(Параметры, АдресХранилища) Экспорт
	
	ЕстьСсылки = ОбщегоНазначенияВызовСервера.ЕстьСсылкиНаОбъект(Параметры.Объект);
	
	ПоместитьВоВременноеХранилище(ЕстьСсылки, АдресХранилища);
	
КонецПроцедуры

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект
// см. ОбщегоНазначения.ЗначениеРеквизитаОбъекта()
// Если полученное значение не имеет тип булево, возвращается значение Ложь
//
Функция ЗначениеРеквизитаОбъектаТипаБулево(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита);
	Если ТипЗнч(Результат) <> Тип("Булево") Тогда
		Результат = ЛожЬ;
	КонецЕсли;
	
	Возврат Результат
	
КонецФункции

Функция КлючКоллекцииПоЗначению(Коллекция, Значение) Экспорт
	
	Для Каждого КлючИЗначение Из Коллекция Цикл
		Если КлючИЗначение.Значение = Значение Тогда
			Возврат КлючИЗначение.Ключ;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

Функция ПоменятьКлючИЗначениеКоллекции(Коллекция) Экспорт
	
	Если ТипЗнч(Коллекция) = Тип("Структура") ИЛИ ТипЗнч(Коллекция) = Тип("ФиксированнаяСтруктура") Тогда
		НоваяКоллекция = Новый Структура;
	ИначеЕсли ТипЗнч(Коллекция) = Тип("Соответствие") ИЛИ ТипЗнч(Коллекция) = Тип("ФиксированноеСоответствие") Тогда
		НоваяКоллекция = Новый Соответствие;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из Коллекция Цикл
		НоваяКоллекция.Вставить(КлючИЗначение.Значение, КлючИЗначение.Ключ);
	КонецЦикла;
	
	Если ТипЗнч(Коллекция) = Тип("ФиксированнаяСтруктура") Тогда
		НоваяКоллекция = Новый ФиксированнаяСтруктура(НоваяКоллекция);
	ИначеЕсли ТипЗнч(Коллекция) = Тип("ФиксированноеСоответствие") Тогда
		НоваяКоллекция = Новый ФиксированноеСоответствие(НоваяКоллекция);
	КонецЕсли;
	
	Возврат НоваяКоллекция;
	
КонецФункции

//Возвращает количество документов прописью
//Параметры:
//  КоличествоДокументов - Число - Количество документов
//Возвращаемое значение:
//  Строка - Количество документов прописью
Функция ЧислоДокументовПрописью(КоличествоДокументов) Экспорт
	
	КоличествоПрописью = ЧислоПрописью(
		КоличествоДокументов,
		"Л = ru_RU; НП = Истина; НД = Ложь; ДП = Ложь;",
		НСтр("ru='документа,документа,документов,м,,,,,0';uk='документа,документа,документів,м,,,,,0'"));
	Поз = СтрНайти(КоличествоПрописью, "документ");
	Если Поз <> 0 Тогда
		КоличествоПрописью = Сред(КоличествоПрописью, Поз);
	КонецЕсли;
	КоличествоПрописью = Строка(КоличествоДокументов) + " " + НРег(КоличествоПрописью);
	
	Возврат КоличествоПрописью;
	
КонецФункции

// Возвращает описание типов по переданному типу
// 
// Параметры:
//	Тип - Тип - тип значения
//
// Возвращаемое значение:
//	ОписаниеТипов - созданное на основании переданного типа описание типов
//
Функция ОписаниеТиповПоТипу(Тип) Экспорт
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип);
	
	ОписаниеТипов = Новый ОписаниеТипов(МассивТипов);
	
	Возврат ОписаниеТипов;
КонецФункции

// Возвращает таблицу значений на основании массива структур
// 
// Параметры:
//	МассивСтруктур - МассивСтруктур - массив структур, которые будут преобразованы в таблиц значений.
//										Свойства структуры первого элемента массива определяютс состав колонок результирующей таблицы
//
// Возвращаемое значение:
//	ТаблицаЗначений - таблица значений, созданная из массива структур
// 
Функция МассивВТаблицуЗначений(МассивСтруктур) Экспорт
	Таблица = Новый ТаблицаЗначений;
	// Создадим колонки по первой структуре массива
	Если ТипЗнч(МассивСтруктур) = Тип("Массив")
		И МассивСтруктур.Количество() <> 0 Тогда
		ПерваяСтруктура = МассивСтруктур[0];
		Для Каждого Свойство Из ПерваяСтруктура Цикл 
			Таблица.Колонки.Добавить(Свойство.Ключ, ОписаниеТиповПоТипу(ТипЗнч(Свойство.Значение)));
		КонецЦикла;
		
		Для Каждого Структура Из МассивСтруктур Цикл 
			НоваяСтрока = Таблица.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Структура);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Таблица;
КонецФункции

// Формирует пакет запросов и возвращает результат каждого запроса
//
// Параметры:
//	Запрос			- Запрос - запрос, параметры которого предварительно установлены.
//	ТекстыЗапроса	- Список значений - в списке перечислены тексты запросов и их имена.
//	ОбходРезультата - ОбходРезультатаЗапроса - вариант обхода результата запроса.
//
// Возвращаемое значение:
//   Структура   - структура в которую помещены полученные таблицы
//
Функция ВыгрузитьРезультатыЗапроса(Запрос, ТекстыЗапроса, ОбходРезультата = Неопределено, ДобавитьРазделитель = Ложь) Экспорт

	Таблицы = Новый Структура;
	
	// Инициализация варианта обхода результата запроса.
	Если ОбходРезультата = Неопределено Тогда
		ОбходРезультата = ОбходРезультатаЗапроса.Прямой;
	КонецЕсли;
	
	// Формирование текст запроса.
	Запрос.Текст = "";
	Для Каждого ТекстЗапроса из ТекстыЗапроса Цикл
		Если ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
			Запрос.Текст = Запрос.Текст 
							+ ?(Запрос.Текст <> "", Символы.ПС, "")
							+ "// " + ТекстЗапроса.Представление + Символы.ПС;	
		КонецЕсли; 
		Запрос.Текст = Запрос.Текст + ТекстЗапроса.Значение;
		Если ДобавитьРазделитель Тогда
			Запрос.Текст = Запрос.Текст + "
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|"
		КонецЕсли; 
	КонецЦикла;

	// Выполнение запроса.
	Результат = Запрос.ВыполнитьПакет();

	// Помещение результатов запроса в таблицы
	Для Каждого ТекстЗапроса из ТекстыЗапроса Цикл

		ИмяТаблицы = ТекстЗапроса.Представление;

		Если Не ПустаяСтрока(ИмяТаблицы) Тогда

			Индекс = ТекстыЗапроса.Индекс(ТекстЗапроса);
			Таблицы.Вставить(ИмяТаблицы, Результат[Индекс].Выгрузить(ОбходРезультата));

		КонецЕсли;

	КонецЦикла;

	Возврат Таблицы;
	
КонецФункции

// Возвращает метаданные объекта по полному имени объекта метаданных
//
// Параметры:
//  ПолноеИмя - Строка - полный путь к объекту метаданных
//              например "РегистрыНакопления.ТоварыНаСкладах.Измерения.Номенклатура"
//
// Возвращаемое значение:
//  ОбъектМетаданных,КоллекцияОбъектовМетаданных
Функция МетаданныеПоИмени(МетаданныеСтрокой) Экспорт
	
	Возврат СвойствоМетаданных(Метаданные, СтрРазделить(МетаданныеСтрокой, "."));
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииУстановкиСтатусовДляМассиваДокументов

// Устанавливает статус для списка документов
//
// Параметры:
// 		МассивДокументов - Массив - Массив документов
// 		ДополнительныеПараметры - Структура - Структура дополнительных параметров
//
// Возвращаемое значение:
// 		Число - Количество документов у которых был изменен статус
//
// ВАЖНО. При использования процедуры для каждого типа документа из массива должны быть объявлены функции:
// В модуле менеджера документа:
// 		Функция СформироватьЗапросПроверкиПриСменеСтатуса(МассивДокументов, НовыйСтатус, ДополнительныеПараметры) Экспорт
// 		Функция ПроверкаПередСменойСтатуса(ВыборкаПроверки, НовыйСтатус, ДополнительныеПараметры) Экспорт
// В модуле объекта документа:
// 		Функция УстановитьСтатус(НовыйСтатус, ДополнительныеПараметры) Экспорт
//
Функция РассчитатьСтатусыДокументовАвтоматически(Знач МассивДокументов, Знач ДополнительныеПараметры=Неопределено) Экспорт
	
	Перем РезультатыПроверки;
	
	// Получение шаблонов сообщений стандартных ошибок
	ШаблонОшибкиСтатусСовпадает   = НСтр("ru='Документу %Документ% уже присвоен статус ""%Статус%""';uk='Документом %Документ% вже присвоєно статус ""%Статус%""'");
	ШаблонОшибкиНеПроведен        = НСтр("ru='Документ %Документ% не проведен. Невозможно изменить статус';uk='Документ %Документ% не проведений. Неможливо змінити статус'");
	ШаблонОшибкиПомеченНаУдаление = НСтр("ru='Документ %Документ% помечен на удаление. Невозможно изменить статус';uk='Документ %Документ% позначений на вилучення. Неможливо змінити статус'");
	ШаблонОшибкиЗаблокировать     = НСтр("ru='Не удалось заблокировать %Документ%. %ОписаниеОшибки%';uk='Не вдалося заблокувати %Документ%. %ОписаниеОшибки%'");
	ШаблонОшибкиЗаписать          = НСтр("ru='Не удалось записать %Документ%. %ОписаниеОшибки%';uk='Не вдалося записати %Документ%. %ОписаниеОшибки%'");
	
	// Получение соответствие типов документов из массива документов разных типов
	СоответствиеТипов = РазложитьМассивСсылокПоТипам(МассивДокументов);
	
	КоличествоОбработанных = 0;
	Для Каждого СоставДокументов Из СоответствиеТипов Цикл
		
		// Получение менеджера документов данного типа
		МенеджерДокументов = Документы[Метаданные.НайтиПоТипу(СоставДокументов.Ключ).Имя];
		
		// Получение массива ссылок документов данного типа
		МассивСсылок = СоставДокументов.Значение;
		
		// Формирование запроса
		Запрос = МенеджерДокументов.СформироватьЗапросПроверкиПриАвтоматическомРасчетеСтатуса(МассивСсылок, ДополнительныеПараметры);
		Результат = Запрос.Выполнить();
		Если Результат.Пустой() Тогда
			Возврат 0;
		КонецЕсли;
		
		// Цикл обхода выборки
		Выборка = Результат.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			// Универсальные проверки
			Если Выборка.ПометкаУдаления Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СтрЗаменить(ШаблонОшибкиПомеченНаУдаление, "%Документ%", Выборка.Представление), Выборка.Ссылка);
				Продолжить;
			КонецЕсли;

			Если Не Выборка.Проведен Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СтрЗаменить(ШаблонОшибкиНеПроведен, "%Документ%", Выборка.Представление), Выборка.Ссылка);
				Продолжить;
			КонецЕсли;
			
			// Захват объекта для редактирования
			Попытка
				ЗаблокироватьДанныеДляРедактирования(Выборка.Ссылка);
			Исключение
				ТекстОшибки = СтрЗаменить(ШаблонОшибкиЗаблокировать, "%Документ%", Выборка.Представление);
				ТекстОшибки = СтрЗаменить(ТекстОшибки, "%ОписаниеОшибки%", КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, Выборка.Ссылка);
				Продолжить;
			КонецПопытки;
			
			// Получение объекта документа
			Объект = Выборка.Ссылка.ПолучитьОбъект();
			
			// Авторасчет статуса
			
			Если НЕ МенеджерДокументов.РассчитатьСтатусДокументаСервер(Объект, КоличествоОбработанных) Тогда
				Продолжить;
			КонецЕсли; 
			
			// Запись документа
			Попытка
				Объект.Записать(?(Выборка.ЗаписьПроведением, РежимЗаписиДокумента.Проведение, РежимЗаписиДокумента.Запись));
			Исключение
				ТекстОшибки = СтрЗаменить(ШаблонОшибкиЗаписать, "%Документ%", Выборка.Представление);
				ТекстОшибки = СтрЗаменить(ТекстОшибки, "%ОписаниеОшибки%", КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки, Выборка.Ссылка);
			КонецПопытки
			
		КонецЦикла; // выборки документов данного типа
		
	КонецЦикла; // обхода соответствия типов
	
	Возврат КоличествоОбработанных;
	
КонецФункции

#КонецОбласти

#Область НастройкиФорм

Процедура НастроитьФормуПоПараметрам(Форма, ПараметрыНастройки) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	НастройкиФорм.Ссылка
	|ИЗ
	|	Справочник.ПараметрыКонтекстныхФункциональныхОпций КАК НастройкиФорм
	|ГДЕ
	|	ИСТИНА";
	
	Для каждого ПараметрНастройки Из ПараметрыНастройки Цикл
	
		ТекстЗапроса = ТекстЗапроса + " 
		|	И НастройкиФорм." + ПараметрНастройки.Ключ + " = &" + ПараметрНастройки.Ключ;
		Запрос.УстановитьПараметр(ПараметрНастройки.Ключ, ПараметрНастройки.Значение);
	
	КонецЦикла;
	
	Запрос.Текст = ТекстЗапроса;
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		
		Настройка = Выборка.Ссылка;
		
	Иначе
		
		СправочникОбъект = Справочники.ПараметрыКонтекстныхФункциональныхОпций.СоздатьЭлемент();
		
		ЗаполнитьЗначенияСвойств(СправочникОбъект, ПараметрыНастройки);
		
		СправочникОбъект.Записать();
		
		Настройка = СправочникОбъект.Ссылка;
		
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	
	Форма.УстановитьПараметрыФункциональныхОпцийФормы(Новый Структура("НастройкаФормы", Настройка));
	
КонецПроцедуры

Процедура ИнициализироватьРеквизитыФормыДляПолнотекстовогоПоиска(Форма, ИмяФОИспользованияППД) Экспорт
	
	Форма.ИнформационнаяБазаФайловая      = ОбщегоНазначения.ИнформационнаяБазаФайловая();
	Форма.ИспользоватьПолнотекстовыйПоиск = ОбщегоНазначенияУТВызовСервера.ИспользуетсяПолнотекстовыйПоиск(ИмяФОИспользованияППД);
	
	Если Форма.ИспользоватьПолнотекстовыйПоиск Тогда
			
		Форма.ИндексПолнотекстовогоПоискаАктуален = ПолнотекстовыйПоискСервер.ИндексПоискаАктуален();
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ПересчитатьТаблицуТоваровВВалютуРегл(МенеджерВременныхТаблиц) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	*
	|ИЗ
	|	ТаблицаТоваровПредварительная
	|
	|ИТОГИ
	|	СУММА(ТаблицаТоваровПредварительная.СуммаБезНДС),
	|	СУММА(ТаблицаТоваровПредварительная.СуммаНДС),
	|	МАКСИМУМ(ТаблицаТоваровПредварительная.Валюта),
	|	МАКСИМУМ(ТаблицаТоваровПредварительная.Дата)
	|ПО
	|	ТаблицаТоваровПредварительная.Ссылка
	|";
	РезультатЗапроса = Запрос.Выполнить();
	
	ПересчитанныеСуммыДокументов = Новый ТаблицаЗначений;
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		ПересчитанныеСуммыДокументов.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
	КонецЦикла;
	
	ВалютаРегл = Константы.ВалютаРегламентированногоУчета.Получить();
	КэшКурсовВалют = РаботаСКурсамиВалютУТ.ИнициализироватьКэшКурсовВалют();
	
	ВыборкаПоДокументу = РезультатЗапроса.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаПоДокументу.Следующий() Цикл
		
		КурсВалютыДокумента = РаботаСКурсамиВалютУТ.ПолучитьКурсВалютыИзКэша(ВыборкаПоДокументу.Валюта, ВыборкаПоДокументу.Дата, КэшКурсовВалют);
		КурсВалютыРегл      = РаботаСКурсамиВалютУТ.ПолучитьКурсВалютыИзКэша(ВалютаРегл, ВыборкаПоДокументу.Дата, КэшКурсовВалют);
		
		СуммаДокумента     = ВыборкаПоДокументу.СуммаБезНДС + ВыборкаПоДокументу.СуммаНДС;
		СуммаДокументаРегл = СуммаДокумента * КурсВалютыДокумента / КурсВалютыРегл;
		
		УчтеноБазыРаспределения = 0;
		УжеРаспределено = 0;
		
		Выборка = ВыборкаПоДокументу.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			СуммаСНДС = Выборка.СуммаБезНДС + Выборка.СуммаНДС;
			
			СуммаСНДСРегл = ?(СуммаДокумента <> 0, Окр(СуммаДокументаРегл * (УчтеноБазыРаспределения + СуммаСНДС) / СуммаДокумента, 2) - УжеРаспределено, 0);
			
			УчтеноБазыРаспределения = УчтеноБазыРаспределения + СуммаСНДС;
			УжеРаспределено         = УжеРаспределено + СуммаСНДСРегл;
			
			НоваяЗапись = ПересчитанныеСуммыДокументов.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяЗапись, Выборка, , "СуммаНДС, СуммаБезНДС");
			
			ТекПроцентНДС = ЦенообразованиеКлиентСервер.ПолучитьСтавкуНДСЧислом(Выборка.СтавкаНДС);
			
			НоваяЗапись.СуммаНДС    = ЦенообразованиеКлиентСервер.РассчитатьСуммуНДС(СуммаСНДСРегл, ТекПроцентНДС);
			НоваяЗапись.СуммаБезНДС = СуммаСНДСРегл - НоваяЗапись.СуммаНДС;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Запрос.Текст = "
	|УНИЧТОЖИТЬ ТаблицаТоваровПредварительная;
	|ВЫБРАТЬ";
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		Запрос.Текст = Запрос.Текст + "
		|Таблица." + Колонка.Имя + ",";
	КонецЦикла;
	Запрос.Текст = Лев(Запрос.Текст, СтрДлина(Запрос.Текст)-1);
	Запрос.Текст = Запрос.Текст + "
	|ПОМЕСТИТЬ ТаблицаТоваровПредварительная
	|ИЗ &Таблица КАК Таблица";
	Запрос.УстановитьПараметр("Таблица", ПересчитанныеСуммыДокументов);
	Запрос.Выполнить();
	
КонецПроцедуры

//Удаляет повторяющиеся элементы массива
//
Функция УдалитьПовторяющиесяЭлементыМассива(Массив, НеИспользоватьНеопределено = Ложь) Экспорт
	
	ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки(); 
	ОписаниеТиповДокументы    = Документы.ТипВсеСсылки(); 
	ОписаниеТиповПВХ          = ПланыВидовХарактеристик.ТипВсеСсылки(); 
	ОписаниеТиповПланыСчетов  = ПланыСчетов.ТипВсеСсылки(); 
	ОписаниеТиповПланыРасчета = ПланыВидовРасчета.ТипВсеСсылки(); 
	
	Если ТипЗнч(Массив) = Тип("Массив") Тогда 
		
		УжеВМассиве 		   = Новый Соответствие; 
		БылоНеопределено 	   = Ложь;
		КолвоЭлементовВМассиве = Массив.Количество(); 
		
		Для ОбратныйИндекс = 1 По КолвоЭлементовВМассиве Цикл 
			
			ЭлементМассива = Массив[КолвоЭлементовВМассиве - ОбратныйИндекс]; 
			ТипЭлемента    = ТипЗнч(ЭлементМассива); 
			
			Если ЭлементМассива = Неопределено Тогда
				
				Если БылоНеопределено ИЛИ НеИспользоватьНеопределено Тогда
					Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
				Иначе
					БылоНеопределено = Истина;
				КонецЕсли;
				
				Продолжить;
				
			ИначеЕсли ОписаниеТиповСправочники.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповДокументы.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповПВХ.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповПланыСчетов.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповПланыРасчета.СодержитТип(ТипЭлемента) Тогда 
				
				ИДЭлемента = Строка(ЭлементМассива.УникальныйИдентификатор()); 
				
			Иначе 
				
				ИДЭлемента = ЭлементМассива; 
				
			КонецЕсли; 
			
			Если УжеВМассиве[ИДЭлемента] = Истина Тогда 
				Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
			Иначе 
				УжеВМассиве[ИДЭлемента] = Истина; 
			КонецЕсли; 
			
		КонецЦикла;      
		
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции

// Функция возвращает представление клавиши
// Параметры:
//	ЗначениеКлавиша						- Клавиша
//
// Возвращаемое значение
//	Строка - Представление клавиши
//
Функция ПредставлениеКлавиши(ЗначениеКлавиша) Экспорт
	
	Если Строка(Клавиша._1) = Строка(ЗначениеКлавиша) Тогда
		Возврат "1";
	ИначеЕсли Строка(Клавиша._2) = Строка(ЗначениеКлавиша) Тогда
		Возврат "2";
	ИначеЕсли Строка(Клавиша._3) = Строка(ЗначениеКлавиша) Тогда
		Возврат "3";
	ИначеЕсли Строка(Клавиша._4) = Строка(ЗначениеКлавиша) Тогда
		Возврат "4";
	ИначеЕсли Строка(Клавиша._5) = Строка(ЗначениеКлавиша) Тогда
		Возврат "5";
	ИначеЕсли Строка(Клавиша._6) = Строка(ЗначениеКлавиша) Тогда
		Возврат "6";
	ИначеЕсли Строка(Клавиша._7) = Строка(ЗначениеКлавиша) Тогда
		Возврат "7";
	ИначеЕсли Строка(Клавиша._8) = Строка(ЗначениеКлавиша) Тогда
		Возврат "8";
	ИначеЕсли Строка(Клавиша._9) = Строка(ЗначениеКлавиша) Тогда
		Возврат "9";
	ИначеЕсли Строка(Клавиша.Num0) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 0";
	ИначеЕсли Строка(Клавиша.Num1) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 1";
	ИначеЕсли Строка(Клавиша.Num2) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 2";
	ИначеЕсли Строка(Клавиша.Num3) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 3";
	ИначеЕсли Строка(Клавиша.Num4) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 4";
	ИначеЕсли Строка(Клавиша.Num5) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 5";
	ИначеЕсли Строка(Клавиша.Num6) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 6";
	ИначеЕсли Строка(Клавиша.Num7) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 7";
	ИначеЕсли Строка(Клавиша.Num8) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 8";
	ИначеЕсли Строка(Клавиша.Num9) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 9";
	ИначеЕсли Строка(Клавиша.NumAdd) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num +";
	ИначеЕсли Строка(Клавиша.NumDecimal) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num .";
	ИначеЕсли Строка(Клавиша.NumDivide) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num /";
	ИначеЕсли Строка(Клавиша.NumMultiply) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num *";
	ИначеЕсли Строка(Клавиша.NumSubtract) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num -";
	Иначе
		Возврат Строка(ЗначениеКлавиша);
	КонецЕсли;
	
КонецФункции

// Функция возвращает представление клавиши
// Параметры:
//	СочетаниеКлавиш						- Сочетание клавиш для которого нужно сформировать представление
//	БезСкобок							- Флаг, указывающий, что представление должно быть сформировано без скобок
//
// Возвращаемое значение
//	Строка - Представление сочетания клавиш
//
Функция ПредставлениеСочетанияКлавиш(СочетаниеКлавиш, БезСкобок = Ложь) Экспорт
	
	Если СочетаниеКлавиш.Клавиша = Клавиша.Нет Тогда
		Возврат "";
	КонецЕсли;
	
	Наименование = ?(БезСкобок, "", "(");
	Если СочетаниеКлавиш.Ctrl Тогда
		Наименование = Наименование + "Ctrl+"
	КонецЕсли;
	Если СочетаниеКлавиш.Alt Тогда
		Наименование = Наименование + "Alt+"
	КонецЕсли;
	Если СочетаниеКлавиш.Shift Тогда
		Наименование = Наименование + "Shift+"
	КонецЕсли;
	Наименование = Наименование + ПредставлениеКлавиши(СочетаниеКлавиш.Клавиша) + ?(БезСкобок, "", ")");
	
	Возврат Наименование;
	
КонецФункции

// Устанавливае свойство ОтображениеСтраницФормы в Нет, если фактически отображается только одна закладка
// Параметры:
//  ЭлементСтраница  - ГруппаФормы - страница, для которой определяется необходимость отображения закладок.
//
Процедура УдалитьЗакладкиЕслиСтраницаОдна(ЭлементСтраница) Экспорт
	
	Если ЭлементСтраница.ПодчиненныеЭлементы.Количество() = 1 Тогда
		ЭлементСтраница.ОтображениеСтраниц = ОтображениеСтраницФормы.Нет;
	Иначе
		КоличествоВидимыхСтраниц = 0;
		Для Каждого ПодчиненнаяСтраница Из ЭлементСтраница.ПодчиненныеЭлементы Цикл
			
			Если КоличествоВидимыхСтраниц > 1 Тогда
				Прервать;
			КонецЕсли;
			
			Для Каждого ЭлементСтраницы Из ПодчиненнаяСтраница.ПодчиненныеЭлементы Цикл
				
				Если ЭлементСтраницы.Видимость Тогда
					КоличествоВидимыхСтраниц = КоличествоВидимыхСтраниц + 1;
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
		Если КоличествоВидимыхСтраниц = 1 Тогда
			ЭлементСтраница.ОтображениеСтраниц = ОтображениеСтраницФормы.Нет;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ЗакрытиеМесяца

// Метод регламентного задания "ЗакрытиеМесяца".
//
Процедура ВыполнитьЗакрытиеМесяца(Организация = Неопределено) Экспорт

	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания();
	
	Если Организация = Неопределено Тогда
		Организация = Справочники.Организации.ПустаяСсылка();
	КонецЕсли;
	
	Запрос = Новый Запрос("
	|ВЫБРАТЬ
	|	ПараметрыЗакрытия.ЗакрываемыйПериод
	|ИЗ
	|	РегистрСведений.РегламентныеЗаданияЗакрытияМесяца КАК ПараметрыЗакрытия
	|ГДЕ
	|	ПараметрыЗакрытия.Организация = &Организация
	|");
	Запрос.УстановитьПараметр("Организация", Организация);
	Результат = Запрос.Выполнить();
	
	ЗакрываемыйПериод = Дата("00010101000000");
	ВыборкаДетальныеЗаписи = Результат.Выбрать();
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		ЗакрываемыйПериод = ВыборкаДетальныеЗаписи.ЗакрываемыйПериод;
	КонецЦикла;
	
	СписокОрганизаций = Новый Массив();
	Если ЗначениеЗаполнено(Организация) Тогда
		СписокОрганизаций.Добавить(Организация);
	КонецЕсли;
	
	МассивОпераций = Новый Массив();
	
	ПараметрыРасчета = Новый Структура("СписокОрганизаций, Организация, ПериодРегистрации, Период, МассивОпераций, АдресХранилища");
	ПараметрыРасчета.СписокОрганизаций = СписокОрганизаций;
	ПараметрыРасчета.Организация = Организация;
	ПараметрыРасчета.ПериодРегистрации = ЗакрываемыйПериод;
	ПараметрыРасчета.Период = ЗакрываемыйПериод;
	ПараметрыРасчета.МассивОпераций = МассивОпераций;
	ПараметрыРасчета.АдресХранилища = Неопределено;
	
	ЗакрытиеМесяцаУТВызовСервера.РассчитатьВФоновомЗадании(ПараметрыРасчета);
	
КонецПроцедуры

// Метод регламентного задания "ПереоценкаВалютныхСредств"
Процедура ВыполнитьПереоценку() Экспорт
	
	ОбщегоНазначения.ПриНачалеВыполненияРегламентногоЗадания();
	Если НЕ ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоВалют") Тогда
		Возврат;
	КонецЕсли;
	
	Документы.ПереоценкаВалютныхСредств.ВыполнитьПереоценку(ТекущаяДатаСеанса());
	
КонецПроцедуры

#КонецОбласти

#Область ЗаполненияТабличныхЧастейДокумента

// Функция возвращает параметры проверки заполнения количества
//
//	Возвращаемое значение:
//		Структура:
//			*ИмяТЧ - Строка - значение по умолчанию "Товары"
//			*СуффиксДопРеквизита - Строка - значение по умолчанию "" - если в ТЧ два реквизита "Количество", то второй назван с суффиксом. 
//											если суффикс передан, то проверяются оба реквизита
//			*ПроверитьВозможностьОкругления - Булево - Истина если нужно проверить возможность округления
//			*УсловиеОтбораСтрокДляОкругления - Строка - Условие выбора строк для проверки округления.
//											в качестве имени таблицы нужно использовать имя переданное в ИмяТЧ
//
Функция ПараметрыПроверкиЗаполненияКоличества() Экспорт
	
	ПараметрыПроверки = Новый Структура;
	ПараметрыПроверки.Вставить("ИмяТЧ",                           "Товары");	
	ПараметрыПроверки.Вставить("СуффиксДопРеквизита",             "");
	ПараметрыПроверки.Вставить("ПроверитьВозможностьОкругления",  Истина);
	ПараметрыПроверки.Вставить("УсловиеОтбораСтрокДляОкругления", "");
	
	Возврат ПараметрыПроверки;
	
КонецФункции

// Процедуры проверки заполнения реквизита Количество и КоличествоУпаковок в документах.
// Параметры:
//	Объект - проверяемый ДокументОбъект
//	ПроверяемыеРеквизиты - массив проверяемых реквизитов
//	Отказ - отказ продолжения операции
Процедура ПроверитьЗаполнениеКоличества(Объект, ПроверяемыеРеквизиты, Отказ, ПараметрыПроверки = Неопределено) Экспорт
	
	Перем ЗаполнятьРеквизитОбязательно;
	Перем ЗаполнятьДопРеквизитОбязательно;
	
	Если ПараметрыПроверки = Неопределено Тогда
		ПараметрыПроверки = ПараметрыПроверкиЗаполненияКоличества();
	КонецЕсли;
	
	ИмяТЧ               = ПараметрыПроверки.ИмяТЧ;
	СуффиксДопРеквизита = ПараметрыПроверки.СуффиксДопРеквизита;
	
	КлючДанных = КлючДанныхДляСообщенияПользователю(Объект);
	
	Если ИмяТЧ = "Объект" Тогда
		
		ПроверяемыеРеквизиты.Удалить(ПроверяемыеРеквизиты.Найти("Количество"));
		ПроверяемыеРеквизиты.Удалить(ПроверяемыеРеквизиты.Найти("КоличествоУпаковок"));

		Если Объект.Количество = 0 И Объект.КоличествоУпаковок <> 0 Тогда

			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(НСтр("ru='Обнаружено нулевое количество при пересчете в единицу хранения';uk='Виявлена нульова кількість при перерахунку на одиницю зберігання'"),
					КлючДанных,
					"КоличествоУпаковок",
					,
					Отказ);

		ИначеЕсли Объект.Количество = 0 Или Объект.КоличествоУпаковок = 0 Тогда

			ТекстСообщения = НСтр("ru='Не заполнено поле ""%ПредставлениеПоляКоличество%""';uk='Не заповнено поле ""%ПредставлениеПоляКоличество%""'");
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПредставлениеПоляКоличество%", Объект.Метаданные().Реквизиты.Количество.Синоним);
			
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,
					КлючДанных,
					"КоличествоУпаковок",
					,
					Отказ);
				
		КонецЕсли;
	Иначе
		МетаданныеОбъекта = Объект.Метаданные();
		                                 
		РеквизитПроверки =  ПроверяемыеРеквизиты.Найти(ИмяТЧ + ".КоличествоУпаковок");
		ЗаполнятьРеквизитОбязательно = РеквизитПроверки <> Неопределено;
		Если РеквизитПроверки <> Неопределено Тогда
			ПроверяемыеРеквизиты.Удалить(РеквизитПроверки);
			ПроверяемыеРеквизиты.Удалить(ПроверяемыеРеквизиты.Найти(ИмяТЧ + ".Количество"));
		КонецЕсли;
		
		ПредставлениеТЧ                          = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Синоним;
		ПредставлениеРеквизитаКоличествоУпаковок = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Реквизиты.КоличествоУпаковок.Синоним;
		Если ЗначениеЗаполнено(СуффиксДопРеквизита) Тогда
			РеквизитПроверки =  ПроверяемыеРеквизиты.Найти(ИмяТЧ + ".КоличествоУпаковок"+СуффиксДопРеквизита);
			ЗаполнятьДопРеквизитОбязательно = РеквизитПроверки <> Неопределено;
			Если РеквизитПроверки <> Неопределено Тогда
				ПроверяемыеРеквизиты.Удалить(РеквизитПроверки);
				ПроверяемыеРеквизиты.Удалить(ПроверяемыеРеквизиты.Найти(ИмяТЧ + ".Количество"+СуффиксДопРеквизита));
			КонецЕсли;
			ПредставлениеРеквизитаКоличествоУпаковокДоп  = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Реквизиты["КоличествоУпаковок"+СуффиксДопРеквизита].Синоним;
		Иначе
			ЗаполнятьДопРеквизитОбязательно = Ложь;
			ПредставлениеРеквизитаКоличествоУпаковокДоп = "";
		КонецЕсли;
		
		ШаблонОшибкаКоличества = НСтр("ru='Не заполнена колонка ""%ПредставлениеКолонки%"" в строке %НомерСтроки% списка ""%ПредставлениеТЧ%""';uk='Не заповнена колонка ""%ПредставлениеКолонки%"" в рядку %НомерСтроки% списку ""%ПредставлениеТЧ%""'");
		ШаблонОшибкаКоличества = СтрЗаменить(ШаблонОшибкаКоличества, "%ПредставлениеТЧ%", ПредставлениеТЧ);
		ШаблонОшибкаПересчета = НСтр("ru='Обнаружено нулевое количество при пересчете в единицу хранения в строке %НомерСтроки% списка ""%ПредставлениеТЧ%""';uk='Виявлена нульова кількість при перерахунку на одиницю зберігання в рядку %НомерСтроки% списку ""%ПредставлениеТЧ%""'");
		ШаблонОшибкаПересчета = СтрЗаменить(ШаблонОшибкаПересчета, "%ПредставлениеТЧ%", ПредставлениеТЧ);
		
		Для Каждого СтрокаТаб Из Объект[ИмяТЧ] Цикл
			
			Если СтрокаТаб.Количество = 0 
				И СтрокаТаб.КоличествоУпаковок <> 0 Тогда
				
				ТекстСообщения = СтрЗаменить(ШаблонОшибкаПересчета, "%НомерСтроки%", Строка(СтрокаТаб.НомерСтроки));
				Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, СтрокаТаб.НомерСтроки, "КоличествоУпаковок");
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,"Объект",Отказ);
				
			ИначеЕсли ЗаполнятьРеквизитОбязательно
				И (СтрокаТаб.Количество = 0
				Или СтрокаТаб.КоличествоУпаковок = 0) Тогда
				
				ТекстСообщения = СтрЗаменить(ШаблонОшибкаКоличества, "%НомерСтроки%", Строка(СтрокаТаб.НомерСтроки));
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПредставлениеКолонки%", ПредставлениеРеквизитаКоличествоУпаковок);
				
				Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, СтрокаТаб.НомерСтроки, "КоличествоУпаковок");
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,"Объект",Отказ);
						
			КонецЕсли;
			
			
			Если Не ЗначениеЗаполнено(СуффиксДопРеквизита) Тогда
				Продолжить;
			КонецЕсли;
			
			Если СтрокаТаб["Количество"+СуффиксДопРеквизита] = 0 
				И СтрокаТаб["КоличествоУпаковок"+СуффиксДопРеквизита] <> 0 Тогда
				
				ТекстСообщения = СтрЗаменить(ШаблонОшибкаПересчета, "%НомерСтроки%", Строка(СтрокаТаб.НомерСтроки));
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПредставлениеТЧ%", ПредставлениеТЧ);
				
				Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, СтрокаТаб.НомерСтроки, "КоличествоУпаковок"+СуффиксДопРеквизита);
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,"Объект",Отказ);
				
			ИначеЕсли ЗаполнятьДопРеквизитОбязательно
				И (СтрокаТаб["Количество"+СуффиксДопРеквизита] = 0
				Или СтрокаТаб["КоличествоУпаковок"+СуффиксДопРеквизита]  = 0) Тогда
				
				ТекстСообщения = СтрЗаменить(ШаблонОшибкаКоличества, "%НомерСтроки%", Строка(СтрокаТаб.НомерСтроки));
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПредставлениеТЧ%", ПредставлениеТЧ);
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%ПредставлениеКолонки%", ПредставлениеРеквизитаКоличествоУпаковокДоп);
				
				Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, СтрокаТаб.НомерСтроки,"КоличествоУпаковок"+СуффиксДопРеквизита);
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,"Объект",Отказ);
						
			КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ТЧ.НомерСтроки КАК НомерСтроки,
	|	ТЧ.Номенклатура КАК Номенклатура,
	|	ТЧ.КоличествоУпаковок КАК КоличествоУпаковок,
	|	ТЧ.Количество КАК КоличествоВДокументе,
	|	ТЧ.Упаковка КАК Упаковка,
	|	&ИмяПоляКоличествоУпаковокСуффикс КАК КоличествоУпаковокСуффикс,
	|	&ИмяПоляКоличествоСуффикс КАК КоличествоВДокументеСуффикс
	|ПОМЕСТИТЬ ВТДляЗапроса
	|ИЗ
	|	&ТЧ КАК ТЧ
	|ГДЕ
	|	ТЧ.Упаковка <> ЗНАЧЕНИЕ(Справочник.УпаковкиЕдиницыИзмерения.ПустаяСсылка)
	|	И (&УсловиеОтбораСтрокДляОкругления)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ВТДляЗапроса.НомерСтроки,
	|	ВЫРАЗИТЬ(ВТДляЗапроса.Номенклатура КАК Справочник.Номенклатура).ЕдиницаИзмерения.ТипИзмеряемойВеличины = &ШтучныйТип
	|		И ВЫРАЗИТЬ(ВТДляЗапроса.Упаковка КАК Справочник.УпаковкиЕдиницыИзмерения).ТипИзмеряемойВеличины В (&МерныеТипы) КАК МожноОкруглять,
	|	ВЫРАЗИТЬ(ВТДляЗапроса.Номенклатура КАК Справочник.Номенклатура).ЕдиницаИзмерения КАК БазоваяЕдиницаИзмерения,
	|	ВТДляЗапроса.Номенклатура,
	|	ВТДляЗапроса.Упаковка,
	|	&ТекстЗапросаКоэффициентУпаковки КАК КоэффициентУпаковки,
	|	ВЫРАЗИТЬ(ВТДляЗапроса.КоличествоУпаковок * &ТекстЗапросаКоэффициентУпаковки КАК ЧИСЛО(15, 3)) КАК Количество,
	|	ВЫРАЗИТЬ(ВТДляЗапроса.КоличествоУпаковок * &ТекстЗапросаКоэффициентУпаковки КАК ЧИСЛО(15, 0)) КАК КоличествоОкругленное,
	|	ВТДляЗапроса.КоличествоВДокументе КАК КоличествоВДокументе,
	|	ВЫРАЗИТЬ(ВТДляЗапроса.КоличествоУпаковокСуффикс * &ТекстЗапросаКоэффициентУпаковки КАК ЧИСЛО(15, 3)) КАК КоличествоСуффикс,
	|	ВЫРАЗИТЬ(ВТДляЗапроса.КоличествоУпаковокСуффикс * &ТекстЗапросаКоэффициентУпаковки КАК ЧИСЛО(15, 0)) КАК КоличествоСуффиксОкругленное,
	|	ВТДляЗапроса.КоличествоВДокументеСуффикс КАК КоличествоВДокументеСуффикс
	|ПОМЕСТИТЬ ВТ
	|ИЗ
	|	ВТДляЗапроса КАК ВТДляЗапроса
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТЧ.НомерСтроки КАК НомерСтроки,
	|	ПРЕДСТАВЛЕНИЕ(ТЧ.БазоваяЕдиницаИзмерения) КАК БазоваяЕдиницаИзмерения,
	|	ПРЕДСТАВЛЕНИЕ(ТЧ.Упаковка) КАК Упаковка,
	|	ТЧ.КоличествоОкругленное КАК КоличествоОкругленное,
	|	ТЧ.КоличествоСуффиксОкругленное КАК КоличествоСуффиксОкругленное,
	|	ВЫРАЗИТЬ(ВЫБОР
	|			КОГДА &ПроверитьВозможностьОкругления
	|					И ТЧ.МожноОкруглять
	|				ТОГДА ВЫБОР
	|						КОГДА ТЧ.Количество - ТЧ.КоличествоОкругленное > 0
	|							ТОГДА ТЧ.Количество - ТЧ.КоличествоОкругленное
	|						ИНАЧЕ ТЧ.КоличествоОкругленное - ТЧ.Количество
	|					КОНЕЦ
	|			ИНАЧЕ ВЫБОР
	|					КОГДА ТЧ.КоличествоВДокументе - ТЧ.Количество > 0
	|						ТОГДА ТЧ.КоличествоВДокументе - ТЧ.Количество
	|					ИНАЧЕ ТЧ.Количество - ТЧ.КоличествоВДокументе
	|				КОНЕЦ
	|		КОНЕЦ / ТЧ.КоэффициентУпаковки КАК ЧИСЛО(15, 3)) КАК КоличествоОтклонение,
	|	ВЫРАЗИТЬ(ВЫБОР
	|			КОГДА &ПроверитьВозможностьОкругления
	|					И ТЧ.МожноОкруглять
	|				ТОГДА &ДопустимыйПроцентОтклонения * ТЧ.КоличествоОкругленное / ТЧ.КоэффициентУпаковки / 100
	|			ИНАЧЕ 0
	|		КОНЕЦ КАК ЧИСЛО(15, 3)) КАК КоличествоМаксимальнаяПогрешность,
	|	ВЫРАЗИТЬ(ВЫБОР
	|			КОГДА &ПроверитьВозможностьОкругления
	|				ТОГДА ВЫБОР
	|						КОГДА ТЧ.КоличествоСуффикс - ТЧ.КоличествоСуффиксОкругленное > 0
	|							ТОГДА ТЧ.КоличествоСуффикс - ТЧ.КоличествоСуффиксОкругленное
	|						ИНАЧЕ ТЧ.КоличествоСуффиксОкругленное - ТЧ.КоличествоСуффикс
	|					КОНЕЦ
	|			ИНАЧЕ ВЫБОР
	|					КОГДА ТЧ.КоличествоВДокументеСуффикс - ТЧ.КоличествоСуффикс > 0
	|						ТОГДА ТЧ.КоличествоВДокументеСуффикс - ТЧ.КоличествоСуффикс
	|					ИНАЧЕ ТЧ.КоличествоСуффикс - ТЧ.КоличествоВДокументеСуффикс
	|				КОНЕЦ
	|		КОНЕЦ / ТЧ.КоэффициентУпаковки КАК ЧИСЛО(15, 3)) КАК КоличествоСуффиксОтклонение,
	|	ВЫРАЗИТЬ(ВЫБОР
	|			КОГДА &ПроверитьВозможностьОкругления
	|					И ТЧ.МожноОкруглять
	|				ТОГДА &ДопустимыйПроцентОтклонения * ТЧ.КоличествоСуффиксОкругленное / ТЧ.КоэффициентУпаковки / 100
	|			ИНАЧЕ 0
	|		КОНЕЦ КАК ЧИСЛО(15, 3)) КАК КоличествоСуффиксМаксимальнаяПогрешность
	|ИЗ
	|	ВТ КАК ТЧ
	|ГДЕ
	|	((ВЫРАЗИТЬ(ВЫБОР
	|					КОГДА &ПроверитьВозможностьОкругления
	|							И ТЧ.МожноОкруглять
	|						ТОГДА ВЫБОР
	|								КОГДА ТЧ.Количество - ТЧ.КоличествоОкругленное > 0
	|									ТОГДА ТЧ.Количество - ТЧ.КоличествоОкругленное
	|								ИНАЧЕ ТЧ.КоличествоОкругленное - ТЧ.Количество
	|							КОНЕЦ
	|					ИНАЧЕ ВЫБОР
	|							КОГДА ТЧ.КоличествоВДокументе - ТЧ.Количество > 0
	|								ТОГДА ТЧ.КоличествоВДокументе - ТЧ.Количество
	|							ИНАЧЕ ТЧ.Количество - ТЧ.КоличествоВДокументе
	|						КОНЕЦ
	|				КОНЕЦ / ТЧ.КоэффициентУпаковки КАК ЧИСЛО(15, 3))) > (ВЫРАЗИТЬ(ВЫБОР
	|					КОГДА &ПроверитьВозможностьОкругления
	|							И ТЧ.МожноОкруглять
	|						ТОГДА &ДопустимыйПроцентОтклонения * ТЧ.КоличествоОкругленное / ТЧ.КоэффициентУпаковки / 100
	|					ИНАЧЕ 0
	|				КОНЕЦ КАК ЧИСЛО(15, 3)))
	|			ИЛИ (ВЫРАЗИТЬ(ВЫБОР
	|					КОГДА &ПроверитьВозможностьОкругления
	|							И ТЧ.МожноОкруглять
	|						ТОГДА ВЫБОР
	|								КОГДА ТЧ.КоличествоСуффикс - ТЧ.КоличествоСуффиксОкругленное > 0
	|									ТОГДА ТЧ.КоличествоСуффикс - ТЧ.КоличествоСуффиксОкругленное
	|								ИНАЧЕ ТЧ.КоличествоСуффиксОкругленное - ТЧ.КоличествоСуффикс
	|							КОНЕЦ
	|					ИНАЧЕ ВЫБОР
	|							КОГДА ТЧ.КоличествоВДокументеСуффикс - ТЧ.КоличествоСуффикс > 0
	|								ТОГДА ТЧ.КоличествоВДокументеСуффикс - ТЧ.КоличествоСуффикс
	|							ИНАЧЕ ТЧ.КоличествоСуффикс - ТЧ.КоличествоВДокументеСуффикс
	|						КОНЕЦ
	|				КОНЕЦ / ТЧ.КоэффициентУпаковки КАК ЧИСЛО(15, 3))) > (ВЫРАЗИТЬ(ВЫБОР
	|					КОГДА &ПроверитьВозможностьОкругления
	|							И ТЧ.МожноОкруглять
	|						ТОГДА &ДопустимыйПроцентОтклонения * ТЧ.КоличествоСуффиксОкругленное / ТЧ.КоэффициентУпаковки / 100
	|					ИНАЧЕ 0
	|				КОНЕЦ КАК ЧИСЛО(15, 3))))
	|
	|УПОРЯДОЧИТЬ ПО
	|	НомерСтроки";

	
	Если ЗначениеЗаполнено(СуффиксДопРеквизита) Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяПоляКоличествоСуффикс", "ТЧ.Количество"+СуффиксДопРеквизита);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяПоляКоличествоУпаковокСуффикс", "ТЧ.КоличествоУпаковок"+СуффиксДопРеквизита);
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяПоляКоличествоСуффикс", "0");
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяПоляКоличествоУпаковокСуффикс", "0");
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ТекстЗапросаКоэффициентУпаковки",
		Справочники.УпаковкиЕдиницыИзмерения.ТекстЗапросаКоэффициентаУпаковки(
			"ВТДляЗапроса.Упаковка",
			"ВТДляЗапроса.Номенклатура"));
			
	Если ПараметрыПроверки.УсловиеОтбораСтрокДляОкругления <> "" Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбораСтрокДляОкругления", 
									СтрЗаменить(ПараметрыПроверки.УсловиеОтбораСтрокДляОкругления, ИмяТЧ + ".", "ТЧ."));
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбораСтрокДляОкругления", "ИСТИНА");
	КонецЕсли; 
			
	Если ПараметрыПроверки.ПроверитьВозможностьОкругления Тогда
		ДопустимыйПроцентОтклонения = Константы.ДопустимоеОтклонениеПриОкругленииКоличества.Получить();
	Иначе
		ДопустимыйПроцентОтклонения = 0;
	КонецЕсли;
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Если ИмяТЧ = "Объект" Тогда
		
		Таблица = Новый ТаблицаЗначений;
		Таблица.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5,0,ДопустимыйЗнак.Неотрицательный)));	
		Таблица.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
		Таблица.Колонки.Добавить("Упаковка", Новый ОписаниеТипов("СправочникСсылка.УпаковкиЕдиницыИзмерения"));
		Таблица.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15,3,ДопустимыйЗнак.Неотрицательный)));	
		Таблица.Колонки.Добавить("КоличествоУпаковок", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15,3,ДопустимыйЗнак.Неотрицательный)));	
		
		СтрокаТаблицы = Таблица.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицы, Объект);
		
		Запрос.УстановитьПараметр("ТЧ", Таблица);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОбработкаОбъект.ПодборСерийВДокументы") Тогда 
		Таблица = Объект[ИмяТЧ].Выгрузить();
		Таблица.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
		Таблица.Колонки.Добавить("Упаковка", Новый ОписаниеТипов("СправочникСсылка.УпаковкиЕдиницыИзмерения"));
		Таблица.ЗаполнитьЗначения(Объект.ПараметрыПроверки.Номенклатура, "Номенклатура");
		Таблица.ЗаполнитьЗначения(Объект.ПараметрыПроверки.Упаковка, "Упаковка");
		Запрос.УстановитьПараметр("ТЧ", Таблица);
	Иначе	
		Запрос.УстановитьПараметр("ТЧ", Объект[ИмяТЧ].Выгрузить());
	КонецЕсли;	
	
	Запрос.УстановитьПараметр("ДопустимыйПроцентОтклонения", ДопустимыйПроцентОтклонения);
	Запрос.УстановитьПараметр("ПроверитьВозможностьОкругления", ПараметрыПроверки.ПроверитьВозможностьОкругления);
	
	МерныеТипы = Новый Массив;
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Вес);
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Объем);
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Площадь);
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Длина);
	Запрос.УстановитьПараметр("МерныеТипы", МерныеТипы);
	Запрос.УстановитьПараметр("ШтучныйТип", Перечисления.ТипыИзмеряемыхВеличин.КоличествоШтук);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если ИмяТЧ = "Объект" Тогда
		Если Не ПараметрыПроверки.ПроверитьВозможностьОкругления Тогда
			ШаблонОшибкаОкругления = НСтр("ru='Количество в ""%Упаковка%"" переведено в количество в ""%БазоваяЕдиницаИзмерения%"" с погрешностью - %КоличествоОтклонение% %Упаковка%, что недопустимо, что свидетельствует об ошибке в работе программы. Обратитесь к администратору.';uk='Кількість у ""%Упаковка%"" переведено в кількість ""%БазоваяЕдиницаИзмерения%"" з похибкою - %КоличествоОтклонение% %Упаковка%, що неприпустимо, що свідчить про помилку в роботі програми. Зверніться до адміністратора.'");
		ИначеЕсли ДопустимыйПроцентОтклонения > 0 Тогда
			ШаблонОшибкаОкругления = НСтр("ru='После округления количество товара будет равно %КоличествоОкругленное% %БазоваяЕдиницаИзмерения%, при этом погрешность округления составит %КоличествоОтклонение% %Упаковка%, что превышает максимальную погрешность - %КоличествоМаксимальнаяПогрешность% %Упаковка%.';uk='Після округлення кількість товару буде дорівнювати %КоличествоОкругленное% %БазоваяЕдиницаИзмерения%, при цьому похибка округлення складе %КоличествоОтклонение% %Упаковка%, що перевищує максимальну похибку - %КоличествоМаксимальнаяПогрешность% %Упаковка%.'");
		Иначе
			ШаблонОшибкаОкругления = НСтр("ru='Количество в ""%Упаковка%"" некратно количеству в ""%БазоваяЕдиницаИзмерения%"". Отклонение - %КоличествоОтклонение% %Упаковка%.';uk='Кількість у ""%Упаковка%"" некратно кількості в ""%БазоваяЕдиницаИзмерения%"". Відхилення %КоличествоОтклонение% %Упаковка%.'");
		КонецЕсли;
	Иначе
		Если Не ПараметрыПроверки.ПроверитьВозможностьОкругления Тогда
			ШаблонОшибкаОкругления = НСтр("ru='В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" количество в ""%Упаковка%"" переведено в количество в ""%БазоваяЕдиницаИзмерения%"" с отклонением - %КоличествоОтклонение% %Упаковка%, что свидетельствует об ошибке в работе программы. Обратитесь к администратору.';uk='У рядку %НомерСтроки% списку ""%ПредставлениеТЧ%"" кількість в ""%Упаковка%"" переведено в кількість в ""%БазоваяЕдиницаИзмерения%"" з відхиленням - %КоличествоОтклонение% %Упаковка%, що свідчить про помилку в роботі програми. Зверніться до адміністратора.'");
		ИначеЕсли ДопустимыйПроцентОтклонения > 0 Тогда
			ШаблонОшибкаОкругления = НСтр("ru='После округления количество товара будет равно %КоличествоОкругленное% %БазоваяЕдиницаИзмерения% в строке %НомерСтроки% списка ""%ПредставлениеТЧ%"", при этом погрешность округления составит %КоличествоОтклонение% %Упаковка%, что превышает максимальную погрешность - %КоличествоМаксимальнаяПогрешность% %Упаковка%.';uk='Після округлення кількість товару буде дорівнювати %КоличествоОкругленное% %БазоваяЕдиницаИзмерения% у рядку %НомерСтроки% списку ""%ПредставлениеТЧ%"", при цьому похибка округлення складе %КоличествоОтклонение% %Упаковка%, що перевищує максимальну похибку - %КоличествоМаксимальнаяПогрешность% %Упаковка%.'");
		Иначе 
			ШаблонОшибкаОкругления = НСтр("ru='В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" количество в ""%Упаковка%"" некратно количеству в ""%БазоваяЕдиницаИзмерения%"". Отклонение - %КоличествоОтклонение% %Упаковка%.';uk='У рядку %НомерСтроки% списку ""%ПредставлениеТЧ%"" кількість в ""%Упаковка%"" некратно кількості в ""%БазоваяЕдиницаИзмерения%"". Відхилення - %КоличествоОтклонение% %Упаковка%.'");
		КонецЕсли;
		ШаблонОшибкаОкругления = СтрЗаменить(ШаблонОшибкаОкругления, "%ПредставлениеТЧ%", ПредставлениеТЧ);
	КонецЕсли;
	
	Пока Выборка.Следующий() Цикл
		Если Выборка.КоличествоОтклонение > Выборка.КоличествоМаксимальнаяПогрешность Тогда
			ТекстСообщения = ШаблонОшибкаОкругления;
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%БазоваяЕдиницаИзмерения%", Выборка.БазоваяЕдиницаИзмерения);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоОтклонение%", Выборка.КоличествоОтклонение);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%Упаковка%", Выборка.Упаковка);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоМаксимальнаяПогрешность%", Выборка.КоличествоМаксимальнаяПогрешность);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоОкругленное%", Выборка.КоличествоОкругленное);
			Если ИмяТЧ = "Объект" Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения, КлючДанных, "КоличествоУпаковок", "Объект", Отказ);
			Иначе
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%НомерСтроки%", Строка(Выборка.НомерСтроки));
				Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, Выборка.НомерСтроки, "КоличествоУпаковок");
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,"Объект",Отказ);
			КонецЕсли;
		КонецЕсли;
		Если Выборка.КоличествоСуффиксОтклонение > Выборка.КоличествоСуффиксМаксимальнаяПогрешность Тогда
			ТекстСообщения = ШаблонОшибкаОкругления;
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%БазоваяЕдиницаИзмерения%", Выборка.БазоваяЕдиницаИзмерения);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоОтклонение%", Выборка.КоличествоСуффиксОтклонение);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%Упаковка%", Выборка.Упаковка);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоМаксимальнаяПогрешность%", Выборка.КоличествоСуффиксМаксимальнаяПогрешность);
			ТекстСообщения = СтрЗаменить(ТекстСообщения, "%КоличествоОкругленное%", Выборка.КоличествоСуффиксОкругленное);
			Если ИмяТЧ = "Объект" Тогда
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения, КлючДанных, "КоличествоУпаковок"+СуффиксДопРеквизита, "Объект" , Отказ);
			Иначе
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%НомерСтроки%", Строка(Выборка.НомерСтроки));
				Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, Выборка.НомерСтроки, "КоличествоУпаковок"+СуффиксДопРеквизита);
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,"Объект",Отказ);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Функция возвращает параметры для округления
//
//	Возвращаемое значение:
//		Структура:
//			*ИмяТЧ - Строка - значение по умолчанию "Товары"
//			*СуффиксДопРеквизита - Строка - значение по умолчанию "" - если в ТЧ два реквизита "Количество", то второй назван с суффиком. 
//											если суффикс передан, то проверяются оба реквизита
//			*УсловиеОтбораСтрокДляОкругления - Строка - Условие выбора строк для проверки округления.
//											в качестве имени таблицы нужно использовать имя переданное в ИмяТЧ
//
Функция ПараметрыОкругленияКоличестваШтучныхТоваров() Экспорт
	
	ПараметрыОкругления = Новый Структура;
	ПараметрыОкругления.Вставить("ИмяТЧ",                           "Товары");	
	ПараметрыОкругления.Вставить("СуффиксДопРеквизита",             "");
	ПараметрыОкругления.Вставить("УсловиеОтбораСтрокДляОкругления", "");
	
	Возврат ПараметрыОкругления;
	
КонецФункции

// Округляет количество товара до целых штук при указании количества в документе в мерных единицах измерения
//
Процедура ОкруглитьКоличествоШтучныхТоваров(Объект, РежимЗаписи = Неопределено, ПараметрыОкругления = Неопределено) Экспорт
	
	Если РежимЗаписи <> Неопределено 
		И РежимЗаписи <> РежимЗаписиДокумента.Проведение
		И ТипЗнч(РежимЗаписи) = Тип("РежимЗаписиДокумента")
		И Объект.Метаданные().Проведение = Метаданные.СвойстваОбъектов.Проведение.Разрешить Тогда
		Возврат;
	КонецЕсли;
	
	Если ПараметрыОкругления = Неопределено Тогда
		ПараметрыОкругления = ПараметрыПроверкиЗаполненияКоличества();
	КонецЕсли;
	
	СуффиксДопРеквизита = ПараметрыОкругления.СуффиксДопРеквизита;
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ТЧ.НомерСтроки КАК НомерСтроки,
	|	ТЧ.Номенклатура КАК Номенклатура,
	|	ТЧ.Упаковка,
	|	ВЫРАЗИТЬ(ТЧ.Количество КАК ЧИСЛО(15, 0)) КАК КоличествоОкругленное,
	|	ВЫРАЗИТЬ(&ИмяПоляКоличествоСуффикс КАК ЧИСЛО(15, 0)) КАК КоличествоСуффиксОкругленное
	|ПОМЕСТИТЬ ВТ
	|ИЗ
	|	&ТЧ КАК ТЧ
	|ГДЕ
	|	ТЧ.Упаковка <> ЗНАЧЕНИЕ(Справочник.УпаковкиЕдиницыИзмерения.ПустаяСсылка)
	|	И (ТЧ.Количество <> (ВЫРАЗИТЬ(ТЧ.Количество КАК ЧИСЛО(15, 0)))
	|			ИЛИ &ИмяПоляКоличествоСуффикс <> (ВЫРАЗИТЬ(&ИмяПоляКоличествоСуффикс КАК ЧИСЛО(15, 0))))
	|	И (&УсловиеОтбораСтрокДляОкругления)
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТЧ.НомерСтроки КАК НомерСтроки,
	|	ТЧ.КоличествоОкругленное КАК КоличествоОкругленное,
	|	ТЧ.КоличествоСуффиксОкругленное КАК КоличествоСуффиксОкругленное
	|ИЗ
	|	ВТ КАК ТЧ
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Номенклатура КАК ТНоменклатура
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.УпаковкиЕдиницыИзмерения КАК ТУпаковкиЕдиницыХранения
	|			ПО (ТУпаковкиЕдиницыХранения.Ссылка = ТНоменклатура.ЕдиницаИзмерения)
	|				И (ТУпаковкиЕдиницыХранения.ТипИзмеряемойВеличины = &ШтучныйТип)
	|		ПО (ТНоменклатура.Ссылка = ТЧ.Номенклатура)
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.УпаковкиЕдиницыИзмерения КАК ТУпаковкиТЧ
	|		ПО (ТУпаковкиТЧ.Ссылка = ТЧ.Упаковка)
	|			И (ТУпаковкиТЧ.ТипИзмеряемойВеличины В (&МерныеТипы))";
	
	Если ЗначениеЗаполнено(СуффиксДопРеквизита) Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяПоляКоличествоСуффикс", "ТЧ.Количество"+СуффиксДопРеквизита);
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяПоляКоличествоСуффикс", "0");
	КонецЕсли;
	
	Если ПараметрыОкругления.УсловиеОтбораСтрокДляОкругления <> "" Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбораСтрокДляОкругления", 
									СтрЗаменить(ПараметрыОкругления.УсловиеОтбораСтрокДляОкругления, ПараметрыОкругления.ИмяТЧ + ".", "ТЧ."));
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбораСтрокДляОкругления", "ИСТИНА");
	КонецЕсли; 
	
	Запрос = Новый Запрос(ТекстЗапроса);
		
	Если ПараметрыОкругления.ИмяТЧ = "Объект" Тогда
		
		Таблица = Новый ТаблицаЗначений;
		Таблица.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5,0,ДопустимыйЗнак.Неотрицательный)));	
		Таблица.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
		Таблица.Колонки.Добавить("Упаковка", Новый ОписаниеТипов("СправочникСсылка.УпаковкиЕдиницыИзмерения"));
		Таблица.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15,3,ДопустимыйЗнак.Неотрицательный)));	
		
		СтрокаТаблицы = Таблица.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицы, Объект);
		
		Запрос.УстановитьПараметр("ТЧ", Таблица);
	Иначе	
		Запрос.УстановитьПараметр("ТЧ", Объект[ПараметрыОкругления.ИмяТЧ].Выгрузить());
	КонецЕсли;	
	
	МерныеТипы = Новый Массив;
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Вес);
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Объем);
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Площадь);
	МерныеТипы.Добавить(Перечисления.ТипыИзмеряемыхВеличин.Длина);
	Запрос.УстановитьПараметр("МерныеТипы", МерныеТипы);
	Запрос.УстановитьПараметр("ШтучныйТип", Перечисления.ТипыИзмеряемыхВеличин.КоличествоШтук);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Если ПараметрыОкругления.ИмяТЧ = "Объект" Тогда
			Объект.Количество = Выборка.КоличествоОкругленное;
			Если ЗначениеЗаполнено(СуффиксДопРеквизита) Тогда
				Объект["Количество" + СуффиксДопРеквизита] = Выборка.КоличествоСуффиксОкругленное;
			КонецЕсли;
		Иначе
			Объект[ПараметрыОкругления.ИмяТЧ][Выборка.НомерСтроки - 1].Количество = Выборка.КоличествоОкругленное;
			Если ЗначениеЗаполнено(СуффиксДопРеквизита) Тогда
				Объект[ПараметрыОкругления.ИмяТЧ][Выборка.НомерСтроки - 1]["Количество" + СуффиксДопРеквизита] = Выборка.КоличествоСуффиксОкругленное;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Процедура проверяет дубли строк в табличной части
// Параметры:
//	Объект - проверяемый ДокументОбъект
//	ИмяТЧ - имя проверяемой табличной части
//	КлючевыеРеквизиты - массив имен реквизитов, по которым определяется уникальность строки
//	Отказ - отказ продолжения операции
Процедура ПроверитьНаличиеДублейСтрокТЧ(Объект,ИмяТЧ,КлючевыеРеквизиты,Отказ, ПредставлениеТЧ = "", УказыватьНомераСтрок = Истина) Экспорт
	
	КлючДанных = КлючДанныхДляСообщенияПользователю(Объект);
	
	МетаданныеОбъекта = Объект.Метаданные();
	Если ПустаяСтрока(ПредставлениеТЧ) Тогда
		ПредставлениеТЧ   = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Синоним;
	КонецЕсли;
	
	ТекстПоляВыборки = "";
	ТекстПоляСоединения = "";	
    ТекстПоляВыгрузки = "";
	ТекстДляСообщенияОДублях = "";
	Для Каждого СтрМас из КлючевыеРеквизиты Цикл
		ТекстПоляВыборки = ТекстПоляВыборки + "
	|	ТаблицаПроверки." + СтрМас + ",";
		ТекстПоляСоединения = ТекстПоляСоединения + "
	|	И ТаблицаПроверки." + СтрМас + " = ДублирующиесяСтроки."+ СтрМас;
		ТекстПоляВыгрузки = ТекстПоляВыгрузки + СтрМас + ",";
		
		ПредставлениеРеквизита = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Реквизиты[СтрМас].Синоним;
		
		ТекстДляСообщенияОДублях = ТекстДляСообщенияОДублях + """"  + ПредставлениеРеквизита  + """, "
	КонецЦикла;	
	
	ТекстДляСообщенияОДублях = Лев(ТекстДляСообщенияОДублях, СтрДлина(ТекстДляСообщенияОДублях) - 2);
	
	СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(ТекстПоляВыборки,1);
	СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(ТекстПоляВыгрузки,1);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ 
	|	ТаблицаПроверки.НомерСтроки, " +
		ТекстПоляВыборки + "
	|ПОМЕСТИТЬ ТаблицаПроверки
	|ИЗ
	|	&ТаблицаПроверки КАК ТаблицаПроверки
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	МИНИМУМ(ТаблицаПроверки.НомерСтроки) КАК НомерСтроки,
	|	СУММА(1) КАК КоличествоДублей,"+
		ТекстПоляВыборки + "
	|ПОМЕСТИТЬ ДублирующиесяСтроки
	|ИЗ
	|	ТаблицаПроверки КАК ТаблицаПроверки
	|
	|СГРУППИРОВАТЬ ПО " +
		ТекстПоляВыборки + "
	|
	|ИМЕЮЩИЕ
	|	СУММА(1) > 1
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицаПроверки.НомерСтроки,
	|	ДублирующиесяСтроки.НомерСтроки КАК ПерваяСтрока,"+
		ТекстПоляВыборки + "
	|ИЗ
	|	ТаблицаПроверки КАК ТаблицаПроверки
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ДублирующиесяСтроки КАК ДублирующиесяСтроки
	|		ПО ТаблицаПроверки.НомерСтроки <> ДублирующиесяСтроки.НомерСтроки " +
	     		ТекстПоляСоединения;
	Запрос.УстановитьПараметр("ТаблицаПроверки",Объект[ИмяТЧ].Выгрузить(,"НомерСтроки," + ТекстПоляВыгрузки));
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если УказыватьНомераСтрок Тогда
		Если КлючевыеРеквизиты.Количество() = 1 Тогда
			ШаблонСообщения = НСтр("ru='В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" по сравнению со строкой %ПерваяСтрока% повторяется значение ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.';uk='У рядку %НомерСтроки% списку ""%ПредставлениеТЧ%  у порівнянні з рядком %ПерваяСтрока% повторюється значення ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.'");
		Иначе
			ШаблонСообщения = НСтр("ru='В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" по сравнению со строкой %ПерваяСтрока% повторяется сочетание значений ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.';uk='У рядку %НомерСтроки% списку ""%ПредставлениеТЧ%"" у  порівнянні з рядком %ПерваяСтрока% повторюється поєднання значень ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.'");
		КонецЕсли;	
	Иначе
		Если КлючевыеРеквизиты.Количество() = 1 Тогда
			ШаблонСообщения = НСтр("ru='В списке ""%ПредставлениеТЧ%"" повторяется значение ""%ПовторяемоеЗначение%"" в поле %НазванияПолей%.';uk='До списку ""%ПредставлениеТЧ%"" повторюється значення ""%ПовторяемоеЗначение%"" в полі %НазванияПолей%.'");
		Иначе
			ШаблонСообщения = НСтр("ru='В списке ""%ПредставлениеТЧ%"" повторяется сочетание значений ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.';uk='До списку  ""%ПредставлениеТЧ%"" повторюється поєднання значень ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.'");
		КонецЕсли;	
	КонецЕсли;
	Пока Выборка.Следующий() Цикл
		
		ТекстСообщения =  СтрЗаменить(ШаблонСообщения, "%ПредставлениеТЧ%", ПредставлениеТЧ);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%НомерСтроки%", Выборка.НомерСтроки);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%ПерваяСтрока%", Выборка.ПерваяСтрока);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%НазванияПолей%", ТекстДляСообщенияОДублях);
		
		ПовторяемоеЗначение = "";
		
		Для Каждого СтрМас из КлючевыеРеквизиты Цикл
			ПредставлениеЗначения = СокрЛП(Строка(Выборка[СтрМас]));
			Если ЗначениеЗаполнено(ПредставлениеЗначения) Тогда
				ПовторяемоеЗначение = ПовторяемоеЗначение + Выборка[СтрМас] + "/";
			КонецЕсли;
		КонецЦикла;
		ПовторяемоеЗначение = Лев(ПовторяемоеЗначение, СтрДлина(ПовторяемоеЗначение) - 1);
		
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%ПовторяемоеЗначение%", ПовторяемоеЗначение);
		
		Если УказыватьНомераСтрок Тогда
			Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, Выборка.НомерСтроки, "НомерСтроки");
		Иначе
			Поле = ИмяТЧ;
		КонецЕсли;
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,"Объект",Отказ);
		
	КонецЦикла;
КонецПроцедуры

// Процедура заполняет значения реквизитов табличной части по структуре
//
// Параметры:
// 		КоллекцияДанных - ДанныеФормыКоллекция - Табличная часть
// 		СтруктураРеквизитов - Структура - Структура. Ключ - имя реквизита флага активности. Значение - строка перечисления зависимых реквизитов
//
Процедура ЗаполнитьДубликатыЗависимыхРеквизитовВКоллекции(КоллекцияДанных, СтруктураРеквизитов) Экспорт
	
	// Получение шаблона поля выборки для значения дубликата реквизита
	// 		Если флаг активности ИСТИНА - скопировать значение из реквизита
	// 		Иначе - заполнить пустым значением
	ШаблонПоляВыборки = ",
	|	ВЫБОР КОГДА Коллекция.%ИмяФлага% = ИСТИНА
	|		ТОГДА Коллекция.%ИмяРеквизита%
	|		ИНАЧЕ 0
	|	КОНЕЦ КАК %ИмяРеквизита%%ИмяФлага%";
	
	ПоляВыборки = ""; // Поля выборки для запроса получения данных
	ПоляВыгрузки = "НомерСтроки"; // Перечисление через запятую полей, выгружаемых из коллекции
	Для Каждого РеквизитФлага Из СтруктураРеквизитов Цикл
		ПоляВыгрузки = ПоляВыгрузки + ", " + РеквизитФлага.Ключ;
		ЗависимыеРеквизиты = Новый Структура(РеквизитФлага.Значение);
		Для Каждого ЗависимыйРеквизит Из ЗависимыеРеквизиты Цикл
			ПоляВыборки = ПоляВыборки + СтрЗаменить(СтрЗаменить(ШаблонПоляВыборки, "%ИмяФлага%", РеквизитФлага.Ключ), "%ИмяРеквизита%", ЗависимыйРеквизит.Ключ);
			ПоляВыгрузки = ПоляВыгрузки + ", " + ЗависимыйРеквизит.Ключ + ", " + ЗависимыйРеквизит.Ключ + РеквизитФлага.Ключ;
		КонецЦикла;
	КонецЦикла;
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Коллекция.НомерСтроки" + ПоляВыборки + "
	|ПОМЕСТИТЬ втКоллекция
	|ИЗ &КоллекцияДанных КАК Коллекция;
	|
	|ВЫБРАТЬ *
	|ИЗ втКоллекция КАК втКоллекция
	|УПОРЯДОЧИТЬ ПО НомерСтроки");
	Запрос.УстановитьПараметр("КоллекцияДанных", КоллекцияДанных.Выгрузить( , ПоляВыгрузки));
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		ЗаполнитьЗначенияСвойств(КоллекцияДанных[Выборка.НомерСтроки-1], Выборка, , "НомерСтроки");
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьДубликатыЗависимыхРеквизитовВКоллекции()

// Процедура проверяет отмену строк в табличной части документа
// Параметры:
//	Объект - проверяемый ДокументОбъект
//	ИмяТЧ - Строка - имя проверяемой табличной части
//	ИмяРеквизитаОтменыСтрок - Строка - имя проверяемого булевого реквизита ТЧ
//
Функция ВсеСтрокиОтменены(Объект, ИмяТЧ, ИмяРеквизитаОтменыСтрок) Экспорт
	
	СтруктураОтбора = Новый Структура(ИмяРеквизитаОтменыСтрок, Ложь);
	НеОтмененныеСтроки = Объект[ИмяТЧ].НайтиСтроки(СтруктураОтбора);
	
	Возврат (НеОтмененныеСтроки.Количество() = 0);
	
КонецФункции

// Создает фиксированную структуру, сожержащую свойства одноименные колонкам таблицы формы.
//
//  Параметры:
//   - Форма - УправляемаяФорма - форма, содержащая таблицу и служебный реквизит,
//                                имя которого образовано именем таблицы с префиксом "Кеш".
//  ИмяТабличнойЧасти - Строка - имя таблицы формы, текущие данные которой необходимо скопировать в служебный реквизит формы.
//                               Имя служебного реквизита должно состоять из префикcа Кеш и имени табличной части.
//
Процедура ИнициализироватьКешТекущейСтроки(Форма, ИмяТабличнойЧасти, ПутьКТабличнойЧасти = "Объект") Экспорт

	Если ЗначениеЗаполнено(ПутьКТабличнойЧасти) Тогда
		МассивРеквизитовФормы = Форма.ПолучитьРеквизиты(ПутьКТабличнойЧасти + "." + ИмяТабличнойЧасти);
	Иначе
		МассивРеквизитовФормы = Форма.ПолучитьРеквизиты(ИмяТабличнойЧасти);
	КонецЕсли;
	
	РезультатСтруктура = Новый Структура;
	Для Каждого РеквизитФормы Из МассивРеквизитовФормы Цикл
		РезультатСтруктура.Вставить(РеквизитФормы.Имя, Истина);
	КонецЦикла;

	Форма[ИмяТабличнойЧасти + "КешТекущейСтроки"] = Новый ФиксированнаяСтруктура(РезультатСтруктура);

КонецПроцедуры

#КонецОбласти

#Область КонтрольНесогласованныхИзменений

// Осуществляет установку подписки на события изменения элементов формы.
//
// Параметры:
// 		Форма                    - ДокументОбъект, СправочникОбъект - Проверяемый объект.
// 		МассивЭлементов          - Массив - массив элементов формы.
// 		УстановитьПодписку - Булево - необходимость установки или снятия предупреждения.
//
Процедура УстановитьПодпискуНаСобытияИзмененияЭлементовФормы(Форма, ИменаЭлементов, Установить) Экспорт
	
	Если Не ЗначениеЗаполнено(Форма.Объект.Ссылка) Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураПолейТаблиц = Новый Структура;
	
	ТипУправляемаяФорма = Тип("УправляемаяФорма");
	ТипДанныеФормыКоллекция = Тип("ДанныеФормыКоллекция");
	ТипДанныеФормыДерево = Тип("ДанныеФормыДерево");
	ТипДанныеФормыСтруктура = Тип("ДанныеФормыСтруктура");
	ТипПолеФормы = Тип("ПолеФормы");
	ТипКнопкаФормы = Тип("КнопкаФормы");
	ТипТаблицаФормы = Тип("ТаблицаФормы");
	
	Элементы = Форма.Элементы;
	
	ОбработчикиСобытийТабличныхЧастей = Новый Структура();
	МассивЭлементов = Новый Массив;
	Для Каждого ИмяЭлементаПолное Из ИменаЭлементов Цикл
		
		ПозицияРазделителя = СтрНайти(ИмяЭлементаПолное, ";");
		Если ПозицияРазделителя > 0 Тогда
			Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭлементаПолное, ";");
			ИмяЭлемента = Массив[0];
		Иначе
			ИмяЭлемента = ИмяЭлементаПолное;
		КонецЕсли;
		
		Если МассивЭлементов.Найти(ИмяЭлемента) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Элемент = Элементы.Найти(ИмяЭлемента);
		Если Элемент = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		МассивЭлементов.Добавить(ИмяЭлемента);
		
		Если ПозицияРазделителя > 0 И Массив.Количество() > 1 Тогда
			Если СтрНайти(Массив[1], ",") > 0 Тогда
				ОбработчикиСобытийТабличныхЧастей.Вставить(ИмяЭлемента, СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Массив[1], ","));
			Иначе	
				ОбработчикиСобытийТабличныхЧастей.Вставить(ИмяЭлемента, Массив[1]);
			КонецЕсли;
		КонецЕсли;
		
		ПоляИсключения = Новый Массив;
		Если ПозицияРазделителя > 0
			И Массив.Количество() > 2 Тогда
			ПоляИсключения = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Массив[2], ",");
		КонецЕсли;
		
		ОбработатьВложенныеПоля(Элементы, Элемент, МассивЭлементов, СтруктураПолейТаблиц, ПоляИсключения);
		
	КонецЦикла;
	
	ИмяОбработчикаПустой = "Подключаемый_ПустойОбработчик_УстановитьДоступностьЭлементовПоСтатусуСервер";
	Если Форма.СтруктураДействийКонтрольНеСогласованныхИзменений = Неопределено Тогда
		
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений = Новый Структура;
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("Команды", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПриИзменении", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("Нажатие", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПередНачаломИзменения", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПередНачаломДобавления", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПередУдалением", Новый Структура);
		
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ОжидаетсяОповещение", Ложь);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ЗначенияРеквизитов", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПутьКДанным", Новый Структура);
		
		Для Каждого ИмяТаблицы Из СтруктураПолейТаблиц Цикл
			
			Имена = Новый Массив;
			Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ЗначенияРеквизитов.Вставить(ИмяТаблицы.Ключ, Новый Структура);
			
			Для Каждого ИмяЭлемента Из СтруктураПолейТаблиц[ИмяТаблицы.Ключ] Цикл
				
				Данные = Неопределено;
				ПутьКДанным = Элементы[ИмяЭлемента].ПутьКДанным;
				Если ЗначениеЗаполнено(ПутьКДанным) Тогда
					
					Позиция = СтрНайти(ПутьКДанным, ".");
					Пока Позиция > 0 Цикл
						Подстрока = Лев(ПутьКДанным, Позиция - 1);
						ПутьКДанным = Сред(ПутьКДанным, Позиция + 1);
						Позиция = СтрНайти(ПутьКДанным, ".");
					КонецЦикла;					
					Имена.Добавить(ПутьКДанным);
					
				КонецЕсли;
				
			КонецЦикла;
			
			Для Каждого Имя Из Имена Цикл
				Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ЗначенияРеквизитов[ИмяТаблицы.Ключ].Вставить(Имя);
			КонецЦикла;
			
		КонецЦикла;
		
		ИмяОбработчикаПриИзменении            = "Подключаемый_ПриИзменении_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаНажатие                 = "Подключаемый_Нажатие_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаКоманды                 = "Подключаемый_Команда_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаПередНачаломИзменения   = "Подключаемый_ПередНачаломИзменения_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаПередНачаломДобавления  = "Подключаемый_ПередНачаломДобавления_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаПередУдалением          = "Подключаемый_ПередУдалением_УстановитьДоступностьЭлементовПоСтатусуСервер";
		
		Для Каждого ИмяЭлементаПолное Из МассивЭлементов Цикл
			
			ПозицияРазделителя = СтрНайти(ИмяЭлементаПолное, ";");
			Если ПозицияРазделителя > 0 Тогда
				ИмяЭлемента = Лев(ИмяЭлементаПолное, ПозицияРазделителя - 1);
			Иначе
				ИмяЭлемента = ИмяЭлементаПолное;
			КонецЕсли;
			
			Элемент = Элементы[ИмяЭлемента];
			Если Элемент = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ТипЗнчЭлемент = ТипЗнч(Элемент);
			
			Если ТипЗнчЭлемент = ТипПолеФормы Тогда
				
				Действие = Элемент.ПолучитьДействие("ПриИзменении");
				Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПриИзменении.Вставить(ИмяЭлемента, Действие);
				КонецЕсли;
				
				Данные = Неопределено;
				ПутьКДанным = Элемент.ПутьКДанным;
				Если ЗначениеЗаполнено(ПутьКДанным) Тогда
					Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьКДанным, ".");
					Данные = Форма;
					Для Каждого СтрокаМассива Из Массив Цикл
						ТипЗнчДанные = ТипЗнч(Данные);
						Если ТипЗнчДанные = ТипУправляемаяФорма
							ИЛИ ТипЗнчДанные = ТипДанныеФормыСтруктура Тогда
							Данные = Данные[СтрокаМассива];
						Иначе
							Данные = Неопределено;
							Прервать;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
				Если Данные <> Неопределено Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ЗначенияРеквизитов.Вставить(ИмяЭлемента, Данные);
				КонецЕсли;
				Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПутьКДанным.Вставить(ИмяЭлемента, ПутьКДанным);
				Элемент.УстановитьДействие("ПриИзменении", ИмяОбработчикаПриИзменении);
				
			ИначеЕсли ТипЗнчЭлемент = ТипТаблицаФормы Тогда
				
				Действия = Неопределено;
				ОбработчикиСобытийТабличныхЧастей.Свойство(ИмяЭлемента, Действия);
				
				Если Действия = Неопределено Или Действия.Найти("ПередНачаломДобавления") <> Неопределено Тогда
					Действие = Элементы[ИмяЭлемента].ПолучитьДействие("ПередНачаломДобавления");
					Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
						Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПередНачаломДобавления.Вставить(ИмяЭлемента, Действие);
					КонецЕсли;
					Элемент.УстановитьДействие("ПередНачаломДобавления", ИмяОбработчикаПередНачаломДобавления);
				КонецЕсли;
				
				Если Действия = Неопределено Или Действия.Найти("ПередУдалением") <> Неопределено Тогда
					Действие = Элементы[ИмяЭлемента].ПолучитьДействие("ПередУдалением");
					Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
						Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПередУдалением.Вставить(ИмяЭлемента, Действие);
					КонецЕсли;
					Элемент.УстановитьДействие("ПередУдалением", ИмяОбработчикаПередУдалением);
				КонецЕсли;
				
				Если Действия = Неопределено Или Действия.Найти("ПередНачаломИзменения") <> Неопределено Тогда
					Действие = Элементы[ИмяЭлемента].ПолучитьДействие("ПередНачаломИзменения");
					Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
						Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПередНачаломИзменения.Вставить(ИмяЭлемента, Действие);
					КонецЕсли;
					Элемент.УстановитьДействие("ПередНачаломИзменения", ИмяОбработчикаПередНачаломИзменения);
				КонецЕсли;
				
			ИначеЕсли ТипЗнчЭлемент = ТипКнопкаФормы Тогда
				
				ИмяКоманды = Элемент.ИмяКоманды;
				
				Если Не ЗначениеЗаполнено(ИмяКоманды) Тогда
					Продолжить;
				КонецЕсли;
				
				Если Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Команды.Свойство(ИмяКоманды) Тогда
					Продолжить;
				КонецЕсли;
				
				Действие = Форма.Команды[ИмяКоманды].Действие;
				Если ЗначениеЗаполнено(Действие) Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Команды.Вставить(ИмяКоманды, Действие);
				КонецЕсли;
				
				Форма.Команды[ИмяКоманды].Действие = ИмяОбработчикаКоманды;
				
			ИначеЕсли ТипЗнчЭлемент = Тип("ДекорацияФормы") Тогда
				
				Действие = Элемент.ПолучитьДействие("Нажатие");
				Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Нажатие.Вставить(ИмяЭлемента, Действие);
				КонецЕсли;
				
				Элемент.УстановитьДействие("Нажатие", ИмяОбработчикаНажатие);
				
			Иначе
				ВызватьИсключение НСтр("ru='Внутренняя ошибка';uk='Внутрішня помилка'");
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		
		Если Форма.СтруктураДействийКонтрольНеСогласованныхИзменений <> Неопределено Тогда
			Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ОжидаетсяОповещение = Ложь;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область УсловноеОформление

// Устанавливаем условное оформление для поля формы "Приоритет"
//    в зависимости от его значения
//
// Параметры:
// 		Форма - Форма - Содержит данную форму 
//
Процедура УстановитьУсловноеОформлениеПриоритета(Форма) Экспорт
	
	Если Форма.ИмяФормы = "Обработка.СамообслуживаниеПартнеров.Форма.МастерОформленияЗаказа" Тогда
		ПутьКРеквизитуПриоритет = "Приоритет";
	Иначе
		ПутьКРеквизитуПриоритет = "Объект.Приоритет";
	КонецЕсли;
	
	УсловноеОформление = Форма.УсловноеОформление;
	ЭлементыФормы = Форма.Элементы;
	
	//
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ЭлементыФормы["Приоритет"].Имя);

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизитуПриоритет);
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Справочники.Приоритеты.ПолучитьВысшийПриоритет();

	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("ЦветФона", ЦветаСтиля.ВысокийПриоритетДокумента);

	//
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ЭлементыФормы["Приоритет"].Имя);

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизитуПриоритет);
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Справочники.Приоритеты.ПолучитьНизшийПриоритет();

	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("ЦветФона", ЦветаСтиля.НизкийПриоритетДокумента);
	
	//
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Приоритеты.Ссылка КАК Приоритет,
	|	Приоритеты.Цвет   КАК Цвет
	|ИЗ
	|	Справочник.Приоритеты КАК Приоритеты");
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		
		Пока Выборка.Следующий() Цикл
			
			Элемент = УсловноеОформление.Элементы.Добавить();

			ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
			ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ЭлементыФормы.Приоритет.Имя);

			ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизитуПриоритет);
			ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
			ОтборЭлемента.ПравоеЗначение = Выборка.Приоритет;

			Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", Выборка.Цвет.Получить());
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

//Процедура заполняет всеми подчиннными полями (с учетом вложенности в группы) оформляемые поля условного оформления
//Пример вызова:
//ЗаполнитьРекурсивноПоляУсловногоОформления(ЭлементУО.Поля, Элементы.Товары.ПодчиненныеЭлементы)
//
//	Параметры:
//		ОформляемыеПоляКомпоновкиДанных	- ОформляемыеПоляКомпоновкиДанных
//		КоллекцияЭлементов - ЭлементыФормы
//      ИсключаяПоля - Массив, Строка, Неопределено - значение по умолчанию Неопределено, массив имен элементов, которые не нужно добавлять в оформляемые поля
//
Процедура ЗаполнитьРекурсивноПоляУсловногоОформления(ОформляемыеПоляКомпоновкиДанных, КоллекцияЭлементов, Знач ИсключаяПоля = Неопределено) Экспорт
	
	Если ТипЗнч(ИсключаяПоля) = Тип("Строка") Тогда
		ИсключаяПоля = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИсключаяПоля);
	КонецЕсли;
	
	Для Каждого Поле из КоллекцияЭлементов Цикл
		Если ТипЗнч(Поле) = Тип("ПолеФормы") Тогда
			Если ИсключаяПоля = Неопределено
				Или ИсключаяПоля.Найти(Поле.Имя) = Неопределено Тогда
					ПолеЭлемента = ОформляемыеПоляКомпоновкиДанных.Элементы.Добавить();
					ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(Поле.Имя);
			КонецЕсли;
		ИначеЕсли ТипЗнч(Поле) = Тип("ГруппаФормы")Тогда	
			ЗаполнитьРекурсивноПоляУсловногоОформления(ОформляемыеПоляКомпоновкиДанных, Поле.ПодчиненныеЭлементы);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Добавляет на форму условное оформление элемента (отметку незаполненного), исходя из значения служебного реквизита
// по следующему правилу: если реквизит не заполнен а служебный реквизит заполнен то пометка устанавливается, иначе снимается.
//
//  Параметры:
//   УсловноеОформление - УсловноеОформление - условное офрмление формы.
//   ИмяЭлемента - Строка - имя элемента для условного оформления.
//   ИмяРеквизита - Произвольный - Реквизит формы, связанный с элементом формы.
//   ИмяТЧ - Строка - имя табличной части, если требуется оформлять поле таблицы формы.
//   ИмяПризнака - Строка - имя служебного реквизита.
//
Процедура УстановитьСнятьОтметкуНезаполненного(УсловноеОформление, ИмяЭлемента, ИмяРеквизита, ИмяТЧ, ИмяПризнака) Экспорт
	
	Подстановка = ?(ИмяТЧ = "", "", "Объект." + ИмяТЧ + ".");
	ПутьКПризнаку = "Объект.Товары.ИмяПризнака";
	ПутьКПризнаку = СтрЗаменить(ПутьКПризнаку, "Объект.Товары.", Подстановка);
	ПутьКПризнаку = СтрЗаменить(ПутьКПризнаку, "ИмяПризнака", ИмяПризнака);
	
	Подстановка = ?(ИмяТЧ = "", "", ИмяТЧ + ".");
	ПутьКРеквизиту = "Объект.Товары.ИмяРеквизита";
	ПутьКРеквизиту = СтрЗаменить(ПутьКРеквизиту, "Товары.", Подстановка);
	ПутьКРеквизиту = СтрЗаменить(ПутьКРеквизиту, "ИмяРеквизита", ИмяРеквизита);
	
	// Установка отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКПризнаку);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено;
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизиту);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Истина);
	
	// Установка отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКПризнаку);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	Отбор.ПравоеЗначение = Истина;
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизиту);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Истина);
	
	// Снятие отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКПризнаку);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Ложь);
	
	// Снятие отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКПризнаку);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	Отбор.ПравоеЗначение = Ложь;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Ложь);
	
	// Снятие отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизиту);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Ложь);
	
КонецПроцедуры

#КонецОбласти

#Область ПереключениеИнтерфейса

// Установка набора видимых подсистем командного интерфейса 
// и настроек всем пользователям вида интерфейса (Такси / в закладках).
//
// Параметры:
//  Режим - Строка - ИнтерфейсТакси / ИнтерфейсВерсии82 - соответствует константе, которая будет установлена в Истину
//
Процедура УстановитьРежимКомандногоИнтерфейса(Режим) Экспорт
	
	Если НЕ ОбщегоНазначенияПовтИсп.ДоступноИспользованиеРазделенныхДанных() Тогда
		Возврат;
	КонецЕсли;
	
	// Установка констант
	
	РежимТакси = ВРег(Режим) = ВРег("ИнтерфейсТакси");
	Режим82    = ВРег(Режим) = ВРег("ИнтерфейсВерсии82");
	
	Если НЕ РежимТакси
		И НЕ Режим82 Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	Константы.ИнтерфейсВерсии82.Установить(Режим82);
	
	// Установка настроек по умолчанию всем пользователям
	
	ВсеПользователи = ПользователиИнформационнойБазы.ПолучитьПользователей();
	Если ВсеПользователи.Количество() > 0 Тогда
		Для каждого ПользовательИБ Из ВсеПользователи Цикл
			ПользователиСлужебный.УстановитьНачальныеНастройки(ПользовательИБ.Имя);
		КонецЦикла;
	Иначе
		ПользователиСлужебный.УстановитьНачальныеНастройки("");
	КонецЕсли;

КонецПроцедуры

Процедура ПереключениеИнтерфейсаПриСозданииНаСервере(Форма) Экспорт 

	// Значения реквизитов формы
	Если Константы.ИнтерфейсВерсии82.Получить() Тогда
		Форма.ВариантИнтерфейса = "ИнтерфейсВерсии82";
	Иначе
		Форма.ВариантИнтерфейса = "ИнтерфейсТакси";
	КонецЕсли;
	Форма.ВариантИнтерфейсаДоИзменения = Форма.ВариантИнтерфейса;
	
	ТекущийРежим = Метаданные.РежимСовместимостиИнтерфейса;
	Такси = (ТекущийРежим = Метаданные.СвойстваОбъектов.РежимСовместимостиИнтерфейса.Такси
		ИЛИ ТекущийРежим = Метаданные.СвойстваОбъектов.РежимСовместимостиИнтерфейса.ТаксиРазрешитьВерсия8_2);
	
	Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Очистить();
	ПредставлениеИнтерфейса82 = НСтр("ru='Как в предыдущих версиях УправлениеТорговлей';uk='Як в попередніх версіях УправлінняТоргівлею'");
	Если Такси ИЛИ ПолучитьФункциональнуюОпцию("БазоваяВерсия") Тогда
	
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсТакси", НСтр("ru='""Такси"" (рекомендуется)';uk='""Таксі"" (рекомендується)'"));
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсВерсии82", ПредставлениеИнтерфейса82);
		
	Иначе
		
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсТакси", НСтр("ru='""Такси""';uk='""Таксі""'"));
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсВерсии82", ПредставлениеИнтерфейса82 + " " + НСтр("ru='(рекомендуется)';uk='(рекомендується)'"));
		
	КонецЕсли; 

КонецПроцедуры
 
#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ПроцедурыИФункцииУстановкиСтатусовДляМассиваДокументов

// Возвращает соответствие массивов документов по типам
//
// Параметры:
// 		МассивСсылок - Массив - Массив ссылок
//
// Возвращаемое значение:
// 		Соответствие - Ключ: Тип; значение: Массив ссылок на документы
//
Функция РазложитьМассивСсылокПоТипам(МассивСсылок) Экспорт
	
	СоответствиеТипов = Новый Соответствие;
	
	Для н = 0 По МассивСсылок.Количество() -1 Цикл
		
		ТипСсылки = ТипЗнч(МассивСсылок[н]);
		Массив = СоответствиеТипов[ТипСсылки];
		Если Массив = Неопределено Тогда
			Массив = Новый Массив;
			СоответствиеТипов.Вставить(ТипСсылки, Массив);
		КонецЕсли;
		Массив.Добавить(МассивСсылок[н]);
		
	КонецЦикла;
	
	Возврат СоответствиеТипов;
	
КонецФункции // РазложитьМассивСсылокПоТипам

#КонецОбласти

#Область МетодыРаботыСРеквизитамиОбъектов

// Позволяет определить есть ли среди реквизитов табличной части объекта реквизит с переданным именем.
//
// Параметры:
//  ИмяРеквизита - строковое имя искомого реквизита.
//  МетаданныеОбъекта - описание метаданных объекта, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - строковое имя табличной части объекта, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиОбъекта(ИмяРеквизита, МетаданныеОбъекта, ИмяТабЧасти) Экспорт

	ТабЧасть = МетаданныеОбъекта.ТабличныеЧасти.Найти(ИмяТабЧасти);

	Если ТабЧасть = Неопределено Тогда // нет такой таб. части
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ТабЧасть.Реквизиты.Найти(ИмяРеквизита) <> Неопределено;
	
КонецФункции

#КонецОбласти

#Область ЗаменаСсылокПоИнформационнойБазе

// Заменяет ссылки по информационной базе
//Параметры:
//	ПарыЗамены - Соответствие - ключи содержат замещаемых, значения содержат заменители
//	Исключения - Массив - необязателен, значения типа ОбъектМетаданных, в экземплярах которых замены проводить нельзя
Процедура ЗаменитьСсылки(ПарыЗамен, Исключения = Неопределено) Экспорт
	Английский = Метаданные.СвойстваОбъектов.ВариантВстроенногоЯзыка.Английский;
	ДвиженияССубконтоИмя = ?(Метаданные.ВариантВстроенногоЯзыка = Английский, ".RecordsWithExtDimensions", ".ДвиженияССубконто");
	
	Если Исключения = Неопределено Тогда
		Исключения = Новый Массив;
	КонецЕсли;
	
	// [ссылающийся объект](.Метаданные, .Замены[(.Замещаемое, .Заменитель)], .ТипыЗамещаемых[])
	ИндексЗамены = ИндексЗамены(ПарыЗамен);
	КешПолей = Новый Соответствие;
	// обходим индекс и в каждом ключе-объекта полностью замещаем все ссылки, подлежащие замене
	Для Каждого УзелЗамены Из ИндексЗамены Цикл
		Ссылка = УзелЗамены.Ключ;
		МетаданныеУзла = УзелЗамены.Значение.Метаданные;
		Замены = УзелЗамены.Значение.Замены;
		ТипыЗамещаемых = УзелЗамены.Значение.ТипыЗамещаемых;
		
		Если Исключения.Найти(МетаданныеУзла) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если ЭтоСсылочныйОбъектМетаданных(МетаданныеУзла) Тогда
			// любой ссылочный объект
			ПолноеИмя = МетаданныеУзла.ПолноеИмя();
			ОбъектДанных = Ссылка.ПолучитьОбъект();
			ИменаПолей = ИменаПолейСТипами(КешПолей, ПолноеИмя, ТипыЗамещаемых, "Ссылка, Ref");
			ЗаменитьЗначения(ОбъектДанных, ИменаПолей, Замены);
			// табчасти объекта
			ЗаменитьВТабчастях(
				КешПолей, МетаданныеУзла.ТабличныеЧасти, ОбъектДанных, ПолноеИмя, Замены, ТипыЗамещаемых, Исключения);
			// стандартные табчасти планов
			Если Метаданные.ПланыСчетов.Содержит(МетаданныеУзла) Или Метаданные.ПланыВидовРасчета.Содержит(МетаданныеУзла) Тогда
				ЗаменитьВТабчастях(
					КешПолей, МетаданныеУзла.СтандартныеТабличныеЧасти, ОбъектДанных, ПолноеИмя, Замены, ТипыЗамещаемых, Исключения);
			КонецЕсли;
			// пишем сам объект
			ЗаписатьДанные(ОбъектДанных);
			ОбъектДанных = Неопределено;
		ИначеЕсли Метаданные.Константы.Содержит(МетаданныеУзла) Тогда
			// значения в константах
			Константа = Константы[МетаданныеУзла.Имя];
			Константа.Установить(НовоеЗначение(Константа.Получить(), Замены));
		ИначеЕсли Метаданные.РегистрыСведений.Содержит(МетаданныеУзла) Тогда
			// необъектные таблицы
			ИменаПолей = ИменаПолейСТипами(КешПолей, МетаданныеУзла.ПолноеИмя(), ТипыЗамещаемых);
			Отборы = ОтборыРегистраСведений(МетаданныеУзла, Ссылка);
			Набор = НаборЗаписей(РегистрыСведений[МетаданныеУзла.Имя], Отборы);
			
			Таблица = Набор.Выгрузить();
			Набор.Очистить();
			ЗаписатьДанные(Набор);

			ЗаменитьЗначения(Таблица[0], ИменаПолей, Замены);
			Для Каждого ИмяПоля Из ИменаПолей Цикл
				Если Не Отборы.Свойство(ИмяПоля) Тогда
					Продолжить;
				КонецЕсли;
				Набор.Отбор[ИмяПоля].Установить(НовоеЗначение(Отборы[ИмяПоля], Замены));
			КонецЦикла;
			Набор.Загрузить(Таблица);
			ЗаписатьДанные(Набор);
		КонецЕсли;
		// обработка движений документа
		Если Метаданные.Документы.Содержит(МетаданныеУзла) Тогда
			Для Каждого Движение Из МетаданныеУзла.Движения Цикл
				ДопТаблица = "";
				Если Исключения.Найти(Движение) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				Если Метаданные.РегистрыНакопления.Содержит(Движение) Тогда
					Регистр = РегистрыНакопления[Движение.Имя];
				ИначеЕсли Метаданные.РегистрыСведений.Содержит(Движение) Тогда
					Регистр = РегистрыСведений[Движение.Имя];
				ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(Движение) Тогда
					ДопТаблица = ДвиженияССубконтоИмя;
					Регистр = РегистрыБухгалтерии[Движение.Имя];
				ИначеЕсли Метаданные.РегистрыРасчета.Содержит(Движение) Тогда
					Регистр = РегистрыРасчета[Движение.Имя];
				КонецЕсли;
				ЗаменитьВПодчиненномРегистре(КешПолей, Регистр, Ссылка, Движение.ПолноеИмя() + ДопТаблица, Замены, ТипыЗамещаемых);
			КонецЦикла;
			// обработка последовательностей, включающих документ
			Для Каждого Движение Из Метаданные.Последовательности Цикл
				Если Исключения.Найти(Движение) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				Если Движение.Документы.Содержит(МетаданныеУзла) Тогда
					ЗаменитьВПодчиненномРегистре(
						КешПолей, Последовательности[Движение.Имя], Ссылка, Движение.ПолноеИмя(), Замены, ТипыЗамещаемых);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Строим соответствие вида [ссылающийся объект](.Метаданные, .Замены[(.Замещаемое, .Заменитель)], .ТипыЗамещаемых[])
// в итоге представляем результаты поиска по ссылкам в индексе с ключом-объектом, содержащим замещаемые ссылки
Функция ИндексЗамены(ПарыЗамен)
	
	СписокСсылок = Новый Массив;
	Для Каждого Пара Из ПарыЗамен Цикл
		СписокСсылок.Добавить(Пара.Ключ);
	КонецЦикла;
	РезультатыПоиска = НайтиПоСсылкам(СписокСсылок);
	// (.Ссылка: исходная ссылка; .Данные: ссылающийся объект; .Метаданные: метаданные ссылающегося объекта)
	
	ИндексЗамены = Новый Соответствие;
	Для Каждого Результат Из РезультатыПоиска Цикл
		УзелЗамены = ИндексЗамены[Результат.Данные];
		Если Неопределено = УзелЗамены Тогда
			УзелЗамены =
				Новый Структура("Метаданные, Замены, ТипыЗамещаемых", Результат.Метаданные, Новый Массив, Новый Массив);
			ИндексЗамены.Вставить(Результат.Данные, УзелЗамены);
		КонецЕсли;

		УзелЗамены.Замены.Добавить(
			Новый Структура("Замещаемое, Заменитель", Результат.Ссылка, ПарыЗамен[Результат.Ссылка]));

		ТипЗамещаемого = ТипЗнч(Результат.Ссылка);
		Если Неопределено = УзелЗамены.ТипыЗамещаемых.Найти(ТипЗамещаемого) Тогда
			УзелЗамены.ТипыЗамещаемых.Добавить(ТипЗамещаемого);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ИндексЗамены;
КонецФункции

Процедура ЗаменитьВТабчастях(КешПолей, ОписанияТабчастей, Объект, ИмяОсновнойТаблицы, Замены, ТипыЗамещаемых, Исключения)
	Для Каждого Описание Из ОписанияТабчастей Цикл
		Если Исключения.Найти(Описание) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ИменаПолей = ИменаПолейСТипами(КешПолей, ИмяОсновнойТаблицы + "." + Описание.Имя, ТипыЗамещаемых, "Ссылка, Ref");
		Для Каждого Табстрока Из Объект[Описание.Имя] Цикл
			ЗаменитьЗначения(Табстрока, ИменаПолей, Замены);
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

Процедура ЗаменитьВПодчиненномРегистре(КешПолей, МенеджерРегистра, Ссылка, ИмяТаблицыРегистра, Замены, ТипыЗамещаемых)
	ИменаПолей = ИменаПолейСТипами(КешПолей, ИмяТаблицыРегистра, ТипыЗамещаемых, "Регистратор, Recorder");
	Набор = НаборЗаписей(МенеджерРегистра, Новый Структура("Регистратор", Ссылка));
	ЗначениеЗаменено = Ложь;
	Для Каждого Запись Из Набор Цикл
		ЗаменитьЗначения(Запись, ИменаПолей, Замены, ЗначениеЗаменено);
	КонецЦикла;
	ЗаписатьДанные(Набор, ЗначениеЗаменено);
КонецПроцедуры

Функция ИменаПолейСТипами(КешПолейТаблиц, ИмяТаблицы, ТипыДанных, ИменаИсключений = "")
	ИменаПолей = Новый Массив;
	
	ТекстЗапроса = СтрЗаменить("ВЫБРАТЬ * ИЗ ТаблицаВыборки КАК Т ГДЕ Ложь", "ТаблицаВыборки", ИмяТаблицы);
	ПоляТаблицы = КешПолейТаблиц.Получить(ИмяТаблицы);
	Если Неопределено = ПоляТаблицы Тогда
		Запрос = Новый Запрос(ТекстЗапроса);
		ПоляТаблицы = Запрос.Выполнить().Колонки;
		КешПолейТаблиц.Вставить(ИмяТаблицы, ПоляТаблицы);
	КонецЕсли;
	
	Исключения = Новый Структура(ИменаИсключений);
	Для Каждого Поле Из ПоляТаблицы Цикл
		Если Исключения.Свойство(Поле.Имя) Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого ТипДанных Из ТипыДанных Цикл
			Если Поле.ТипЗначения.СодержитТип(ТипДанных) И Неопределено = ИменаПолей.Найти(Поле.Имя) Тогда
				ИменаПолей.Добавить(Поле.Имя);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
    Возврат ИменаПолей;
КонецФункции

Процедура ЗаменитьЗначения(Данные, ИменаПолей, Замены, Заменено = Ложь)
	Для Каждого ИмяПоля Из ИменаПолей Цикл
		НовоеЗначение = НовоеЗначение(Данные[ИмяПоля], Замены);
		Если НовоеЗначение <> Данные[ИмяПоля] Тогда;
			Заменено = Истина;
			Данные[ИмяПоля] = НовоеЗначение;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Функция НовоеЗначение(СтароеЗначение, Замены)
	Для Каждого Замена Из Замены Цикл
		Если СтароеЗначение = Замена.Замещаемое Тогда
			Возврат Замена.Заменитель;
		КонецЕсли;
	КонецЦикла;
	Возврат СтароеЗначение;
КонецФункции

Процедура ЗаписатьДанные(Данные, Принудительно = Ложь)
	Если Данные.Модифицированность() Или Принудительно Тогда
		Данные.ОбменДанными.Загрузка = Истина;
		Данные.Записать();
	КонецЕсли;
КонецПроцедуры

Функция ОтборыРегистраСведений(МетаданныеРегистра, Запись)
	Отборы = Новый Структура;
	Если МетаданныеРегистра.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		Отборы.Вставить("Период", Запись.Период);
	КонецЕсли;
	Для Каждого Измерение Из МетаданныеРегистра.Измерения Цикл
		Отборы.Вставить(Измерение.Имя, Запись[Измерение.Имя]);
	КонецЦикла;
	Возврат Отборы;
КонецФункции

Функция НаборЗаписей(МенеджерРегистра, Отборы)
	Набор = МенеджерРегистра.СоздатьНаборЗаписей();
	Для Каждого Отбор Из Отборы Цикл
		Набор.Отбор[Отбор.Ключ].Установить(Отбор.Значение);
	КонецЦикла;
	Набор.Прочитать();
	Возврат Набор;
КонецФункции

Функция ЭтоСсылочныйОбъектМетаданных(ОбъектМетаданных)
	Возврат Метаданные.Справочники.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Документы.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Перечисления.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Задачи.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных);
КонецФункции

#КонецОбласти

#Область ОтладочныеМетоды

// Показать произвольную выборку данных в отладчике
// Пример:
//	ОбщегоНазначенияУТ.ЗапросВыполнитьВыгрузить("выбрать * из Справочник.Валюты где Валюты.Код = &Код", Новый Структура("Код", "810"))
//
Функция ЗапросВыполнитьВыгрузить(ТекстЗапроса, ПараметрыЗапроса = Неопределено, МенеджерВременныхТаблиц = Неопределено) Экспорт
	
	Запрос = Новый Запрос(ТекстЗапроса);
	
	Если МенеджерВременныхТаблиц <> Неопределено Тогда
		Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПараметрыЗапроса) Тогда
		Для Каждого Параметр Из ПараметрыЗапроса Цикл
			Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

// Показать временную таблицу из менеджера временных таблиц.
// Используется для просмотра временных таблиц в отладчике.
// Пример вызова функции:
//	ОбщегоНазначенияУТ.ПоказатьВременнуюТаблицу(Запрос, "ТаблицаТоваров")
//
Функция ПоказатьВременнуюТаблицу(МенеджерВременныхТаблицИлиЗапрос, ИмяВременнойТаблицы) Экспорт
	
	ЗакрытьМенеджерВременныхТаблиц = Ложь;
	
	Если ТипЗнч(МенеджерВременныхТаблицИлиЗапрос) = Тип("Запрос") Тогда
		Если МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц = Неопределено Тогда
			МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
			ЗакрытьМенеджерВременныхТаблиц = Истина;
			МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц; 
		Иначе
			МенеджерВременныхТаблиц = МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц;
		КонецЕсли;
		Попытка
			МенеджерВременныхТаблицИлиЗапрос.Выполнить();
		Исключение
			// Ничего не делаем.
		КонецПопытки;
	Иначе
		МенеджерВременныхТаблиц = МенеджерВременныхТаблицИлиЗапрос;
	КонецЕсли; 
	
	ДанныеТаблицы = ЗапросВыполнитьВыгрузить("ВЫБРАТЬ * ИЗ " + ИмяВременнойТаблицы,, МенеджерВременныхТаблиц);
	
	Если ЗакрытьМенеджерВременныхТаблиц Тогда
		МенеджерВременныхТаблиц.Закрыть();
		МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц = Неопределено;
	КонецЕсли; 
	
	Возврат ДанныеТаблицы;
	
КонецФункции

// Преобразует таблицу значений в табличный документ и сохраняет его в файл.
// Примеры вызова функции:
// 	ОбщегоНазначенияУТ.СохранитьТаблицуЗначенийВФайл(Таблица, "c:\temp\таблица.mxl")
// 	ОбщегоНазначенияУТ.СохранитьТаблицуЗначенийВФайл(ОбщегоНазначенияУТ.ПоказатьВременнуюТаблицу(МВТ, "Таблица"), "c:\temp\таблица.mxl")
//
// Параметры:
//	Таблица - ТаблицаЗначений - произвольная таблица значений
//	ПолноеИмяФайла - Строка - полное имя сохраняемого файла, с расширением
//
// Возвращаемое значение:
//	Строка - текст сообщения об ошибке или пустая строка, если запись выполнена успешно.
//
Функция СохранитьТаблицуЗначенийВФайл(Таблица, ПолноеИмяФайла) Экспорт
	
	ВыгрузкаТаблицы = Новый ТабличныйДокумент; // преобразованная в mxl таблица значений
	
	НомерСтроки  = 1;
	НомерКолонки = 0;
	
	// Сформируем шапку табличного документа - выведем имена колонок таблицы значений
	Для Каждого ТекКолонка Из Таблица.Колонки Цикл
		
		НомерКолонки = НомерКолонки + 1;
		
		Область = ВыгрузкаТаблицы.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
		Область.Текст 		 = ТекКолонка.Имя;
		Область.Шрифт 		 = Новый Шрифт(Область.Шрифт,,, Истина); 
		Область.ГраницаСнизу = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
		
	КонецЦикла;
	
	// Выведем строки таблицы значений
	Для Каждого ТекСтр Из Таблица Цикл
		
		НомерСтроки = НомерСтроки + 1;
		НомерКолонки = 0;
		
		Для Каждого ТекКолонка Из Таблица.Колонки Цикл
			
			НомерКолонки = НомерКолонки + 1;
			
			Область = ВыгрузкаТаблицы.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
			Область.Текст = ТекСтр[ТекКолонка.Имя];
			
		КонецЦикла;
		
	КонецЦикла;
	
	ВыгрузкаТаблицы.ФиксацияСверху = 1;
	ВыгрузкаТаблицы.ФиксацияСлева  = 1;
	
	// Сохраним табличный документ в файл
	ТекстОшибки = "";
	Попытка
		ВыгрузкаТаблицы.Записать(ПолноеИмяФайла);
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат ТекстОшибки;
	
КонецФункции

#КонецОбласти

#Область СистемныеОпределяютПоведениеКонфигурации

// Проверяет соблюдение условий открытия базовой версии конфигурации в режиме Предприятие.
//
// Возвращаемое значение:
// 	- если текущая версия конфигурации не является базовой, то возвращается значение Истина.
//  - если текущая версия конфигурации является базовой, то возвращается значение Истина
//	  в случае, если ИБ развернута в файловом варианте и запускается в однопользовательском режиме.
//
Функция ВозможенЗапускБазовойВерсии() Экспорт
	
	Если НЕ СтандартныеПодсистемыСервер.ЭтоБазоваяВерсияКонфигурации() Тогда
		Возврат Истина; // ОК: это не базовая версия
	КонецЕсли;
	
	Если НЕ ОбщегоНазначения.ИнформационнаяБазаФайловая(СтрокаСоединенияИнформационнойБазы()) Тогда
		Возврат Ложь; // не файловая ИБ
	КонецЕсли;
	
	СеансыИнформационнойБазы = ПолучитьСеансыИнформационнойБазы();
	НомерТекущегоСеанса		 = НомерСеансаИнформационнойБазы();
	ЗапрещенныеПриложения	 = ",1CV8,1CV8C,WebClient,WSConnection,COMConnection,";
	
	Для Каждого СеансИБ Из СеансыИнформационнойБазы Цикл
		
		Если СеансИБ.НомерСеанса = НомерТекущегоСеанса Тогда
			Продолжить;
		ИначеЕсли СтрНайти(ЗапрещенныеПриложения, "," + СеансИБ.ИмяПриложения + ",") > 0 Тогда
			Возврат Ложь; // открыты другие сеансы платформы
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина; // ОК: это файловая ИБ в однопользовательском режиме
	
КонецФункции

#КонецОбласти

#Область Версионирование

// Возвращает признак использования версионирования для указанного объекта метаданных.
//
// Параметры:
//  ПолноеИмяОбъекта - Строка - полный путь к объекту метаданных. Например, "Справочник.Номенклатура".
//
// Возвращаемое значение:
//  Булево
//
Функция ИспользоватьВерсионированиеОбъекта(ПолноеИмяОбъекта) Экспорт
	
	Возврат ПолучитьФункциональнуюОпцию("ИспользоватьВерсионированиеОбъекта",
		Новый Структура("ТипВерсионируемогоОбъекта", ПолноеИмяОбъекта));
		
КонецФункции	

// Включает версионирования для указанного объекта метаданных.
//
// Параметры:
//  ПолноеИмяОбъекта - Строка - полный путь к объекту метаданных. Например, "Справочник.Номенклатура".
//	ВариантВерсионирования - Строка - имя значения перечисления ВариантыВерсионированияОбъектов.
//
// Возвращаемое значение:
//  Булево - Истина, если для указанного объекта было включено версионирование
//
Функция ВключитьВерсионированиеОбъекта(ПолноеИмяОбъекта, ВариантВерсионирования = "ВерсионироватьПриЗаписи") Экспорт
	
	ВерсионированиеВключено = Ложь;
	
	ПеречислениеВариантВерсионирования = Перечисления.ВариантыВерсионированияОбъектов[ВариантВерсионирования];
	
	Если НЕ ИспользоватьВерсионированиеОбъекта(ПолноеИмяОбъекта) Тогда
		
		ВерсионированиеОбъектов.ЗаписатьНастройкуВерсионированияПоОбъекту(ПолноеИмяОбъекта, ПеречислениеВариантВерсионирования);
		ВерсионированиеВключено = Истина;
		
	КонецЕсли;
	
	Возврат ВерсионированиеВключено;
	
КонецФункции

// Включает версионирования для указанных объектов метаданных.
//
// Параметры:
//	Объекты - Соответствие
//  	Ключ 	 - Строка - полный путь к объекту метаданных. Например, "Справочник.Номенклатура".
//		Значение - Строка - имя значения перечисления ВариантыВерсионированияОбъектов.
//
// Возвращаемое значение:
//  Булево - Истина, если хотя бы для одного из указанных объектов было включено версионирование
//
Функция ВключитьВерсионированиеОбъектов(Объекты) Экспорт
	
	ВерсионированиеВключено = Ложь;
	
	Для Каждого КлючИЗначение Из Объекты Цикл
		ВерсионированиеВключено =
			ВключитьВерсионированиеОбъекта(КлючИЗначение.Ключ, КлючИЗначение.Значение)
			ИЛИ ВерсионированиеВключено;
	КонецЦикла;
	
	Возврат ВерсионированиеВключено;
	
КонецФункции

#КонецОбласти

#Область Константы

// Возвращает состав набор констант.
//
// Параметры:
//	Набор - КонстантыНабор
//
// Возвращаемое значение:
//  Структура
//		Ключ - имя константы из набора
//
Функция ПолучитьСтруктуруНабораКонстант(Набор) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого МетаКонстанта Из Метаданные.Константы Цикл
		Если ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Набор, МетаКонстанта.Имя) Тогда
			Результат.Вставить(МетаКонстанта.Имя);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область Перечисления

// Получает список выбора для указанного перечисления.
//
// Параметры:
//	ИмяПеречисления 	- Строка - имя перечисления как оно задано в конфигураторе.
//	ДанныеВыбора 		- Список значений - сформированный список выбора перечисления.
//	Параметры 			- Структура - подробнее см. ОбработкаПолученияДанныхВыбора
//	ИсключаемыеЗначения - Массив - значения перечисления, не включаемые в список выбора.
//
Процедура ПолучитьСписокВыбораПеречисления(ИмяПеречисления, ДанныеВыбора, Параметры, ИсключаемыеЗначения) Экспорт
	
	ДанныеВыбора = Новый СписокЗначений; // результат
	
	Запрос = Новый Запрос;
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ЗначенияПеречисления.Ссылка КАК Ссылка,
	|	ПРЕДСТАВЛЕНИЕ(ЗначенияПеречисления.Ссылка) КАК Представление
	|ИЗ
	|	Перечисление.%ИмяПеречисления% КАК ЗначенияПеречисления
	|ГДЕ
	|	НЕ ЗначенияПеречисления.Ссылка В (&ИсключаемыеЗначения)
	|	//%ТекстОтборПоПараметрам%
	|
	|УПОРЯДОЧИТЬ ПО
	|	ЗначенияПеречисления.Порядок";
	
	Запрос.УстановитьПараметр("ИсключаемыеЗначения", ИсключаемыеЗначения);
	
	Если Параметры.Отбор.Свойство("Ссылка") Тогда
		
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "//%ТекстОтборПоПараметрам%", "И ЗначенияПеречисления.Ссылка В (&ОтборПоСсылке)");
		
		Запрос.УстановитьПараметр("ОтборПоСсылке", Параметры.Отбор.Ссылка);
		
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(ТекстЗапроса, "%ИмяПеречисления%", ИмяПеречисления);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если НЕ ЗначениеЗаполнено(Параметры.СтрокаПоиска)
		 ИЛИ СтрНайти(НРег(Выборка.Представление), НРег(Параметры.СтрокаПоиска)) = 1 Тогда
			ДанныеВыбора.Добавить(Выборка.Ссылка);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область КонтактнаяИнформация

// Актуализирует значения полей КИ из ее представления.
//
//  Параметры:
//		АдресПредставление - представление КИ
//		АдресЗначенияПолей - служебная информация, значения полей КИ
//		ТипКИ			   - тип контактной информации (Перечисления.ТипыКонтактнойИнформации)
//
Процедура ЗаполнитьЗначенияПолейКИПоПредставлению(Представление, ЗначенияПолей, ТипКИ = Неопределено) Экспорт
	
	Если ТипКИ = Неопределено Тогда
		ТипКИ = Перечисления.ТипыКонтактнойИнформации.Адрес;
	КонецЕсли;
	
	Если УправлениеКонтактнойИнформацией.ПредставлениеКонтактнойИнформации(ЗначенияПолей) = Представление Тогда
		Возврат;
	КонецЕсли;
	
	// Сохраним комментарий из старых значений полей.
	Комментарий = СокрЛП(УправлениеКонтактнойИнформацией.КомментарийКонтактнойИнформации(ЗначенияПолей));
	
	// Сформируем значения полей КИ по представлению.
	ЗначенияПолей = УправлениеКонтактнойИнформациейСлужебныйВызовСервера.КонтактнаяИнформацияXMLПоПредставлению(Представление,	ТипКИ);
	
	Если ЗначениеЗаполнено(Комментарий) Тогда
		// Вернем комментарий обратно.
		УправлениеКонтактнойИнформацией.УстановитьКомментарийКонтактнойИнформации(ЗначенияПолей, Комментарий);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ДополнительныеРеквизитыИСведения

// Возвращает наборы доп. реквизитов и сведений, доступных при данных настройках конфигурации.
//
// Возвращаемое значение:
//	Массив, элементы - СправочникСсылка.НаборыДополнительныхРеквизитовИСведений
//
Функция ДоступныеДопРеквизитыИСведения() Экспорт
	
	ДоступныеСвойства = Новый Массив;
	
	СвязиСвойствИФО = ОбщегоНазначенияУТПовтИсп.СвязиДопРеквизитовИФункциональныхОпций();
	
	Для Каждого КлючИЗначение Из СвязиСвойствИФО Цикл
		
		Если НЕ ЗначениеЗаполнено(КлючИЗначение.Значение) Тогда
			
			// Этот набор доп. свойств не зависит от ФО
			ДоступныеСвойства.Добавить(КлючИЗначение.Ключ);
			
		Иначе
			
			РодительскиеФО = Новый Структура(КлючИЗначение.Значение);
			
			Для Каждого ТекущаяФО Из РодительскиеФО Цикл
				Если ПолучитьФункциональнуюОпцию(ТекущаяФО.Ключ) Тогда
					// Включена хотя бы одна ФО, от которой зависит этот набор доп. свойств
					ДоступныеСвойства.Добавить(КлючИЗначение.Ключ);
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ДоступныеСвойства;
	
КонецФункции

#КонецОбласти

#Область Подсистемы

// Добавляет подсистему в коллекцию.
//
// Параметры:
//	Коллекция - Массив или СписокЗначений - коллекция, куда добавляется подсистема из метаданных
//	ИмяПодсистемы - Строка - имя подсистемы
//		подчиненные подсистемы разделяются ".",	служебные слова "Подсистема" или "Подсистемы" указывать не нужно
//	Представление - Строка - представление подсистемы (для списка значений)
//
Процедура ДобавитьПодсистемуВКоллекцию(Коллекция, ИмяПодсистемы, Представление = "") Экспорт
	
	Подсистема = ПодсистемаПоИмени(ИмяПодсистемы);
	Если Подсистема = Неопределено Тогда
		Возврат; // нет такой подсистемы в метаданных
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Представление) Тогда
		Коллекция.Добавить(Подсистема, Представление);
	Иначе
		Коллекция.Добавить(Подсистема);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает метаданные подсистемы по ее имени.
//
// Параметры:
//	ИмяПодсистемы - Строка - имя подсистемы
//		подчиненные подсистемы разделяются ".",	служебные слова "Подсистема" или "Подсистемы" указывать не нужно
//
// Возвращаемое значение:
//	Объект метаданных - метаданные подсистемы или Неопределено, если подсистемы с таким именем не существует
//
Функция ПодсистемаПоИмени(ИмяПодсистемы) Экспорт
	
	ПолноеИмяПодсистемы = Сред(СтрЗаменить("." + ИмяПодсистемы, ".", ".Подсистема."), 2);;
	
	Возврат Метаданные.НайтиПоПолномуИмени(ПолноеИмяПодсистемы);
	
КонецФункции

#КонецОбласти

#Область Последовательности

// Получает границы последовательности.
//
// Параметры:
//	ИмяПоследовательности - Строка - Имя последовательности границы которой необходимо получить
//
// Возвращаемое значение:
//	ТаблицаЗначений - текущие границы заданной последовательности по всем разрезам
//
Функция ПолучитьГраницыПоследовательности(ИмяПоследовательности) Экспорт
	
	мтдПоследовательность = Метаданные.Последовательности[ИмяПоследовательности];
	Разрезы = "";
	Для Каждого Измерение Из мтдПоследовательность.Измерения Цикл
		Разрезы = ?(ПустаяСтрока(Разрезы),"",",") + Разрезы + Измерение.Имя;
	КонецЦикла;
	
	Возврат Последовательности[ИмяПоследовательности].ПолучитьГраницы(Разрезы);
	
КонецФункции

// Устанавливает границы последовательности.
//
// Параметры:
//	ИмяПоследовательности - Строка - Имя последовательности границы которой необходимо установить
//	НовыеГраницы - ТаблицаЗначений - таблица содержащая границы последовательности
//                 структура таблицы должна совпадать со структурой таблицы возвращаемой методом ПолучитьГраницы() менеджера последовательности
//
Процедура УстановитьГраницыПоследовательности(ИмяПоследовательности, НовыеГраницы) Экспорт
	
	Разрезы = Новый Структура;
	Для Каждого Колонка Из НовыеГраницы.Колонки Цикл
		Если Колонка.Имя <> "Граница" Тогда
			Разрезы.Вставить(Колонка.Имя);
		КонецЕсли;
	КонецЦикла;
	
	УстановитьПривилегированныйРежим(Истина);
	Последовательность = Последовательности[ИмяПоследовательности];
	Для Каждого Граница Из НовыеГраницы Цикл
		ЗаполнитьЗначенияСвойств(Разрезы, Граница);
		Последовательность.УстановитьГраницу(Граница.Граница, Разрезы);
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область РегистрыСведений

// Возвращает результат запроса к регистрам сведений, в которых есть записи по указанным объектам метаданных.
// 
// Параметры:
//	ОбъектыМетаданных - Массив с элементами типа ОбъектМетаданных
//	РазмерПорцииВыборки - Число - количество записей в результате запроса
//
// Возвращаемое значение:
//		РезультатЗапроса
//		подробнее см. ОбщегоНазначенияУТПовтИсп.ТекстЗапросаКРегистрамСведенийПоМетаданнымИзмерений
//
Функция ВыбратьЗаписиРегистровСведенийПоМетаданнымИзмерений(ОбъектыМетаданных, РазмерПорцииВыборки = 0) Экспорт
	
	ИменаОбъектовМетаданных = "";
	
	Если ТипЗнч(ОбъектыМетаданных) = Тип("Массив") Тогда
		Для Каждого ОбъектМетаданных Из ОбъектыМетаданных Цикл
			ИменаОбъектовМетаданных = ИменаОбъектовМетаданных
				+ ?(ИменаОбъектовМетаданных = "", "", ",") + ОбъектМетаданных.ПолноеИмя();
		КонецЦикла;
	Иначе
		ИменаОбъектовМетаданных = ОбъектыМетаданных.ПолноеИмя();
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = ОбщегоНазначенияУТПовтИсп.ТекстЗапросаКРегистрамСведенийПоМетаданнымИзмерений(
		ИменаОбъектовМетаданных,
		РазмерПорцииВыборки);
		
	РезультатЗапроса = Запрос.Выполнить();
	
	Возврат РезультатЗапроса;
	
КонецФункции

// Возвращает информацию о регистрах сведений, в которых есть записи по указанным метаданным.
// 
Функция РегистрыСведенийПоМетаданнымИзмерений(ОбъектыМетаданных) Экспорт
	
	ИменаОбъектовМетаданных = "";
	
	Если ТипЗнч(ОбъектыМетаданных) = Тип("Массив") Тогда
		Для Каждого ОбъектМетаданных Из ОбъектыМетаданных Цикл
			ИменаОбъектовМетаданных = ИменаОбъектовМетаданных
				+ ?(ИменаОбъектовМетаданных = "", "", ",") + ОбъектМетаданных.ПолноеИмя();
		КонецЦикла;
	Иначе
		ИменаОбъектовМетаданных = ОбъектыМетаданных.ПолноеИмя();
	КонецЕсли;
	
	Возврат ОбщегоНазначенияУТПовтИсп.РегистрыСведенийПоМетаданнымИзмерений(ИменаОбъектовМетаданных);
	
КонецФункции

#КонецОбласти

#Область Прочее

Процедура ОбработатьВложенныеПоля(ЭлементыФормы, ЭлементФормы, МассивЭлементов, Структура, ПоляИсключения)
	
	ТипЗнчЭлементФормы = ТипЗнч(ЭлементФормы);
	
	Если ТипЗнчЭлементФормы = Тип("ТаблицаФормы")
		ИЛИ ТипЗнчЭлементФормы = Тип("ГруппаФормы") Тогда
		Если ТипЗнчЭлементФормы = Тип("ТаблицаФормы") Тогда
			ИмяЭлемента = ЭлементФормы.Имя;
			Структура.Вставить(ИмяЭлемента, Новый Массив);
			ОбработатьПоляТаблицыФормы(ЭлементыФормы, ЭлементФормы, Структура[ИмяЭлемента], ПоляИсключения);
		КонецЕсли;
		Для Каждого Элемент Из ЭлементФормы.ПодчиненныеЭлементы Цикл
			Имя = Элемент.Имя;
			ПодчиненныйЭлемент = ЭлементыФормы[Имя];
			ТипЗнчПодчиненныйЭлемент = ТипЗнч(ПодчиненныйЭлемент);
			Если ТипЗнчПодчиненныйЭлемент = Тип("ПолеФормы") Тогда
				Если МассивЭлементов.Найти(Имя) <> Неопределено
					Или ПоляИсключения.Найти(Имя) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				МассивЭлементов.Добавить(Имя);
			ИначеЕсли ТипЗнчПодчиненныйЭлемент = Тип("ГруппаФормы") Тогда
				ОбработатьВложенныеПоля(ЭлементыФормы, ПодчиненныйЭлемент, МассивЭлементов, Структура, ПоляИсключения);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбработатьПоляТаблицыФормы(ЭлементыФормы, ЭлементФормы, МассивЭлементов, ПоляИсключения)
	
	ТипЗнчЭлементФормы = ТипЗнч(ЭлементФормы);
	
	Если ТипЗнчЭлементФормы = Тип("ТаблицаФормы")
		ИЛИ ТипЗнчЭлементФормы = Тип("ГруппаФормы") Тогда
		Для Каждого Элемент Из ЭлементФормы.ПодчиненныеЭлементы Цикл
			ПодчиненныйЭлемент = ЭлементыФормы[Элемент.Имя];
			ТипЗнчПодчиненныйЭлемент = ТипЗнч(ПодчиненныйЭлемент);
			Если ТипЗнчПодчиненныйЭлемент = Тип("ПолеФормы") Тогда
				Если МассивЭлементов.Найти(Элемент.Имя) <> Неопределено
					Или ПоляИсключения.Найти(Элемент.Имя) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				МассивЭлементов.Добавить(Элемент.Имя);
			ИначеЕсли ТипЗнчПодчиненныйЭлемент = Тип("ГруппаФормы") Тогда
				ОбработатьПоляТаблицыФормы(ЭлементыФормы, ПодчиненныйЭлемент, МассивЭлементов, ПоляИсключения);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Функция возвращает идентификатор конфигурации.
// Длина идентификатора не должна превышать 8 символов.
//
Функция ИДКонфигурации() Экспорт
	
	Возврат "BASУТ3" + ?(СтандартныеПодсистемыСервер.ЭтоБазоваяВерсияКонфигурации(), "Базовая", ""); // в конфигурации BAS УТ
	
КонецФункции


// Процедура выполняет проведение документа по указанному объекту метаданных:
// регистру накопления, регистру сведений или последовательности.
// Параметры;
//	ДопСвойства - Структура - Структура, содержащая доп. свойства документа.
//	ИмяСвойства - Строка - Имя таблицы содержащей в себе набор записей регистра.
//	Регистр - РегистрНакопленияМенеджер, РегистрСведенийМенеджер, ПоследовательностиМенеджер - Объект метаданных, по которому
//				выполняется запись.
// Регистратор - ДокументСсылка - Ссылка на документ
// УстанавливатьАктивность - Булево - Признак, отвечающий за установку активности у записываемых записей
// ДопСвойстваТаблицы - Структура - Структура, содержащая доп. свойства объекта метаданных.
//
// Пример:
// ДопСвойства = Новый Структура("ЭтоНовый, РежимЗаписи", Ложь, РежимЗаписиДокумента.Проведение);
// ДополнитьДвижения(ДопСвойства, "ТаблицаСебестоимостьТоваров", РегистрыНакопления.СебестоимостьТоваров, СсылкаНаДокумент);
Процедура ДополнитьДвижения(ДопСвойства, ИмяТаблицы, Регистр, Регистратор, УстанавливатьАктивность = Истина, ДопСвойстваТаблицы = Неопределено) Экспорт
	
	Отказ = Ложь;
		
	ПроведениеСервер.ИнициализироватьДополнительныеСвойстваДляПроведения(Регистратор, ДопСвойства, РежимПроведенияДокумента.Неоперативный);
		Документы[ДопСвойства.ДляПроведения.МетаданныеДокумента.Имя].ИнициализироватьДанныеДокумента(Регистратор, ДопСвойства);
		
	Если ДопСвойства.ТаблицыДляДвижений.Свойство(ИмяТаблицы) Тогда
		ЗаписатьДвиженияВБазу(Регистр, ДопСвойства.ТаблицыДляДвижений[ИмяТаблицы], Регистратор,,УстанавливатьАктивность, ДопСвойстваТаблицы);
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаписатьДвиженияВБазу(МенеджерДвижений, Таблица, Ссылка, ЗаполнятьЦиклом = Ложь, УстановитьАктивность, ДопСвойства)
	Набор = МенеджерДвижений.СоздатьНаборЗаписей();
	Набор.Отбор.Регистратор.Установить(Ссылка);
	Набор.Прочитать();
	Если ДопСвойства <> Неопределено Тогда
		Для Каждого Свойство ИЗ ДопСвойства Цикл
			Набор.ДополнительныеСвойства.Вставить(Свойство.Ключ, Свойство.Значение);
		КонецЦикла;
	КонецЕсли;
	Если Набор.Количество() > 0 Или Таблица.Количество() > 0 Тогда
		Если ЗаполнятьЦиклом Тогда
			Для Каждого Строка Из Таблица Цикл
				Запись = Набор.Добавить();
				ЗаполнитьЗначенияСвойств(Запись, Строка);
			КонецЦикла;
		Иначе
			Набор.Загрузить(Таблица);
		КонецЕсли;
		Если УстановитьАктивность Тогда
			Набор.УстановитьАктивность(Истина);
		КонецЕсли;
		Попытка
			Набор.Записать();
		Исключение
			ЗаписьЖурналаРегистрации(ОбновлениеИнформационнойБазы.СобытиеЖурналаРегистрации(),
				УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
	КонецЕсли;
КонецПроцедуры

// Возращает массив уникальных значений из колонки таблицы
//
// Параметры:
//  Таблица    - ТаблицаЗначений, ДанныеФормыКоллекция, ТабличнаяЧасть - таблица, из которой необходимо выбрать данные
//  ИмяКолонки - Строка - имя колонки таблицы значений, из которой необходимо выбрать значения
// 
// Возвращаемое значение:
//  Массив - набор уникальных значений
//
Функция ПолучитьМассивУникальныхЗначенийКолонкиТаблицы(Таблица, ИмяКолонки) Экспорт
	
	Если ТипЗнч(Таблица) = Тип("ТаблицаЗначений") Тогда
		ТаблицаКопия = Таблица.Скопировать(, ИмяКолонки);
	Иначе
		ТаблицаКопия = Таблица.Выгрузить(, ИмяКолонки);
	КонецЕсли;
	
	ТаблицаКопия.Свернуть(ИмяКолонки);
	
	Возврат ТаблицаКопия.ВыгрузитьКолонку(0);
	
КонецФункции

// Возвращает таблицу значений с данными дерева значений
//
// Параметры:
//  ДеревоДанных - ДеревоЗначений, ДанныеФормыДерево - дерево с данными
//  Уровень		 - Число - уровень дерева, на котором расположены искомые данные (нумерация с 0). Если не передано, то 
//						   будут возвращенные данные со всех последних уровней веток.
//
// Возвращаемое значение:
//  ТаблицаЗначений - содержит данные дерева
//
Функция ДанныеДерева(ДеревоДанных, Уровень = Неопределено) Экспорт
	
	ТаблицаВозврата = Новый ТаблицаЗначений;
	Для Каждого Колонка Из ДеревоДанных.Колонки Цикл
		ТаблицаВозврата.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
	КонецЦикла;
	
	Если ТипЗнч(ДеревоДанных) = Тип("ДеревоЗначений") Тогда
		СтрокиДерева = ДеревоДанных.Строки;
	ИначеЕсли ТипЗнч(ДеревоДанных) = Тип("ДанныеФормыДерево") Тогда
		СтрокиДерева = ДеревоДанных.ПолучитьЭлементы();
	Иначе
		ВызватьИсключение НСтр("ru='Передан некорректный тип аргумента';uk='Переданий некоректний тип аргументу'");
	КонецЕсли;
	
	ЗаполнитьТаблицуРекурсивно(ТаблицаВозврата, СтрокиДерева, Уровень, 0);
	
	Возврат ТаблицаВозврата;

КонецФункции

Процедура ЗаполнитьТаблицуРекурсивно(ТаблицаЗначений, СтрокиДерева, ИскомыйУровень, ТекущийУровень)
	
	Для Каждого Строка Из СтрокиДерева Цикл

		Если ТипЗнч(СтрокиДерева) = Тип("КоллекцияСтрокДереваЗначений") Тогда
			Подстроки = Строка.Строки;
		ИначеЕсли ТипЗнч(СтрокиДерева) = Тип("ДанныеФормыКоллекцияЭлементовДерева") Тогда
			Подстроки = Строка.ПолучитьЭлементы();
		КонецЕсли;
		
		Если ИскомыйУровень = ТекущийУровень 
			Или (ИскомыйУровень = Неопределено И Подстроки.Количество() = 0) Тогда
			НовСтрока = ТаблицаЗначений.Добавить();
			ЗаполнитьЗначенияСвойств(НовСтрока, Строка);
		Иначе
			ЗаполнитьТаблицуРекурсивно(ТаблицаЗначений, Подстроки, ИскомыйУровень, ТекущийУровень + 1);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Добавляет на форму списка условное оформление поля Дата
//
//  Параметры:
//   Форма - УправляемаяФорма – форма документа.
//   ИмяСписка - Строка – имя динамического списка.
//   ИмяПоляДата - Строка - условное оформление формы.
//
Процедура УстановитьУсловноеОформлениеПоляДата(Форма, ИмяСписка = "Список", ИмяПоляДата = "Дата") Экспорт
	
	УсловноеОформлениеКД = Форма.УсловноеОформление;
	УсловноеОформлениеКД.ИдентификаторПользовательскойНастройки = "ОсновноеОформление";
	
	// Представление даты сегодня "09:46"
	ЭлементУсловногоОформления = УсловноеОформлениеКД.Элементы.Добавить();
	ЭлементУсловногоОформления.Использование = Истина;
	
	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяПоляДата);
	
	ПредставлениеЭлемента = НСтр("ru='Представление даты сегодня: ""09:46""';uk='Представлення дати сьогодні: ""09:46""'");
	ЭлементУсловногоОформления.Представление = ПредставлениеЭлемента;
	
	ЭлементОтбораДанных = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбораДанных.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяСписка + "." + "Дата");
	ЭлементОтбораДанных.ВидСравнения = ВидСравненияКомпоновкиДанных.БольшеИлиРавно;
	ЭлементОтбораДанных.ПравоеЗначение = Новый СтандартнаяДатаНачала(ВариантСтандартнойДатыНачала.НачалоЭтогоДня);
	ЭлементОтбораДанных.Использование = Истина;
	
	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("Формат", "ДФ=ЧЧ:мм");
	
	// Отображение даты отличной от сегодня "10.06.2012"
	ЭлементУсловногоОформления = УсловноеОформлениеКД.Элементы.Добавить();
	ЭлементУсловногоОформления.Использование = Истина;
	
	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяПоляДата);
	
	ПредставлениеЭлемента = НСтр("ru='Представление даты до начала этого дня: ""10.06.2012""';uk='Представлення до дати початку цього дня: ""10.06.2012""'");
	ЭлементУсловногоОформления.Представление = ПредставлениеЭлемента;
	
	ЭлементОтбораДанных = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбораДанных.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяСписка + "." + "Дата");
	ЭлементОтбораДанных.ВидСравнения = ВидСравненияКомпоновкиДанных.Меньше;
	ЭлементОтбораДанных.ПравоеЗначение = Новый СтандартнаяДатаНачала(ВариантСтандартнойДатыНачала.НачалоЭтогоДня);
	ЭлементОтбораДанных.Использование = Истина;
	
	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("Формат", "ДЛФ=D");
	
	// Отображение даты отличной от сегодня "10.06.2012"
	ЭлементУсловногоОформления = УсловноеОформлениеКД.Элементы.Добавить();
	ЭлементУсловногоОформления.Использование = Истина;
	
	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяПоляДата);
	
	ПредставлениеЭлемента = НСтр("ru='Представление даты после начала этого дня: ""10.06.2012""';uk='Представлення дати після початку цього дня: ""10.06.2012""'");
	ЭлементУсловногоОформления.Представление = ПредставлениеЭлемента;
	
	ЭлементОтбораДанных = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбораДанных.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяСписка + "." + "Дата");
	ЭлементОтбораДанных.ВидСравнения = ВидСравненияКомпоновкиДанных.БольшеИлиРавно;
	ЭлементОтбораДанных.ПравоеЗначение = Новый СтандартнаяДатаНачала(ВариантСтандартнойДатыНачала.НачалоСледующегоДня);
	ЭлементОтбораДанных.Использование = Истина;
	
	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("Формат", "ДЛФ=D");
	
КонецПроцедуры

// Возвращает свойства последнего задания.
//
// Параметры:
//  Задание - РегламентноеЗадание, Строка, ОчередьЗаданийОбластейДанных - строка уникального идентификатора РегламентногоЗадания.
//
// Возвращаемое значение:
//  СтруктураСвойств.
//
Функция ПолучитьСостояниеПоследнегоЗадания(Задание) Экспорт
	
	СвойстваЗадания = Новый Структура("ДатаНачала, ДатаЗавершения, Состояние");
	
	Если ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
		
		ЭлементСправочника = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Задание.Идентификатор, "ДатаНачалаПоследнегоЗапуска, ДатаЗавершенияПоследнегоЗапуска, СостояниеЗадания");
		
		СвойстваЗадания.ДатаНачала = ЭлементСправочника.ДатаНачалаПоследнегоЗапуска;
		СвойстваЗадания.ДатаЗавершения = ЭлементСправочника.ДатаЗавершенияПоследнегоЗапуска;
		СвойстваЗадания.Состояние = ЭлементСправочника.СостояниеЗадания;
		
	Иначе
		
		СвойстваРегЗадания = РегламентныеЗаданияСлужебный.ПолучитьСвойстваПоследнегоФоновогоЗаданияВыполненияРегламентногоЗадания(Задание);
		
		Если СвойстваРегЗадания <> Неопределено Тогда
			
			СвойстваЗадания.ДатаНачала = СвойстваРегЗадания.Начало;
			СвойстваЗадания.ДатаЗавершения = СвойстваРегЗадания.Конец;
			СвойстваЗадания.Состояние = СвойстваРегЗадания.Состояние;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СвойстваЗадания;
	
КонецФункции

Функция СвойствоМетаданных(МетаданныеОбъекта, ЧастиИмени, Индекс = 0)
	
	Имя = ЧастиИмени[Индекс];
	Свойство = МетаданныеОбъекта[Имя];
	Если Индекс < ЧастиИмени.ВГраница() Тогда
		Свойство = СвойствоМетаданных(Свойство, ЧастиИмени, Индекс+1);
	КонецЕсли;
	Возврат Свойство;
	
КонецФункции

// Проверяет, что переданный тип - примитивный
//
// Параметры:
//  ПроверяемыйТип	 - Тип - 
// 
// Возвращаемое значение:
//  Ьулево 
//
Функция ЭтоПримитивныйТип(ПроверяемыйТип) Экспорт
	
	Если ПроверяемыйТип = Тип("Неопределено")
		Или ПроверяемыйТип = Тип("Булево")
		Или ПроверяемыйТип = Тип("Строка")
		Или ПроверяемыйТип = Тип("Число")
		Или ПроверяемыйТип = Тип("Дата")
		Или ПроверяемыйТип = Тип("УникальныйИдентификатор") Тогда
		
		Возврат Истина;
		
	Иначе
		
		Возврат Ложь;
		
	КонецЕсли;
	
КонецФункции

Функция РазделительЗапросовПакета(ИмяЗапроса = Неопределено) Экспорт
	
	Текст = Символы.ПС +
	";
	|
	|//#ИмяЗапроса#//////////////////////////////////////////////////////////////////
	|";
	
	Если ЗначениеЗаполнено(ИмяЗапроса) Тогда
		Возврат СтрЗаменить(Текст, "#ИмяЗапроса#", ИмяЗапроса);
	Иначе
		Возврат СтрЗаменить(Текст, "#ИмяЗапроса#", "////////");
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#КонецОбласти
