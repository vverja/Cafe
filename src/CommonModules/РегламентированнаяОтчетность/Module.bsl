// ПРОЦЕДУРЫ И ФУНКЦИИ, ВЫПОЛНЯЕМЫЕ НА СЕРВЕРЕ
//


Функция ПолучитьПризнакУчетаПоВсемОрганизациям() Экспорт
	
	Возврат Истина;
	
КонецФункции


Функция ПолучитьЗначениеПоУмолчанию(Настройка, Пользователь = Неопределено) Экспорт

	Если ВРег(Настройка) = ВРег("ОсновнаяОрганизация") Тогда
		ПустоеЗначение = Справочники.Организации.ПустаяСсылка();
	ИначеЕсли ВРег(Настройка) = ВРег("ОсновноеПодразделениеОрганизации") Тогда
		ПустоеЗначение = Справочники.ПодразделенияОрганизаций.ПустаяСсылка();		
	Иначе	
		Возврат Неопределено;
	КонецЕсли;
	
	ЗначениеНастройки = ХранилищеОбщихНастроек.Загрузить(ВРег(Настройка),,, Пользователь);
	
	Возврат ?(ЗначениеНастройки = Неопределено, ПустоеЗначение, ЗначениеНастройки);
	  
КонецФункции


Функция ПолучитьОрганизациюПоУмолчанию() Экспорт
	
	Организация = ПолучитьЗначениеПоУмолчанию("ОсновнаяОрганизация");
	
	Если НЕ Организация.Пустая() Тогда
		Если Организация.ПолучитьОбъект() = Неопределено Тогда
			// Нарушена ссылочная целостность информационной базы.
			Организация = Справочники.Организации.ПустаяСсылка();
		КонецЕсли;
	КонецЕсли;
	
	Возврат Организация;
		
КонецФункции


Процедура УдалитьЭлементОтбораСписка(Список, ИмяПоля) Экспорт
	
	ЭлементыОтбора = Список.КомпоновщикНастроек.Настройки.Отбор.Элементы;

	ПолеКомпоновки = Новый ПолеКомпоновкиДанных(ИмяПоля);
	Для Каждого ЭлементОтбора Из ЭлементыОтбора Цикл
		Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбораКомпоновкиДанных")
			И ЭлементОтбора.ЛевоеЗначение = ПолеКомпоновки Тогда
			ЭлементыОтбора.Удалить(ЭлементОтбора);
		КонецЕсли;
	КонецЦикла;
	
	Список.КомпоновщикНастроек.Настройки.Отбор.ИдентификаторПользовательскойНастройки = Строка(Новый УникальныйИдентификатор);
	
КонецПроцедуры


Процедура УстановитьЭлементОтбораСписка(Список, ИмяПоля, ПравоеЗначение, ВидСравнения = Неопределено) Экспорт
	
	ЭлементОтбора = Список.КомпоновщикНастроек.Настройки.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));

	ЭлементОтбора.ЛевоеЗначение    = Новый ПолеКомпоновкиДанных(ИмяПоля);
	ЭлементОтбора.ВидСравнения     = ?(ВидСравнения = Неопределено, ВидСравненияКомпоновкиДанных.Равно, ВидСравнения);
	ЭлементОтбора.Использование    = Истина;
	ЭлементОтбора.ПравоеЗначение   = ПравоеЗначение;
	ЭлементОтбора.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	
	Список.КомпоновщикНастроек.Настройки.Отбор.ИдентификаторПользовательскойНастройки = Строка(Новый УникальныйИдентификатор);
			
КонецПроцедуры


Процедура ИзменитьЭлементОтбораСписка(Список, ИмяПоля, ПравоеЗначение = Неопределено, Установить = Ложь, ВидСравнения = Неопределено) Экспорт
	
	УдалитьЭлементОтбораСписка(Список, ИмяПоля);
	
	Если Установить Тогда
		УстановитьЭлементОтбораСписка(Список, ИмяПоля, ПравоеЗначение, ВидСравнения);
	КонецЕсли;
	
КонецПроцедуры

 
Функция ПолучитьИнформациюДляПеремещенияОМетаданных(Ссылка) Экспорт
	
	Информация = Новый Структура;
	
	МетаданныеОбъекта = Ссылка.Метаданные();
	МетаданныеРеквизита = МетаданныеОбъекта.СтандартныеРеквизиты.Код;
	
	Информация.Вставить("ПолноеИмя",    МетаданныеОбъекта.ПолноеИмя());
	
	ЭтоСправочник = Метаданные.Справочники.Содержит(МетаданныеОбъекта);
	ЭтоПВХ        = Метаданные.ПланыВидовХарактеристик.Содержит(МетаданныеОбъекта);
	
	Если ЭтоСправочник ИЛИ ЭтоПВХ Тогда
		
		Информация.Вставить("ЕстьГруппы",
					МетаданныеОбъекта.Иерархический И 
							?(ЭтоПВХ, Истина, МетаданныеОбъекта.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов));
		
		Информация.Вставить("ДляГрупп",     Истина);
		Информация.Вставить("ДляЭлементов", Истина);
		Информация.Вставить("ЕстьРодитель",  МетаданныеОбъекта.Иерархический);
		Информация.Вставить("ГруппыСверху", ?(НЕ Информация.ЕстьРодитель, Ложь, МетаданныеОбъекта.ГруппыСверху));
		Информация.Вставить("ЕстьВладелец", ?(ЭтоПВХ, Ложь, (МетаданныеОбъекта.Владельцы.Количество() <> 0)));
		
	Иначе
		
		Информация.Вставить("ЕстьГруппы",   Ложь);
		Информация.Вставить("ДляГрупп",     Ложь);
		Информация.Вставить("ДляЭлементов", Истина);
		Информация.Вставить("ЕстьРодитель", Ложь);
		Информация.Вставить("ЕстьВладелец", Ложь);
		Информация.Вставить("ГруппыСверху", Ложь);
		
	КонецЕсли;
	
	Возврат Информация;
	
КонецФункции


// Определяет, с учетом кэша, является ли отчет, заданный строкой-идентификатором Наим, внешним.
// Параметры:
//		Наим - строка-идентификатор отчета.
// ВозвращаемоеЗначение:
//		Булево - Истина, если для заданной строки-идентификатора используется внешний отчет.
//				 Ложь - в противном случае.
//				 Неопределено - информация по отчету, заданному строкой-идентификатором 
//  			 отсутствует в справочнике РегламентированныеОтчеты.
Функция ЭтоВнешнийОтчет(Наим) Экспорт
	
	НайденныйЭлемент = ПолучитьРеглОтчетПоУмолчанию(Наим);
	Если НайденныйЭлемент.Пустая() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(НайденныйЭлемент);
	
КонецФункции


// Возвращает признак использования внешнего отчета с учетом кэша (реквизит ВнешнийОтчетИспользовать), 
// для переданного в качестве параметра элемента справочника РегламентированныеОтчеты.
// Параметры:
//		РеглОтч - ссылка на элемент справочника РегламентированныеОтчеты.
// Возвращаемое значение:
//		Признак использования внешнего отчета для заданного элемента справочника с учетом кэша.
Функция ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(РеглОтч, НеЗапоминатьВКэше = Ложь)
	Перем ПараметрыОтчета;
	
	ПараметрыОтчета = ПараметрыСеанса.ПараметрыВнешнихРегламентированныхОтчетов.Получить(РеглОтч.ИсточникОтчета);
	Если ПараметрыОтчета <> Неопределено Тогда
		Возврат ПараметрыОтчета.Признак;
	Иначе
		Если НеЗапоминатьВКэше Тогда
			Возврат РеглОтч.ВнешнийОтчетИспользовать;
		Иначе                                                                                           
			Возврат ЗакэшироватьСтруктуруОписанияОтчета(РеглОтч).Признак;
		КонецЕсли;
	КонецЕсли;
	
КонецФункции


Функция ЗакэшироватьСтруктуруОписанияОтчета(РеглОтч)
	
	Запрос = Новый Запрос("ВЫБРАТЬ РАЗРЕШЕННЫЕ
	                      |	РегламентированныеОтчеты.ВнешнийОтчетИспользовать,
	                      |	РегламентированныеОтчеты.ИсточникОтчета,
	                      |	ВЫБОР
	                      |		КОГДА РегламентированныеОтчеты.ВнешнийОтчетИспользовать
	                      |			ТОГДА РегламентированныеОтчеты.ВнешнийОтчетХранилище
	                      |		ИНАЧЕ NULL
	                      |	КОНЕЦ КАК ВнешнийОтчетХранилище
	                      |ИЗ
	                      |	Справочник.РегламентированныеОтчеты КАК РегламентированныеОтчеты
	                      |ГДЕ
	                      |	РегламентированныеОтчеты.Ссылка = &Ссылка");
	Запрос.УстановитьПараметр("Ссылка", РеглОтч);
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат Неопределено;
	КонецЕсли;
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	ПризнакИспользованияВнешнегоОтчета = Выборка.ВнешнийОтчетИспользовать;
	СтруктураПараметровОтчета = Новый Структура("Признак", ПризнакИспользованияВнешнегоОтчета);
	Если ПризнакИспользованияВнешнегоОтчета Тогда
		#Если НЕ ТолстыйКлиентОбычноеПриложение Тогда
			АдресВоВременномХранилище = ПоместитьВоВременноеХранилище(Выборка.ВнешнийОтчетХранилище.Получить());
			ИмяОбработки = ВнешниеОтчеты.Подключить(АдресВоВременномХранилище, , Ложь);
		#Иначе	
			ИмяВременогоФайла = ПолучитьИмяВременногоФайла();
			Выборка.ВнешнийОтчетХранилище.Получить().Записать(ИмяВременогоФайла);
			ИмяОбработки = ИмяВременогоФайла;
		#КонецЕсли 
		СтруктураПараметровОтчета.Вставить("Файл", ИмяОбработки);
	КонецЕсли;
	
	СоответствиеПараметров = Новый Соответствие;
	Если ТипЗнч(ПараметрыСеанса.ПараметрыВнешнихРегламентированныхОтчетов) = Тип("ФиксированноеСоответствие") И ПараметрыСеанса.ПараметрыВнешнихРегламентированныхОтчетов.Количество() > 0 Тогда 
		Для Каждого ЭлементСоответствия ИЗ ПараметрыСеанса.ПараметрыВнешнихРегламентированныхОтчетов Цикл 
			СоответствиеПараметров.Вставить(ЭлементСоответствия.Ключ, ЭлементСоответствия.Значение);
		КонецЦикла;
	КонецЕсли;
	
	СоответствиеПараметров[Выборка.ИсточникОтчета] = Новый ФиксированнаяСтруктура(СтруктураПараметровОтчета);
	ПараметрыСеанса.ПараметрыВнешнихРегламентированныхОтчетов = Новый ФиксированноеСоответствие(СоответствиеПараметров);
	
	Возврат СтруктураПараметровОтчета;
	
КонецФункции


// Функция возвращает гарантированно один и тот же элемент справочника РегламентированныеОтчеты
// по значению реквизита для всех пользователей, режимах работы платформы и т.п.
// 
// Параметры:
//		Наим - строка-идентификатор регламентированного отчета.
// Возвращаемое значение:
// 		СправочникСсылка.РегламентированныеОтчеты - найденный элемент справочника
//
Функция ПолучитьРеглОтчетПоУмолчанию(Наим, МассивДублей = Неопределено) Экспорт
	
	МассивДублей = Новый Массив;
	
	// Элемент по умолчанияю - с минимальным значением ссылки (не помеченный на удаление)
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	РегламентированныеОтчеты.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.РегламентированныеОтчеты КАК РегламентированныеОтчеты
	|ГДЕ
	|	РегламентированныеОтчеты.ИсточникОтчета = &ИсточникОтчета
	|	И РегламентированныеОтчеты.ЭтоГруппа = ЛОЖЬ
	|	И РегламентированныеОтчеты.ПометкаУдаления = ЛОЖЬ
	|
	|УПОРЯДОЧИТЬ ПО
	|	Ссылка";
    Запрос.УстановитьПараметр("ИсточникОтчета", Наим);
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат Справочники.РегламентированныеОтчеты.ПустаяСсылка();
	КонецЕсли;
	
	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();
	ОсновнойОтчет = Выборка.Ссылка;
	
	Пока Выборка.Следующий() Цикл
		МассивДублей.Добавить(Выборка.Ссылка)	
	КонецЦикла;
	
	Возврат ОсновнойОтчет;
	
КонецФункции


Функция РеглОтчеты(Наим, НеЗапоминатьВКэше = Ложь) Экспорт
		
	Перем ВременныйФайл;
	Перем ПараметрыОтчета;
	
	МассивДублей = Неопределено;
	НайденныйЭлемент = ПолучитьРеглОтчетПоУмолчанию(Наим, МассивДублей);
	Если МассивДублей.Количество() > 0 Тогда
		Сообщить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='В справочнике ""Регламентированные отчеты"" обнаружены дубли для объекта ""%1""';uk='У довіднику ""Регламентовані звіти"" виявлені дублі для об''єкта ""%1""'"), СокрП(Наим)), СтатусСообщения.Информация);
		Для каждого СсылкаДубль Из МассивДублей Цикл
			Попытка
				ОбъектДубль = СсылкаДубль.ПолучитьОбъект();
				ОбъектДубль.ПометкаУдаления = Истина;
				ОбъектДубль.Записать();
				Сообщить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Элемент ""%1"" (%2) помечен на удаление';uk='Елемент ""%1"" (%2) позначений на вилучення'"), Строка(СсылкаДубль), Строка(СсылкаДубль.Код)), СтатусСообщения.БезСтатуса);
			Исключение
			 	// При невозможности записать ничего не предпринимаем 
			КонецПопытки;
		КонецЦикла;
	КонецЕсли;
	
	Если НайденныйЭлемент = Справочники.РегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если НЕ ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(НайденныйЭлемент, НеЗапоминатьВКэше) ИЛИ НайденныйЭлемент.ВнешнийОтчетХранилище = Неопределено Тогда // используется внутренний отчет
		Если Метаданные.Документы.Найти(Наим) <> Неопределено Тогда
			Возврат Документы[Наим];
		ИначеЕсли Метаданные.Отчеты.Найти(Наим) <> Неопределено Тогда
			Возврат Отчеты[Наим];
		Иначе
			
			Сообщение = Новый СообщениеПользователю;

			Сообщение.Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Не найден отчет %1!';uk='Не знайдений звіт %1!'"), СокрП(Наим));

			Сообщение.Сообщить();
			
			Возврат Неопределено;
			
		КонецЕсли; 
	Иначе // используется внешний отчет
		Попытка
			ВременныйФайл = ФайлОтчетаСУчетомКэша(НайденныйЭлемент);
			ВнешнийОтчет = ВнешниеОтчеты.Создать(ВременныйФайл);
			Попытка
				ВнешнийОтчет.мПолноеИмяФайлаВнешнейОбработки = ВременныйФайл;
			Исключение
			КонецПопытки;
			Возврат ВнешнийОтчет;
		Исключение
			
			Сообщение = Новый СообщениеПользователю;

			Сообщение.Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Не удалось запустить внешний отчет %1!';uk='Не вдалося запустити зовнішній звіт %1!'"), СокрП(Наим));

			Сообщение.Сообщить();
			
			Возврат Неопределено;
			
		Конецпопытки;
	КонецЕсли;
	Возврат Неопределено;
	
КонецФункции


Функция ФайлОтчетаСУчетомКэша(РеглОтч, НеЗапоминатьВКэше = Ложь)
	
	Перем ПараметрыОтчета;
	
	ПараметрыОтчета = ПараметрыСеанса.ПараметрыВнешнихРегламентированныхОтчетов.Получить(РеглОтч.ИсточникОтчета);
	Если ПараметрыОтчета <> Неопределено Тогда
		Возврат ПараметрыОтчета.Файл;
	Иначе
		Если НеЗапоминатьВКэше Тогда
			АдресВоВременномХранилище = ПоместитьВоВременноеХранилище(РеглОтч.ВнешнийОтчетХранилище.Получить());
			ВременныйФайл = ВнешниеОтчеты.Подключить(АдресВоВременномХранилище, , Ложь);
			Возврат ВременныйФайл;
		Иначе
			Возврат ЗакэшироватьСтруктуруОписанияОтчета(РеглОтч).Файл;
		КонецЕсли;
	КонецЕсли;
	
КонецФункции


Функция ФормаРеглОтчета(Наим, ВыбраннаяФорма = Неопределено, Владелец = Неопределено, КлючУникальности = Неопределено) Экспорт
	Перем ВременныйФайл;
	
	НайденныйЭлемент = ПолучитьРеглОтчетПоУмолчанию(Наим);
	Если НайденныйЭлемент = Справочники.РегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если НЕ ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(НайденныйЭлемент) ИЛИ НайденныйЭлемент.ВнешнийОтчетХранилище = Неопределено Тогда // используется внутренний отчет
		Если Метаданные.Документы.Найти(Наим) <> Неопределено Тогда
			Возврат Документы[Наим];
		ИначеЕсли Метаданные.Отчеты.Найти(Наим) <> Неопределено Тогда
			Возврат Отчеты[Наим];
		Иначе
						
			Сообщение = Новый СообщениеПользователю;

			Сообщение.Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Не найден отчет %1!';uk='Не знайдений звіт %1!'"), СокрП(Наим));

			Сообщение.Сообщить();
		
			Возврат Неопределено;
			
		КонецЕсли; 
	Иначе // используется внешний отчет
		
		Попытка
			
			ВременныйФайл = ФайлОтчетаСУчетомКэша(НайденныйЭлемент);
			ВнешнийОтчет = ВнешниеОтчеты.Создать(ВременныйФайл, Ложь);
			Попытка
				ВнешнийОтчет.мПолноеИмяФайлаВнешнейОбработки = ВременныйФайл;
			Исключение
			КонецПопытки;
			
			//ДобавитьНадписьВнешнийОтчет(ВнешнийОтчет);
			Возврат ВнешнийОтчет;
			
		Исключение
			
			//ТекстОшибки = ОписаниеОшибки();
			Сообщение = Новый СообщениеПользователю;
			Сообщение.Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Не найден отчет %1!';uk='Не знайдений звіт %1!'"), СокрП(Наим));
			Сообщение.Сообщить();
			
			Возврат Неопределено;
			
		Конецпопытки;
	КонецЕсли;
	Возврат Неопределено;
	
КонецФункции


Функция ЗаблокироватьДокумент(мСохраненныйДок)
	
	Попытка
		мСохраненныйДок.Заблокировать();
		Возврат Истина;
	Исключение
				
		Сообщение = Новый СообщениеПользователю;

		Сообщение.Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Не удается заблокировать документ!%1Возможно, документ уже открыт другим пользователем!';uk='Не вдається заблокувати документ!%1Можливо, документ вже відкритий іншим користувачем!'"), Символы.ПС);

		Сообщение.Сообщить();
        
		Возврат Ложь;
		
	Конецпопытки;
			
КонецФункции


Функция ПродолжитьПриНесоответствииВерсийФорм(Знач ВерсияФормы, Знач мВерсияФормы) Экспорт
	
	ПервыйСлеш = Найти(ВерсияФормы, "/");
	ВторойСлеш = Найти(Лев(ВерсияФормы, ПервыйСлеш - 1) + " " + Сред(ВерсияФормы, ПервыйСлеш + 1), "/");
	Если ПервыйСлеш = Неопределено ИЛИ ВторойСлеш = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	ГодВерсияФормы = Сред(ВерсияФормы, ВторойСлеш + 1);
	МесяцВерсияФормы = Сред(ВерсияФормы, ПервыйСлеш + 1, ВторойСлеш - ПервыйСлеш - 1);
	ДеньВерсияФормы = Сред(ВерсияФормы, 1, ПервыйСлеш - 1);
	Если СтрДлина(ГодВерсияФормы) = 2 Тогда
		ГодВерсияФормы = "20" + ГодВерсияФормы;
	КонецЕсли;
	Если СтрДлина(МесяцВерсияФормы) = 1 Тогда
		МесяцВерсияФормы = "0" + МесяцВерсияФормы;
	КонецЕсли;
	Если СтрДлина(ДеньВерсияФормы) = 1 Тогда
		ДеньВерсияФормы = "0" + ДеньВерсияФормы;
	КонецЕсли;
	ДатаВерсияФормы = Дата(ГодВерсияФормы + МесяцВерсияФормы + ДеньВерсияФормы);
	
	ПервыйСлеш = Найти(мВерсияФормы, "/");
	ВторойСлеш = Найти(Лев(мВерсияФормы, ПервыйСлеш - 1) + " " + Сред(мВерсияФормы, ПервыйСлеш + 1), "/");
	Если ПервыйСлеш = Неопределено ИЛИ ВторойСлеш = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	ГодмВерсияФормы = Сред(мВерсияФормы, ВторойСлеш + 1);
	МесяцмВерсияФормы = Сред(мВерсияФормы, ПервыйСлеш + 1, ВторойСлеш - ПервыйСлеш - 1);
	ДеньмВерсияФормы = Сред(мВерсияФормы, 1, ПервыйСлеш - 1);
	Если СтрДлина(ГодмВерсияФормы) = 2 Тогда
		ГодмВерсияФормы = "20" + ГодмВерсияФормы;
	КонецЕсли;
	Если СтрДлина(МесяцмВерсияФормы) = 1 Тогда
		МесяцмВерсияФормы = "0" + МесяцмВерсияФормы;
	КонецЕсли;
	Если СтрДлина(ДеньмВерсияФормы) = 1 Тогда
		ДеньмВерсияФормы = "0" + ДеньмВерсияФормы;
	КонецЕсли;
	ДатамВерсияФормы = Дата(ГодмВерсияФормы + МесяцмВерсияФормы + ДеньмВерсияФормы);
	
	Если ДатамВерсияФормы < ДатаВерсияФормы Тогда
						
		Сообщение = Новый СообщениеПользователю;
		
		Сообщение.Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Сохраненные данные не могут быть открыты текущей версией отчета!%1Версия отчета - от %2Версия данных - от %3';uk='Збережені дані не можуть бути відкриті поточною версією звіту!%1Версия звіту - від %2Версия даних - від %3'"), Символы.ПС, Формат(ДатамВерсияФормы, "ДЛФ=DD; ДП='Пустая дата'") + Символы.ПС, Формат(ДатаВерсияФормы,  "ДЛФ=DD; ДП='Пустая дата'"));
		
		Сообщение.Сообщить();
                  						
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат Истина;
КонецФункции


Функция ПолучитьВариантЗаполненияПоказателяРегОтчета(МакетСоставаПоказателей, Ном) Экспорт
	
	стрВариантЗаполнения = СокрЛП(МакетСоставаПоказателей.Область(Ном, 6).Текст);
	ПозицияРазделителя = Найти(стрВариантЗаполнения, ",");

	// Указан общий вариант заполнения показателя, для всех конфигураций.
	Если ПозицияРазделителя = 0 Тогда
		Возврат стрВариантЗаполнения;
	КонецЕсли;
	
	Если ПозицияРазделителя > 0 Тогда
		
		ВариантыЗаполнения = СтрЗаменить(стрВариантЗаполнения, ",", Символы.ПС);
		ВариантыЗаполнения = СтрЗаменить(ВариантыЗаполнения, " ", "");
		
		ВариантЗаполнения = СтрПолучитьСтроку(ВариантыЗаполнения, 1);
		Возврат ВариантЗаполнения;

	КонецЕсли;

КонецФункции


Функция ПолучитьДокФизЛица(ФизЛицо, ДатаЗначения) Экспорт
	
	Удостоверения = РегистрыСведений.ДокументыФизическихЛиц.СрезПоследних(ДатаЗначения, Новый Структура("ФизЛицо", ФизЛицо));

	Если Удостоверения.Количество() > 0 Тогда
		Возврат Удостоверения[0];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции


Функция ПолучитьФИОФизЛица(ФизЛицо, НаДату = Неопределено) Экспорт
	
	Результат = Новый Структура("Фамилия, Имя, Отчество", "", "", "");
	Если Метаданные.Справочники.Найти("ФизическиеЛица") = Неопределено Тогда
		ЗаполнитьЗначенияСвойств(Результат, ФизЛицо);
	Иначе
		ДанныеФЛ = РегистрыСведений.ФИОФизическихЛиц.СрезПоследних(?(ЗначениеЗаполнено(НаДату), НаДату, ТекущаяДатаСеанса()), Новый Структура("ФизическоеЛицо", ФизЛицо));
		Если ДанныеФЛ.Количество() > 0 Тогда
			ЗаполнитьЗначенияСвойств(Результат, ДанныеФЛ[0]);
		КонецЕсли;
	КонецЕсли;
	Возврат Результат;
	
КонецФункции


Функция ПриЗаписиРегламентированногоОтчетаНаСервере(Форма, Автосохранение = Ложь, мСохраненныйДок) Экспорт
		
	Форма.СтруктураРеквизитовФормы.мЗаписываетсяНовыйДокумент = (мСохраненныйДок = Неопределено ИЛИ Форма.СтруктураРеквизитовФормы.мСкопированаФорма <> Неопределено);
	
	Если мСохраненныйДок = Неопределено ИЛИ Форма.СтруктураРеквизитовФормы.мСкопированаФорма <> Неопределено Тогда
					
		// создаем новый документ вида РегламентированныйОтчет
					
		мСохраненныйДок = Документы.РегламентированныйОтчет.СоздатьДокумент();
		ЗаблокироватьДокумент(мСохраненныйДок);
		Форма.СтруктураРеквизитовФормы.мЗаписываетсяНовыйДокумент = Истина;
		мСохраненныйДок.Дата = Форма.СтруктураРеквизитовФормы.мДатаКонцаПериодаОтчета;
		мСохраненныйДок.УстановитьВремя();
		мСохраненныйДок.УстановитьНовыйНомер();
					
	КонецЕсли;

	Возврат Истина;
	
КонецФункции


Функция СуществуетДокументСАналогичнымиРеквизитами(Форма) Экспорт	
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("мСохраненныйДок", ?(Форма.СтруктураРеквизитовФормы.мСохраненныйДок = Неопределено, Неопределено, Форма.СтруктураРеквизитовФормы.мСохраненныйДок.Ссылка));
	//Запрос.УстановитьПараметр("ИсточникОтчета", Метаданные.Отчеты[Сред(Лев(Форма.ИмяФормы, Найти(Форма.ИмяФормы, ".Форма.") - 1), 7)].Имя);
	Запрос.УстановитьПараметр("ИсточникОтчета", Метаданные.Отчеты[Сред(Лев(СтрЗаменить(Форма.ИмяФормы, "Внешний", ""), Найти(СтрЗаменить(Форма.ИмяФормы, "Внешний", ""), ".Форма.") - 1), 7)].Имя);
	Запрос.УстановитьПараметр("Организация", Форма.СтруктураРеквизитовФормы.Организация);
	Запрос.УстановитьПараметр("ДатаНачалаНач", НачалоДня(Форма.СтруктураРеквизитовФормы.мДатаНачалаПериодаОтчета));
	Запрос.УстановитьПараметр("ДатаНачалаКон", КонецДня(Форма.СтруктураРеквизитовФормы.мДатаНачалаПериодаОтчета));
	Запрос.УстановитьПараметр("ДатаКонцаНач", НачалоДня(Форма.СтруктураРеквизитовФормы.мДатаКонцаПериодаОтчета));
	Запрос.УстановитьПараметр("ДатаКонцаКон", КонецДня(Форма.СтруктураРеквизитовФормы.мДатаКонцаПериодаОтчета));
	
	Запрос.Текст = "ВЫБРАТЬ
	               |	КОЛИЧЕСТВО(РегламентированныйОтчет.Ссылка)
	               |ИЗ
	               |	Документ.РегламентированныйОтчет КАК РегламентированныйОтчет
	               |ГДЕ
	               |	РегламентированныйОтчет.Ссылка <> &мСохраненныйДок
	               |	И РегламентированныйОтчет.ИсточникОтчета = &ИсточникОтчета
	               |	И РегламентированныйОтчет.Организация = &Организация
	               |	И РегламентированныйОтчет.ДатаНачала МЕЖДУ &ДатаНачалаНач И &ДатаНачалаКон
	               |	И РегламентированныйОтчет.ДатаОкончания МЕЖДУ &ДатаКонцаНач И &ДатаКонцаКон
				   |";
			   
	РезультатЗапроса = Запрос.Выполнить().Выгрузить();			   
	Если РезультатЗапроса.Количество() = 0 ИЛИ РезультатЗапроса.Получить(0).Получить(0) = 0 Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли;
	
КонецФункции


Процедура ОперацииПриВосстановленииРегламентированногоОтчета(Форма) Экспорт
	
	//Форма.СтруктураРеквизитовФормы.мВариант = Форма.СтруктураРеквизитовФормы.мСохраненныйДок.Вид;
	//Если Форма.СтруктураРеквизитовФормы.мВариант = Неопределено Тогда
	//	Форма.СтруктураРеквизитовФормы.мВариант = 0;
	//КонецЕсли;

	//Если Форма.СтруктураРеквизитовФормы.мВариант = 0 Тогда
	//	Если Форма.СтруктураРеквизитовФормы.Свойство("ВидДокумента") Тогда
	//		Форма.СтруктураРеквизитовФормы.ВидДокумента = 0;
	//	КонецЕсли;
	//Иначе
	//	Если Форма.СтруктураРеквизитовФормы.Свойство("ВидДокумента") Тогда
	//		Форма.СтруктураРеквизитовФормы.ВидДокумента = 1;
	//	КонецЕсли;
	//	Форма.НомерКорректировки = Форма.СтруктураРеквизитовФормы.мВариант;
	//КонецЕсли;

	Возврат;
	
КонецПроцедуры


Процедура ЗаполнитьСтрокуДаннымиИзТаблицы(ТаблицаРаздела, Строка1, СтрокаТаблицы, НомерНаФорме) Экспорт
	// Заполняем строку.
	Для каждого Колонка Из ТаблицаРаздела.Колонки Цикл
		КолонкаИмя = Колонка.Имя;
		НазвЯчейки = КолонкаИмя + "_" + НомерНаФорме;
		Если Строка1.Области[НазвЯчейки].СодержитЗначение = Истина Тогда
			Строка1.Области[НазвЯчейки].Значение = СтрокаТаблицы[КолонкаИмя];
		Иначе
			Строка1.Области[НазвЯчейки].Текст = СтрокаТаблицы[КолонкаИмя];
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры


Функция БылиИзмененыКлючевыеРеквизитыОтчета(Форма) Экспорт
	
	Попытка
		Вариант = Форма.СтруктураРеквизитовФормы.ВидДокумента*Форма.НомерКорректировки;
		мСохраненныйДок = Форма.СтруктураРеквизитовФормы.мСохраненныйДок;
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
	Если мСохраненныйДок = Неопределено ИЛИ Форма.СтруктураРеквизитовФормы.мСкопированаФорма <> Неопределено Тогда
		Возврат Истина;
	Иначе
		Возврат Вариант <> мСохраненныйДок.Вид;
	КонецЕсли;
	
КонецФункции


Функция ВерсияПрограммы() Экспорт
	
	Возврат СокрЛП(Метаданные.Версия);
	
КонецФункции

	
Функция НазваниеПрограммы() Экспорт
	
	Возврат РегламентированнаяОтчетностьПереопределяемый.КраткоеНазваниеПрограммы();
	
КонецФункции


Функция НазваниеИВерсияПрограммы() Экспорт
	
	Возврат Лев(НазваниеПрограммы() + " " + ВерсияПрограммы(), 40);
	
КонецФункции


Функция ВычислитьЗначениеПоКорню(Табл, Корень)
	
	Табл2 = Табл.Скопировать();
	ИтоговоеЗначение = "";
	
	Для Каждого Стр Из Табл2 Цикл
		
		Имя = Стр.Имя;
		Если Имя = Корень Тогда
			ИтоговоеЗначение = ИтоговоеЗначение + Стр.Знач;
		КонецЕсли;
		
	КонецЦикла;
	
	Если ((ВРЕГ(Лев(Корень, 4)) = "ДАТА") ИЛИ (СтрЧислоВхождений(Корень, "Дата") <> 0)) 
		И (((СтрДлина(ИтоговоеЗначение)=8) ИЛИ (СтрДлина(ИтоговоеЗначение)=6)) ИЛИ (ПустаяСтрока(ИтоговоеЗначение)))Тогда
		
		Если ПустаяСтрока(ИтоговоеЗначение) Тогда
			ИтоговоеЗначение = "00.00.0000";
		Иначе
			ИтоговоеЗначение = Лев(ИтоговоеЗначение, 2) + "." + Сред(ИтоговоеЗначение, 3, 2) + "." + Сред(ИтоговоеЗначение, 5);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ИтоговоеЗначение;
	
КонецФункции


Функция СкопированнаяСтруктура(Структура1) Экспорт
	
	Структура2 = Новый Структура;
	
	Для Каждого Зап из Структура1 Цикл
		Структура2.Вставить(Зап.Ключ, Зап.Значение);
	КонецЦикла;
	
	Возврат Структура2;
	
КонецФункции


Процедура СообщитьВТаблицуСообщений(Форма, Описание, Раздел, ИмяЯчейки = "", ФИО = "") Экспорт
	
	НовСтр = Форма.ТаблицаСообщений.Добавить();
	НовСтр.Раздел = Раздел;
	НовСтр.ИмяЯчейки = ИмяЯчейки;
	НовСтр.Описание = Описание;
	НовСтр.Страница = ФИО;
	
КонецПроцедуры


Функция СтрЗаменитьПробелы(ИсхСтрока) Экспорт
	
	ПромСтр=СокрЛП(ИсхСтрока); 
	
	Если ПустаяСтрока(ПромСтр) Тогда
		ПромСтр = ",,";
		
		Возврат ПромСтр;
	КонецЕсли;

	// сначала удаляем возможный недопустимый символ '.'
	ЧП = СтрЧислоВхождений(ПромСтр,".");
	Если ЧП>0 Тогда
		Для К=1 По ЧП Цикл
			РезСтр=СтрЗаменить(ПромСтр,"."," ");
			ПромСтр=РезСтр;
		КонецЦикла; 
	КонецЕсли;
	
	// Число разделительных пробелов
	ЧП=СтрЧислоВхождений(ПромСтр," ");
	Если ЧП>0 Тогда
		Для К=1 По ЧП Цикл
			РезСтр  = СтрЗаменить(ПромСтр," ",",");
			ПромСтр = РезСтр;
		КонецЦикла; 
	КонецЕсли;
	
	// проверяем соответствие формату представления
	КолЗап = СтрЧислоВхождений(ПромСтр,",");
	Если КолЗап < 2 Тогда
		// дополняем недостающими запятыми
		Для Ном=(КолЗап+1) По 2 Цикл
			ПромСтр=ПромСтр+",";
		КонецЦикла;
	ИначеЕсли КолЗап > 2 Тогда
		Пока СтрЧислоВхождений(ПромСтр, ",") <> 2 Цикл
			НайденПовтор = 0;
			
			ПозицияЗапятой = Найти(ПромСтр, ",");
			Если Сред(ПромСтр, ПозицияЗапятой + 1, 1) = "," Тогда
				НачПозиция	 = ПозицияЗапятой;
				НайденПовтор = 1;
			Иначе
				ПозицияЗапятой2 = Найти(Сред(ПромСтр, ПозицияЗапятой + 1), ",");
				Если Сред(ПромСтр, ПозицияЗапятой + ПозицияЗапятой2 + 1, 1) = "," Тогда
					НачПозиция	 = ПозицияЗапятой + ПозицияЗапятой2;
					НайденПовтор = 1;
				КонецЕсли;
			КонецЕсли;	
			
			Если НайденПовтор = 1 Тогда
				ПромСтр = Лев(ПромСтр, НачПозиция) + Сред(ПромСтр, НачПозиция + 2);
			Иначе
				Если Прав(ПромСтр, 1) = "," Тогда
					// лишние хвостовые пробелы удаляем
					ПромСтр = Лев(ПромСтр, СтрДлина(ПромСтр) - 1);
				Иначе
					// лишние запятые заменяем пробелами
					ПромСтр = Лев(ПромСтр, ПозицияЗапятой - 1) + " " + Сред(ПромСтр, ПозицияЗапятой + 1); 
				КонецЕсли;
			КонецЕсли;
				
		КонецЦикла;
	КонецЕсли;
		
	Возврат ВРег(ПромСтр);         
	
КонецФункции


Функция ПолучитьКоличествоПоказателей(Текст) Экспорт
    
	КоличествоПоказателей = 0;

	Для НомСтр = 1 По Текст.КоличествоСтрок() Цикл

		ТекСтр = СокрЛ(Текст.ПолучитьСтроку(Текст.КоличествоСтрок() - НомСтр + 1));

		Если Лев(ТекСтр, 11) = "КолПокФОтч:" Тогда
			Прервать;
		КонецЕсли;

		Если СтрДлина(ТекСтр)<14 Тогда
			Продолжить;
		КонецЕсли;

		Если (Сред(ТекСтр, 1, 1) = "П") и (Сред(ТекСтр, 14, 1) = ":") Тогда

			ЭтоПоказатель = Ложь;

			Для НСимв = 2 По 13 Цикл

				ТекСимв = Сред(ТекСтр, НСимв, 1);

				Если (ТекСимв = "0") или (ТекСимв = "1") ИЛИ (ТекСимв = "2") ИЛИ (ТекСимв = "3") ИЛИ (ТекСимв = "4")
					ИЛИ (ТекСимв = "5") ИЛИ (ТекСимв = "6") ИЛИ (ТекСимв = "7") ИЛИ (ТекСимв = "8") ИЛИ (ТекСимв = "9") Тогда

					ЭтоПоказатель = Истина;

				Иначе

					ЭтоПоказатель = Ложь;
					Прервать;

				КонецЕсли;

			КонецЦикла;

			Если ЭтоПоказатель Тогда
				КоличествоПоказателей = КоличествоПоказателей + 1;
			КонецЕсли;

		КонецЕсли;

	КонецЦикла;
    	
	Возврат Формат(КоличествоПоказателей, "ЧН=; ЧГ=0");

КонецФункции


Функция СобратьАдрес(Знач СтруктураАдрес) Экспорт

	Возврат ""+ СтруктураАдрес.Страна + "," + СтруктураАдрес.Индекс + ","+ СтруктураАдрес.Регион + ","
	+ СтруктураАдрес.Район  + "," + СтруктураАдрес.Город  + ","+ СтруктураАдрес.НаселенныйПункт + ","
	+ СтруктураАдрес.Улица  + "," + СтруктураАдрес.Дом    + ","+ СтруктураАдрес.Корпус + "," + СтруктураАдрес.Квартира

КонецФункции


Функция ЕстьРеквизитДокумента(ИмяРеквизита, МетаданныеДокумента) Экспорт

	Возврат НЕ (МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) = Неопределено);

КонецФункции


Процедура УдалитьНепроверяемыеРеквизитыИзМассива(МассивРеквизитов, МассивНепроверяемыхРеквизитов) Экспорт
	
	Для Каждого ЭлементМассива Из МассивНепроверяемыхРеквизитов Цикл
		
		// перед удалением реквизита из массива необходимо проверить, что он там есть
		// (не был удален ранее платформой или в коде).
		ПорядковыйНомер = МассивРеквизитов.Найти(ЭлементМассива);
		Если ПорядковыйНомер <> Неопределено Тогда
			МассивРеквизитов.Удалить(ПорядковыйНомер);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры


Процедура ВывестиНаПечатьЛистОбщая(ЗаголовокФормы, СтруктураПараметровЛиста, ТабличноеПоле, мПечатныеФормы) Экспорт
	Перем ИмяЛиста;           // имя выводимого на печать листа;
	Перем Ориентация;         // ориентация страницы;
	Перем ИмяТабличногоПоля;  // имя табличного поля, который выводится на печать;
	Перем ИмяОбластиТаблПоля; // имя области дабличного документа, выводимой на печать;
	Перем ВидПечати;          // строка, задающая способ печати
	Перем ЕстьДуплекс;		  // поддержка дуплексной печати принтером
	
	СтруктураПараметровЛиста.Свойство("НаименованиеЛиста",  ИмяЛиста);
	СтруктураПараметровЛиста.Свойство("ОриентацияЛиста",    Ориентация);
	СтруктураПараметровЛиста.Свойство("ВидПечати",          ВидПечати);
	СтруктураПараметровЛиста.Свойство("ИмяТабличногоПоля",  ИмяТабличногоПоля);
	СтруктураПараметровЛиста.Свойство("ИмяОбластиТаблПоля", ИмяОбластиТаблПоля);
	СтруктураПараметровЛиста.Свойство("ЕстьДуплекс", 		ЕстьДуплекс);

	ПечатнаяФорма = Новый ТабличныйДокумент();
	
	ПечатнаяФорма.ОтображатьЗаголовки = Ложь;
	ПечатнаяФорма.ОтображатьСетку     = Ложь;
	ПечатнаяФорма.ЧерноБелыйПросмотр  = Истина;
	ПечатнаяФорма.ЧерноБелаяПечать    = Истина;
	ПечатнаяФорма.Автомасштаб         = Истина;
	
	// приведем этот параметр к "норамльному виду"
	Если    Ориентация = ОриентацияСтраницы.Портрет
		ИЛИ Ориентация = ОриентацияСтраницы.Ландшафт Тогда
	    ПечатнаяФорма.ОриентацияСтраницы  =  Ориентация;
	Иначе	
		ПечатнаяФорма.ОриентацияСтраницы  = ?(ВРЕГ(Ориентация) = ВРЕГ("Портрет"), ОриентацияСтраницы.Портрет, ОриентацияСтраницы.Ландшафт);
	КонецЕсли;

	СтруктураПараметровЛиста.Вставить("ОриентацияЛиста", ПечатнаяФорма.ОриентацияСтраницы);
	
	Если ПустаяСтрока(ИмяОбластиТаблПоля) Тогда
		ОбластьПечати = ТабличноеПоле.ПолучитьОбласть();
	Иначе
		ОбластьПечати = ТабличноеПоле.ПолучитьОбласть(ИмяОбластиТаблПоля);
	КонецЕсли;
	
	ПечатнаяФорма.Вывести(ОбластьПечати);
	
	РазбитьПечатнуюФорму(ПечатнаяФорма, СтруктураПараметровЛиста, ИмяЛиста, мПечатныеФормы);
		
КонецПроцедуры


Процедура РазбитьПечатнуюФорму(ПечФорма, СтруктураПараметровЛиста, ИмяФормы = "", мПечатныеФормы)
	
	АвтоМасштаб = Неопределено;
	Если СтруктураПараметровЛиста.Свойство("АвтоМасштаб") Тогда
		АвтоМасштаб = СтруктураПараметровЛиста.АвтоМасштаб;	
	КонецЕсли;
	Если АвтоМасштаб = Неопределено Тогда
		АвтоМасштаб = Ложь;	
	КонецЕсли;
	
	МасштабПечати = Неопределено;
	Если СтруктураПараметровЛиста.Свойство("МасштабПечати") Тогда
		МасштабПечати = СтруктураПараметровЛиста.МасштабПечати;	
	КонецЕсли;
	Если МасштабПечати = Неопределено ИЛИ АвтоМасштаб = Истина Тогда
		МасштабПечати  = 100;	
	КонецЕсли;

	ЕстьДуплекс = Неопределено;
	Если СтруктураПараметровЛиста.Свойство("ЕстьДуплекс") Тогда
		ЕстьДуплекс = СтруктураПараметровЛиста.ЕстьДуплекс;	
	КонецЕсли;
	Если ЕстьДуплекс = Неопределено Тогда
		ЕстьДуплекс = Ложь;	
	КонецЕсли;
	
	ПустойТаблДок = Новый ТабличныйДокумент;
	ПустойТаблДок.АвтоМасштаб = АвтоМасштаб;
	ПустойТаблДок.МасштабПечати = МасштабПечати;
	ПустойТаблДок.ОриентацияСтраницы = СтруктураПараметровЛиста.ОриентацияЛиста;
	ПустойТаблДок.ЧерноБелаяПечать = Истина;
	ПустойТаблДок.ЧерноБелыйПросмотр = Истина;
	ПослВерх = 1;
	
	Если ЕстьДуплекс Тогда
		НовТаблДок = Новый ТабличныйДокумент();
	КонецЕсли;
	
	Сч = 0;
	Пока Сч < ПечФорма.ВысотаТаблицы Цикл
		 Сч = Сч + 1;
		 
		Если НЕ ПустойТаблДок.ПроверитьВывод(ПечФорма.ПолучитьОбласть(ПослВерх, 0, Сч, 0)) Тогда
			
			// проверим, не должна ли предпоследняя строка печататься вместе со текущей ("не влезшей") строкой.
			// если так, то "откатимся" вверх
			Пока ПослВерх < Сч-1 И ПечФорма.ПолучитьОбласть(Сч-1, , Сч-1, ).Область().ВместеСоСледующим Цикл
			  Сч = Сч - 1;
			КонецЦикла; 
			
			Если НЕ ЕстьДуплекс Тогда
				НовТаблДок = Новый ТабличныйДокумент();
			КонецЕсли;
			
			НовТаблДок.Вывести(ПечФорма.ПолучитьОбласть(ПослВерх, 0, Сч - 1, 0));
			НовТаблДок.АвтоМасштаб = АвтоМасштаб;
			НовТаблДок.МасштабПечати = МасштабПечати;
			НовТаблДок.ОриентацияСтраницы = СтруктураПараметровЛиста.ОриентацияЛиста;
			НовТаблДок.ЧерноБелаяПечать = Истина;
			НовТаблДок.ЧерноБелыйПросмотр = Истина;
			НовТаблДок.ОтображатьСетку = Ложь;
			НовТаблДок.ОтображатьЗаголовки = Ложь;
			
			Если НЕ ЕстьДуплекс Тогда
				мПечатныеФормы.Добавить(НовТаблДок, ИмяФормы);
			КонецЕсли;
			
			ПослВерх = Сч;
		КонецЕсли;
		
		Если ПечФорма.Область(Сч, 0, Сч, 0).КонецСтраницы Тогда
			
			Если НЕ ЕстьДуплекс Тогда
				НовТаблДок = Новый ТабличныйДокумент();
			КонецЕсли;
			
			НовТаблДок.Вывести(ПечФорма.ПолучитьОбласть(ПослВерх, 0, Сч, 0));
			НовТаблДок.АвтоМасштаб = АвтоМасштаб;
			НовТаблДок.МасштабПечати = МасштабПечати;
			НовТаблДок.ОриентацияСтраницы = СтруктураПараметровЛиста.ОриентацияЛиста;
			НовТаблДок.ЧерноБелаяПечать = Истина;
			НовТаблДок.ЧерноБелыйПросмотр = Истина;
			НовТаблДок.ОтображатьСетку = Ложь;
			НовТаблДок.ОтображатьЗаголовки = Ложь;
			Если НЕ ЕстьДуплекс Тогда
				мПечатныеФормы.Добавить(НовТаблДок, ИмяФормы);
			КонецЕсли;
			
			ПослВерх = Сч + 1;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если ПослВерх <= ПечФорма.ВысотаТаблицы Тогда
		
		Если НЕ ЕстьДуплекс Тогда
			НовТаблДок = Новый ТабличныйДокумент();
		КонецЕсли;
		
		НовТаблДок.Вывести(ПечФорма.ПолучитьОбласть(ПослВерх, 0, ПечФорма.ВысотаТаблицы, 0));
		НовТаблДок.АвтоМасштаб = АвтоМасштаб;
		НовТаблДок.МасштабПечати = МасштабПечати;
		НовТаблДок.ОриентацияСтраницы = СтруктураПараметровЛиста.ОриентацияЛиста;
		НовТаблДок.ЧерноБелаяПечать = Истина;
		НовТаблДок.ЧерноБелыйПросмотр = Истина;
		НовТаблДок.ОтображатьСетку = Ложь;
		НовТаблДок.ОтображатьЗаголовки = Ложь;
		
		Если НЕ ЕстьДуплекс Тогда
			мПечатныеФормы.Добавить(НовТаблДок, ИмяФормы);
		КонецЕсли;
		
	КонецЕсли;
	
	Если ЕстьДуплекс Тогда
		мПечатныеФормы.Добавить(НовТаблДок, ИмяФормы);
	КонецЕсли;
	
КонецПроцедуры


Функция ПечататьРаздел(Форма, СтрокаРаздела, ЧтоИскать = Неопределено) Экспорт
	Перем КлючФизЛица;
	
	Если ЧтоИскать <> Неопределено Тогда
		Возврат 1;
	КонецЕсли;
	
	// если в настройках взведен флаг печати, то добавляем раздел в список печатаемых и выходим
	Если СтрокаРаздела.ВыводНаПечать <> 0 Тогда
		Форма.СтруктураРеквизитовФормы.мПечатаемыеРазделы.Добавить(СтрокаРаздела.ИмяСтраницы);
		Возврат 1;
	КонецЕсли;
	
	Возврат 0;
	
КонецФункции


Процедура ПриЗакрытииРегламентированногоОтчета(Форма) Экспорт
		
	Если Форма.СтруктураРеквизитовФормы.мСохраненныйДок <> Неопределено И Форма.СтруктураРеквизитовФормы.мСохраненныйДок <> РегламентированнаяОтчетностьКлиентСервер.ПустоеЗначениеТипа(ТипЗнч(Форма.СтруктураРеквизитовФормы.мСохраненныйДок)) И Форма.СтруктураРеквизитовФормы.мСохраненныйДок.ПолучитьОбъект().Заблокирован() Тогда
		Форма.СтруктураРеквизитовФормы.мСохраненныйДок.ПолучитьОбъект().Разблокировать();
	КонецЕсли;
	
КонецПроцедуры


Процедура ПослеВставкиДополнительнойСтраницыНаСервере(Форма, ИмяВставляемойСтраницы, ПерейтиНаВставленныйЛист = Истина) Экспорт
	
	РегламентированнаяОтчетностьКлиентСервер.ПослеВставкиДополнительнойСтраницы(Форма, ИмяВставляемойСтраницы, ПерейтиНаВставленныйЛист);

КонецПроцедуры


Процедура УдалитьДополнительнуюСтраницуНаСервере(Форма, ИмяТекущейСтраницыПанели = Неопределено) Экспорт
	Перем ТаблицаСтраницРаздела;
        	
	Если Не Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяТекущейСтраницыПанели, ТаблицаСтраницРаздела) Тогда
		Возврат;
	КонецЕсли;

	ТаблицаСтраницРаздела = Форма[ТаблицаСтраницРаздела];
	
	// Если одна страница в разделе, то её удалять нельзя
	Если ТаблицаСтраницРаздела.Количество() = 1 Тогда
		Возврат;
	КонецЕсли;

	ИмяТекТабличногоПоля     = "ТабличныйДокумент";
	ТекТабличноеПоле         = Форма[ИмяТекТабличногоПоля];

	СтрТаблицаСтраницы = ТаблицаСтраницРаздела.НайтиСтроки(Новый Структура("АктивнаяСтраница", Истина));

	Если СтрТаблицаСтраницы.Количество() > 0 Тогда
		
		СтрТаблицаСтраницы = СтрТаблицаСтраницы[0];
		
		ИндексТекСтрока = ТаблицаСтраницРаздела.Индекс(СтрТаблицаСтраницы);
		ТаблицаСтраницРаздела.Удалить(СтрТаблицаСтраницы);
		
		// очищаем редактируемые ячейки удаляемой страницы
		Форма.ОчиститьТабличноеПолеНаСервере(ИмяТекущейСтраницыПанели);
				
		КолвоДопСтраниц = ТаблицаСтраницРаздела.Количество();

		Если КолвоДопСтраниц > 0 Тогда
			СтрТаблицаСтраницыЗамена = ТаблицаСтраницРаздела[Мин(ИндексТекСтрока, КолвоДопСтраниц - 1)];

			// Для страниц многостраничного раздела, содержащих многострочную часть,
			// восстанавливаем структуру дополнительных строк.
			//
			// Предварительно проверим, содержит ли страница многострочные части

			КолвоМногострочныхБлоков = РегламентированнаяОтчетностьКлиентСервер.ПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "МногострочностьВРазделе").Количество();
			
			СохранятьМногострКакТЗ = РегламентированнаяОтчетностьКлиентСервер.ПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "СохранятьМногострКакТЗ");

			Если КолвоМногострочныхБлоков > 0 Тогда
				
				ДанныеДопСтрокРаздела = СтрТаблицаСтраницыЗамена.ДанныеДопСтрок;
				
				Если (ТипЗнч(ДанныеДопСтрокРаздела) = Тип("СписокЗначений"))
					И (ДанныеДопСтрокРаздела.Количество() > 0)
					И (ДанныеДопСтрокРаздела[0].Представление = "ДанныеФормыКоллекцияТаблицаДопСтрокРаздела") Тогда
					
					ДанныеДопСтрокРаздела = ДанныеДопСтрокРаздела[0].Значение;
					
				Иначе
					
					ДанныеДопСтрокРаздела = Неопределено;
					
				КонецЕсли;
				
			Иначе
				ДанныеДопСтрокРаздела = Неопределено;
			КонецЕсли;

			Если ДанныеДопСтрокРаздела <> Неопределено Тогда

				Если (КолвоМногострочныхБлоков > 0) И (НЕ СохранятьМногострКакТЗ) Тогда

					Для Каждого ГруппаСтрок Из ДанныеДопСтрокРаздела Цикл
						ИмяГруппыДопСтрок = ГруппаСтрок.Ключ;
						ДанныеГруппыСтрок = ГруппаСтрок.Значение;
						
						ПромТаблицаГруппыСтрок = Форма["Хранилище" + ИмяГруппыДопСтрок].Добавить().Таблица;
						
						КопироватьДанныеФормы(ДанныеГруппыСтрок, ПромТаблицаГруппыСтрок);

						// Заменяем таблицу значений с данными текущей страницы.
						//Форма.мСтруктураМногострочныхРазделов.Вставить(ИмяГруппыДопСтрок, ПромТаблицаГруппыСтрок);
						КопироватьДанныеФормы(ПромТаблицаГруппыСтрок, Форма[ИмяГруппыДопСтрок]);
						
						// Выводим в табличный документ строки многострочной группы
						Форма.ВывестиРазделВТабличныйДокументНаСервере(ИмяГруппыДопСтрок, ПромТаблицаГруппыСтрок);
						
					КонецЦикла;

				ИначеЕсли (КолвоМногострочныхБлоков > 0) И (СохранятьМногострКакТЗ) Тогда

					ИмяГруппыДопСтрок = Форма.ОпределитьИдМногострочногоРазделаПоАктивнойСтраницеНаСервере(ИмяТекущейСтраницыПанели);
					
					ПромТаблицаДопСтрокРаздела = Форма["Хранилище" + ИмяГруппыДопСтрок].Добавить().Таблица;
						
					КопироватьДанныеФормы(ДанныеДопСтрокРаздела, ПромТаблицаДопСтрокРаздела);
					
					// Заменяем таблицу значений с данными текущей страницы.
					//Форма.мСтруктураМногострочныхРазделов.Вставить(ИмяГруппыДопСтрок, ПромТаблицаДопСтрокРаздела);
					КопироватьДанныеФормы(ПромТаблицаДопСтрокРаздела, Форма[ИмяГруппыДопСтрок]);
					
					// Выводим строки многострочной группы замещающей страницы
					Форма.ВывестиРазделВТабличныйДокументНаСервере(ИмяГруппыДопСтрок, ПромТаблицаДопСтрокРаздела);

				КонецЕсли;
				
			КонецЕсли;

			ПредставлениеДанных = РегламентированнаяОтчетностьКлиентСервер.ПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "ПредставлениеДанных");
			// Восстановим данные замещаемой страницы.
			СтруктураДанныхСтраницыЗамена = СтрТаблицаСтраницыЗамена.Данные[0].Значение;

			Для Каждого Элемент Из СтруктураДанныхСтраницыЗамена Цикл
				ИмяПоказателя      = Элемент.Ключ;
				ЗначениеПоказателя = Элемент.Значение;

				Если ПредставлениеДанных Тогда
					
					Если Форма.ОбновитьПеременныеМодуляНаСервере(ИмяПоказателя, ЗначениеПоказателя) Тогда
						Продолжить; // Пропустим цикл
					КонецЕсли;

				КонецЕсли;

				Попытка
					ТекТабличноеПоле.Области[ИмяПоказателя].Значение = ЗначениеПоказателя;
				Исключение
				КонецПопытки;

			КонецЦикла;
			
			СтрТаблицаСтраницыЗамена.АктивнаяСтраница = Истина;
			
		КонецЕсли;
        				
		Форма.РасчетНаСервере(ИмяТекущейСтраницыПанели);
		
		Форма.Модифицированность = Истина;

	КонецЕсли;
   	
КонецПроцедуры


Процедура ВставитьДополнительнуюСтраницуНаСервере(Форма, ИмяТекущейСтраницыПанели = Неопределено) Экспорт

	Перем ТаблицаСтраницРаздела;
	Перем СтруктураДанныхДопСтрокРаздела;
   	
	Если Не Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяТекущейСтраницыПанели, ТаблицаСтраницРаздела) Тогда
		Возврат;
	Иначе
		МаксКолвоЭкз=РегламентированнаяОтчетностьКлиентСервер.ПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "МаксКолвоЭкз", 0);
		Если МаксКолвоЭкз<>0 И Форма[Форма.мСтруктураМногостраничныхРазделов[ИмяТекущейСтраницыПанели]].Количество() >= МаксКолвоЭкз Тогда
			
			ЗаголовокСтраницы = ИмяТекущейСтраницыПанели;
			
			Сообщение = Новый СообщениеПользователю;
			
			Сообщение.Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='В разделе ""%1"" максимальное количество экземпляров страниц равно %2.';uk='В розділі ""%1"" максимальна кількість екземплярів сторінок дорівнює 
|%2.'"), ЗаголовокСтраницы, МаксКолвоЭкз);
			
			Сообщение.Сообщить();
                
			Возврат;
			
		КонецЕсли;
	КонецЕсли;
	
	ИмяТекТабличногоПоля     = "ТабличныйДокумент";
	ТекТабличноеПоле         = Форма[ИмяТекТабличногоПоля];

	// Сначала сохраним данные текущей страницы.
	// Если на листе есть многострочность, то удалим ее.
	РегламентированнаяОтчетностьКлиентСервер.СохранитьДанныеМногостраничногоРазделаВактивнойСтранице(Форма, ИмяТекущейСтраницыПанели, Истина);
	
	ТаблицаСтраницРаздела = Форма[ТаблицаСтраницРаздела];
	
	// Часть для подстраховки, от старой системы хранения многостраничности
	Если ТаблицаСтраницРаздела.Количество() = 0 Тогда
		// создаем исходную таблицу значений многостраничных разделов
		СтрТаблицаСтраницы = ТаблицаСтраницРаздела.Добавить();
		СтрТаблицаСтраницы.АктивнаяСтраница = Истина;
	КонецЕсли;

	// Найдем активную страницу
	СтрТаблицаСтраницы = ТаблицаСтраницРаздела.НайтиСтроки(Новый Структура ("АктивнаяСтраница", Истина));

	Если СтрТаблицаСтраницы.Количество() > 0 Тогда

		СтрТаблицаСтраницы = СтрТаблицаСтраницы[0];
		
		// Убираем активность у текущей страницы
		СтрТаблицаСтраницы.АктивнаяСтраница = Ложь;
        						                                   
	КонецЕсли;
	
	// Добавляем новую страницу
	СтрНоваяСтраница = ТаблицаСтраницРаздела.Добавить();
	
	// Присваиваем представление по умолчанию
	СтрНоваяСтраница.Представление      = "Новая страница";
	СтрНоваяСтраница.АвтоматическоеПредставление      = Истина;
	
	// Ставим признак активной страницы
	СтрНоваяСтраница.АктивнаяСтраница   = Истина;
	
	КолМногострочныхЧастей = РегламентированнаяОтчетностьКлиентСервер.ПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "МногострочностьВРазделе").Количество();
	
	// Если есть многострочность, то она очищена в проц роСохранитьДанныеМногостраничногоРазделаВактивнойСтранице
	// Если многострочность есть, то она удалится и запустится Расчет на стадии роСохранитьДанныеМногостраничногоРазделаВактивнойСтранице
	Если КолМногострочныхЧастей = 0 Тогда
		// Очищаем текущее поле
		Форма.ОчиститьТабличноеПолеНаСервере(ИмяТекущейСтраницыПанели);
	КонецЕсли;
	
	Если КолМногострочныхЧастей = 0 Тогда
		// Выполняем расчет показателей добавленной страницы
		Форма.РасчетНаСервере(ИмяТекущейСтраницыПанели);
	КонецЕсли;
	
	Форма.Модифицированность = Истина;
    		
КонецПроцедуры





Функция ЗначениеИнтервалаНапоминанийРегламентированнойОтчетности() Экспорт

	ИнтервалНапоминанийРегламентированнойОтчетности = ХранилищеНастроекДанныхФорм.Загрузить("Обработка.ОбщиеОбъектыРегламентированнойОтчетности.Форма.УправлениеОтчетностьюФормаНастройки", "ИнтервалНапоминанийРегламентированнойОтчетности");
	Если ИнтервалНапоминанийРегламентированнойОтчетности = Неопределено Тогда
		ИнтервалНапоминаний = 3;
	Иначе
		ИнтервалНапоминаний = ИнтервалНапоминанийРегламентированнойОтчетности;
	КонецЕсли;
	Возврат ИнтервалНапоминаний;

КонецФункции

/////////////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА АВТОМАТИЧЕСКОГО ЗАПОЛНЕНИЯ
//


Процедура ВставитьПоказательВСтруктуру(СтруктураПоказателей, ИмяПоказателя, ПризнакАвтозаполнения, ПризнакРасшифровки) Экспорт
	
	// Вставляем в структуру новый показатель.
	СтруктураПоказателей.Вставить(ИмяПоказателя, Новый Массив(2));	
	// Устанавливаем признак автозаполнения показателя.
	СтруктураПоказателей[ИмяПоказателя][0] = ПризнакАвтозаполнения;
	// Устанавливаем признак расшифровки показателя.
	СтруктураПоказателей[ИмяПоказателя][1] = ПризнакРасшифровки;
	
КонецПроцедуры


Процедура ПолучитьСведенияОПоказателяхОтчета(Форма, ПараметрыОтчета = Неопределено) Экспорт
	
	Форма_ИмяФормы = СтрЗаменить(Форма.ИмяФормы, "Внешний", "");
	АвтозаполняемыеПоказателиОтчета = РегламентированнаяОтчетностьПереопределяемый.ПолучитьСведенияОПоказателяхОтчета(Сред(Лев(Форма_ИмяФормы, Найти(Форма_ИмяФормы, ".Форма.") - 1), 7), Сред(Форма_ИмяФормы, Найти(Форма_ИмяФормы, ".Форма.") + 7), ПараметрыОтчета);
	 	 	
	Если АвтозаполняемыеПоказателиОтчета.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого АвтозаполняемыйПоказательОтчета Из АвтозаполняемыеПоказателиОтчета Цикл
		
		Если АвтозаполняемыйПоказательОтчета.Значение[0] Тогда
			
			Форма.СтруктураРеквизитовФормы.ОтображатьКнопкуЗаполнить = Истина;
			
			Если Форма.СтруктураРеквизитовФормы.ОтображатьКнопкуРасшифровать Тогда
				Прервать;
			КонецЕсли;
											
		КонецЕсли;	
		
		Если АвтозаполняемыйПоказательОтчета.Значение[1] Тогда
			
			Форма.СтруктураРеквизитовФормы.ОтображатьКнопкуРасшифровать = Истина;
			
			Если Форма.СтруктураРеквизитовФормы.ОтображатьКнопкуЗаполнить Тогда
				Прервать;
			КонецЕсли;
								
		КонецЕсли;	
			
	КонецЦикла;
	
	ОбновитьТаблицыВариантовЗаполнения(Форма, АвтозаполняемыеПоказателиОтчета);
			
КонецПроцедуры


Процедура ОбновитьТаблицыВариантовЗаполнения(Форма, АвтозаполняемыеПоказателиОтчета)
	
	Для Каждого АвтозаполняемыйПоказатель Из АвтозаполняемыеПоказателиОтчета Цикл
		
		Если АвтозаполняемыйПоказатель.Значение[0] Тогда
			
			НайденноеЗначение = Форма.мТаблицаСоставПоказателей.НайтиСтроки(Новый Структура("КодПоказателяПоСоставу", АвтозаполняемыйПоказатель.Ключ));
			
			Если НайденноеЗначение.Количество() > 0 Тогда
				
				НайденноеЗначение = НайденноеЗначение[0];
				
				Для Каждого ТаблВариантовЗаполн Из Форма["ТаблицаВариантыЗаполнения" + НайденноеЗначение.ИмяПоляТаблДокумента] Цикл
					
					ТаблицаВариантыЗаполнения = ТаблВариантовЗаполн.ТаблицаВариантовЗаполнения;
					
					НайденныеПоказатели = ТаблицаВариантыЗаполнения.НайтиСтроки(Новый Структура("КодПоказателя", АвтозаполняемыйПоказатель.Ключ));
					
					Если НайденныеПоказатели.Количество() = 0 Тогда
						
						СтрТабл = ТаблицаВариантыЗаполнения.Добавить();
						СтрТабл.КодПоказателя = АвтозаполняемыйПоказатель.Ключ;
						СтрТабл.ВариантЗаполнения = 3;
						
					Иначе
						
						НайденныйПоказатель = НайденныеПоказатели[0];
						
						НайденныйПоказатель.ВариантЗаполнения = 3;
						
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

/////////////////////////////////////////////////////////////////////////////////////////
// ИНТЕРФЕЙС ВЗАИМОДЕЙСТВИЯ С КОНФИГУРАЦИЯМИ (БИБЛИОТЕКАМИ) - ПОТРЕБИТЕЛЯМИ
//


// Функция возвращает массив ссылок на сохраненные регламентированные отчеты заданного вида
// для указанной организации за нужный отчетный период.
//
// Возвращаемое значение: массив ссылок.
//
// Параметры:
//	ИсточникОтчета - строка с наименованием регламентированного отчета (совпадает с именем объекта метаданных).
// 	Организация    - ссылка на элемент справочника организаций.
//  ДатаОкончания  - дата окончания отчетного периода (правая граница отчетного периода).
//
// Пример:
// 	РегламентированнаяОтчетность.ПолучитьСсылкуНаРеглОтчет("РегламентированныйОтчетБаланс", "ФормаОтчета2012Кв1", Организация, '20120331');
//
Функция ПолучитьСсылкуНаРеглОтчет(ИсточникОтчета, Организация, ДатаОкончания) Экспорт
	
	Запрос = Новый Запрос;
	
	ТекстЗапроса = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	РегламентированныйОтчет.Дата,
	|	РегламентированныйОтчет.Ссылка
	|ИЗ
	|	Документ.РегламентированныйОтчет КАК РегламентированныйОтчет
	|ГДЕ  РегламентированныйОтчет.ИсточникОтчета = &ИсточникОтчета
	|	И РегламентированныйОтчет.ВыбраннаяФорма ПОДОБНО &ВыбраннаяФорма
	|	И РегламентированныйОтчет.Организация = &Организация
	|	И РегламентированныйОтчет.ДатаОкончания = &ДатаОкончания
	|	И НЕ РегламентированныйОтчет.ПометкаУдаления";
	 
	Запрос.Текст = ТекстЗапроса;
	 
	Запрос.УстановитьПараметр("ИсточникОтчета", ИсточникОтчета);
	Запрос.УстановитьПараметр("ВыбраннаяФорма", РегламентированнаяОтчетностьВызовСервера.ИмяФормыРеглОтчетаДействующейВОтчетномПериоде(ИсточникОтчета, ДатаОкончания));
	Запрос.УстановитьПараметр("Организация",	Организация);
	Запрос.УстановитьПараметр("ДатаОкончания",	ДатаОкончания);
	
	РезультатЗапроса = Запрос.Выполнить().Выгрузить();
	
	РезультатЗапроса.Сортировать("Дата Убыв");
	
	Возврат РезультатЗапроса.ВыгрузитьКолонку("Ссылка");
	
КонецФункции


// Функция возвращает структуру с данными регламентированного отчета.
// Ключ структуры совпадает с наименованием раздела регл. отчета,
// значение структуры содержит данные раздела регл. отчета.
// Все разделы регл. отчета подразделяются на два вида: одностраничные, многостраничные.
// Одностраничные разделы имеют тип Структура, в которой содержатся имена показателей
// вместе с их значениями.
// Многостраничные разделы имеют тип ТаблицаЗначений. Каждый элемент таблицы значений
// - это отдельная страница раздела. Данные страницы содержатся в колонке Данные
// с типом Структура, в которой содержатся имена показателей вместе с их значениями.
//
// Возвращаемое значение: структура с данными регл. отчета.
//
// Параметры:
//  СсылкаНаСохрРеглОтчет - ссылка на сохраненный регламентированный отчет, данные которого нужно получить.
//
Функция ПолучитьДанныеРеглОтчета(СсылкаНаСохрРеглОтчет) Экспорт
	
	Перем ДанныеМногостраничныхРазделов;
	Перем ДанныеМногострочныхРазделов;
	Перем ПоказателиРеглОтчета;
	
	ДанныеРеглОтчета = Новый Структура;
	          	
	ДанныеРеглОтчета.Вставить("ФормаРеглОтчетаДействуетВТекущемОтчетномПериоде", (СсылкаНаСохрРеглОтчет.ВыбраннаяФорма = РегламентированнаяОтчетностьВызовСервера.ИмяФормыРеглОтчетаДействующейВОтчетномПериоде(СсылкаНаСохрРеглОтчет.ИсточникОтчета, СсылкаНаСохрРеглОтчет.ДатаОкончания)));
	
	ДанныеРеглОтчета.Вставить("Организация", СсылкаНаСохрРеглОтчет.Организация.Ссылка);
	
	ДанныеРазделовРеглОтчета = Новый Структура;
	
	СписокСохранения = СсылкаНаСохрРеглОтчет.ДанныеОтчета.Получить();
	
	Если СписокСохранения.Свойство("ПоказателиОтчета", ПоказателиРеглОтчета) Тогда
		
		Для Каждого ЭлементСтруктуры Из ПоказателиРеглОтчета Цикл
			
			ДанныеРазделовРеглОтчета.Вставить(СтрЗаменить(ЭлементСтруктуры.Ключ, "ПолеТабличногоДокумента", ""), ЭлементСтруктуры.Значение);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Если СписокСохранения.Свойство("ДанныеМногостраничныхРазделов", ДанныеМногостраничныхРазделов) Тогда
				
		Для Каждого ЭлементСтруктуры Из ДанныеМногостраничныхРазделов Цикл
			
			ДанныеРазделовРеглОтчета.Вставить(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);

		КонецЦикла;

	КонецЕсли;
	
	Если СписокСохранения.Свойство("ДанныеМногострочныхРазделов", ДанныеМногострочныхРазделов) Тогда
				
		Для Каждого ЭлементСтруктуры Из ДанныеМногострочныхРазделов Цикл
			
			Для Каждого РазделРеглОтчета Из ПоказателиРеглОтчета Цикл
				
				Для Каждого ПоказательРеглОтчета Из РазделРеглОтчета.Значение Цикл
					
					Если Лев(ПоказательРеглОтчета.Ключ, 11) = ЭлементСтруктуры.Ключ Тогда
						
						ДанныеРазделовРеглОтчета.Вставить(СтрЗаменить(РазделРеглОтчета.Ключ, "ПолеТабличногоДокумента", "") + "_ДанныеДопСтрок", ЭлементСтруктуры.Значение);
						
						Прервать;
						
					КонецЕсли;
										
				КонецЦикла;
								
			КонецЦикла;
			
		КонецЦикла;

	КонецЕсли;
	
	ДанныеРеглОтчета.Вставить("ДанныеРазделовРеглОтчета", ДанныеРазделовРеглОтчета);
		
	Возврат ДанныеРеглОтчета;
	
КонецФункции


// Функция возвращает ссылку на головную организацию.
//
// Возвращаемое значение: ссылка на элемент справочника организаций.
//
// Параметры:
// 	Организация - ссылка на элемент справочника организаций.
//
Функция ГоловнаяОрганизация(Организация) Экспорт
	
	ГоловнаяОрганизация = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Организация, "ГоловнаяОрганизация");
	
	Если НЕ ЗначениеЗаполнено(Организация)
	 ИЛИ НЕ ЗначениеЗаполнено(ГоловнаяОрганизация) Тогда
	 
		Возврат Организация;
		
	Иначе
		
		Возврат ГоловнаяОрганизация; 
		
	КонецЕсли;

КонецФункции 

/////////////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ОБНОВЛЕНИЯ ИНФОРМАЦИОННОЙ БАЗЫ
//


Процедура ЗаполнитьСписокОбработчиковОбновленияИнформационнойБазы(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "*";
	Обработчик.Процедура = "РегламентированнаяОтчетность.ВыполнитьОбновлениеИнформационнойБазы";
	
КонецПроцедуры


Процедура ВыполнитьОбновлениеИнформационнойБазы() Экспорт
	
	// Заполнение списка регламентированных отчетов.
	ЗаполнитьСписокРегламентированныхОтчетов(Ложь);
	
КонецПроцедуры


Процедура ЗаполнитьСписокРегламентированныхОтчетов(ПервоеЗаполнение = Истина, ИзменятьПризнакИспользованияВнешнегоОтчета = Истина) Экспорт

	Перем ДеревоОтчетов;
	Перем ОбработкаОбновлениеОтчетов;

	Если ИзменятьПризнакИспользованияВнешнегоОтчета И НЕ ПервоеЗаполнение Тогда

		Запрос = Новый Запрос("ВЫБРАТЬ
		                      |	РегламентированныеОтчеты.Ссылка КАК Ссылка,
							  |	РегламентированныеОтчеты.ИсточникОтчета КАК ИсточникОтчета
		                      |ИЗ
		                      |	Справочник.РегламентированныеОтчеты КАК РегламентированныеОтчеты
		                      |ГДЕ
		                      |	РегламентированныеОтчеты.ВнешнийОтчетИспользовать = &ПризнакИспользованияВнешнегоОтчета");
		Запрос.УстановитьПараметр("ПризнакИспользованияВнешнегоОтчета", Истина);
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			Если Метаданные.Документы.Найти(Выборка.ИсточникОтчета) <> Неопределено ИЛИ	Метаданные.Отчеты.Найти(Выборка.ИсточникОтчета) <> Неопределено Тогда
				ОбъектРеглОтчет = Выборка.Ссылка.ПолучитьОбъект();
				ОбъектРеглОтчет.ВнешнийОтчетИспользовать = Ложь;
				ОбъектРеглОтчет.Записать();
			КонецЕсли;
		КонецЦикла;

	КонецЕсли;

	// Заполнением списка отчетов выполняется путем вызова экспортных процедур
	// основной формы обработки ОбновлениеРегламентированнойОтчетности.
	ОбработкаОбновлениеОтчетов = Обработки.ОбновлениеРегламентированнойОтчетности.Создать();

	// Получаем список регламентированных отчетов в виде дерева.
	ДеревоОтчетов = ОбработкаОбновлениеОтчетов.ПолучитьСписокОтчетов();

	Если ДеревоОтчетов.Строки.Количество() = 0 Тогда
		// нет обновлений
		Возврат;
	КонецЕсли;

	// Заполняем списком отчетов.
	ОбработкаОбновлениеОтчетов.ЗаполнитьСписокОтчетов(ДеревоОтчетов, ПервоеЗаполнение);
	
КонецПроцедуры


Процедура ДобавитьПрефиксОрганизации(ДокументОбъект, Префикс) Экспорт
	
	// Если  нет реквизита "Организация" или для нее не задан префикс, то 
	// используем пустой префикс,
	// иначе используем префикс организации.
	МетаданныеДокумента = ДокументОбъект.Метаданные();

	Если Не ЕстьРеквизитДокумента("Организация", МетаданныеДокумента)
		 ИЛИ НЕ ЗначениеЗаполнено(ДокументОбъект.Организация.Префикс)  Тогда
		Префикс = "";
	Иначе
                                
		Префикс = ДокументОбъект.Организация.Префикс;
        		
	КонецЕсли;
	
Конецпроцедуры


Функция ПолучитьОрганизациюДокумента(ДокументСсылка) Экспорт

	Если НЕ ДокументСсылка = Неопределено И Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(ДокументСсылка)) Тогда
		Возврат ДокументСсылка.Организация
	Иначе	
	    Возврат Неопределено;
	КонецЕсли;

КонецФункции // ()



Функция ПроверитьВозможностьОткрытияОтчета(ИсточникОтчета) Экспорт
	
	ПравоДоступаКОтчету = РегламентированнаяОтчетностьВызовСервера.ПравоДоступаКРегламентированномуОтчету(ИсточникОтчета);
	
	Если ПравоДоступаКОтчету = Ложь Тогда
		Сообщить(НСтр("ru='Недостаточно прав';uk='Недостатньо прав'"), СтатусСообщения.Важное);
		Сообщить(НСтр("ru='Выгрузка не выполнена!';uk='Вивантаження не виконано!'"), СтатусСообщения.Важное);
		Возврат Ложь
	ИначеЕсли ПравоДоступаКОтчету = Неопределено Тогда
		Сообщить(НСтр("ru='В справочнике регл. отчетов не зарегистрирован соответствующий отчет';uk='У довіднику регл. звітів не зареєстрований відповідний звіт'"), СтатусСообщения.Важное);
		Сообщить(НСтр("ru='Выгрузка не выполнена!';uk='Вивантаження не виконано!'"), СтатусСообщения.Важное);
		Возврат Ложь;
	КонецЕсли;
	
	ТекОтчет = РегламентированнаяОтчетность.РеглОтчеты(ИсточникОтчета);
	Если ТекОтчет = Неопределено Тогда
		Сообщить(НСтр("ru='Не удалось открыть соответсвующий регл. отчет';uk='Не вдалося відкрити відповідний регл. звіт'"), СтатусСообщения.Важное);
		Сообщить(НСтр("ru='Выгрузка не выполнена!';uk='Вивантаження не виконано!'"), СтатусСообщения.Важное);
		Возврат Ложь
	КонецЕсли;
	
	ТекФорма = РегламентированнаяОтчетность.ФормаРеглОтчета(ИсточникОтчета);
	Если ТекФорма = Неопределено Тогда
		Сообщить(НСтр("ru='Не удалось открыть соответсвующий регл. отчет';uk='Не вдалося відкрити відповідний регл. звіт'"), СтатусСообщения.Важное);
		Сообщить(НСтр("ru='Выгрузка не выполнена!';uk='Вивантаження не виконано!'"), СтатусСообщения.Важное);
		Возврат Ложь
	КонецЕсли;

	Возврат Истина;
	
КонецФункции // ()


Функция ВидКонтактнойИнформации(НаимВидаКИ) Экспорт
	
	ВидКИ = Неопределено;
	
	РегламентированнаяОтчетностьПереопределяемый.ПолучитьВидКонтактнойИнформации(ВидКИ, НаимВидаКИ);
	
	Если ВидКИ = Неопределено Тогда
		
		ВидКИ = Справочники.ВидыКонтактнойИнформации[НаимВидаКИ];
		
	КонецЕсли;	
	
	Возврат ВидКИ;
	
КонецФункции


// Функция возвращает структуру с данными регламентированного отчета.
//
// Возвращаемое значение: структура с данными регл. отчета.
//
// Параметры:
//  СсылкаНаСохрРегОтчет - ссылка на сохраненный регламентированный отчет, данные которого нужно получить.
//
Функция ПолучитьДанныеСохрРегОтчета(СсылкаНаСохрРегОтчет) Экспорт
	
	Перем ДанныеМногостраничныхРазделов;
	Перем ДанныеМногострочныхРазделов;
	Перем ПоказателиРеглОтчета;
	
	ДанныеСохрРегОтчета = Новый Структура;
	
	ДанныеРазделовРеглОтчета = Новый Структура;
	
	СписокСохранения = СсылкаНаСохрРегОтчет.ДанныеОтчета.Получить();
	
	Если СписокСохранения.Свойство("ПоказателиОтчета", ПоказателиРеглОтчета) Тогда
		
		Для Каждого ЭлементСтруктуры Из ПоказателиРеглОтчета Цикл
			
			ДанныеРазделовРеглОтчета.Вставить(СтрЗаменить(ЭлементСтруктуры.Ключ, "ПолеТабличногоДокумента", ""), ЭлементСтруктуры.Значение);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Если СписокСохранения.Свойство("ДанныеМногостраничныхРазделов", ДанныеМногостраничныхРазделов) Тогда
		
		Для Каждого ЭлементСтруктуры Из ДанныеМногостраничныхРазделов Цикл
			
			ДанныеРазделовРеглОтчета.Вставить(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Если СписокСохранения.Свойство("ДанныеМногострочныхРазделов", ДанныеМногострочныхРазделов) Тогда
		
		Для Каждого ЭлементСтруктуры Из ДанныеМногострочныхРазделов Цикл
			
			Для Каждого РазделРеглОтчета Из ПоказателиРеглОтчета Цикл
				
				Для Каждого ПоказательРеглОтчета Из РазделРеглОтчета.Значение Цикл
					
					Если Лев(ПоказательРеглОтчета.Ключ, 11) = ЭлементСтруктуры.Ключ Тогда
						
						ДанныеРазделовРеглОтчета.Вставить(СтрЗаменить(РазделРеглОтчета.Ключ, "ПолеТабличногоДокумента", "") + "_ДанныеДопСтрок",
							ЭлементСтруктуры.Значение);
						
						Прервать;
						
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЕсли;
	
	ДанныеСохрРегОтчета.Вставить("ДанныеРазделовРеглОтчета", ДанныеРазделовРеглОтчета);
	
	Возврат ДанныеСохрРегОтчета;
	
КонецФункции


Функция ПринтерДоступен() Экспорт
	
	ТаблДок = Новый ТабличныйДокумент;
	Возврат ОбщегоНазначения.ПроверитьВыводТабличногоДокумента(ТаблДок, ТаблДок, Ложь);
	
КонецФункции


Процедура ЗаполнитьСтруктуруДанныхРазделаЗначениямиИзДопСтрок(СтруктураДанных, ДанныеДопСтрок) Экспорт
	
	Если ТипЗнч(ДанныеДопСтрок) <> Тип("Массив") Тогда
		
		МассивДанныхДопСтрок = Новый Массив;
		МассивДанныхДопСтрок.Добавить(ДанныеДопСтрок);
		
	Иначе
		
		МассивДанныхДопСтрок = ДанныеДопСтрок;
		
	КонецЕсли;
	
	Для Каждого ДопСтроки Из МассивДанныхДопСтрок Цикл
		
		ТЗ = ДанныеФормыВЗначение(ДопСтроки, Тип("ТаблицаЗначений"));
		
		Если ТипЗнч(ТЗ) = Тип("ТаблицаЗначений") Тогда
			
			Для ИндексТЗ = 0 По ТЗ.Количество() - 1 Цикл
				
				Для Каждого КолонкаТЗ Из ТЗ.Колонки Цикл
					
					СтруктураДанных.Вставить(
						КолонкаТЗ.Имя + "_" + Формат(ИндексТЗ + 1, "ЧГ="), ТЗ[ИндексТЗ][КолонкаТЗ.Имя]);
					
				КонецЦикла;
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры


Функция ЗначенияИзДопСтрокСоответствуютСтруктуреДанныхРаздела(СтруктураДанных, ДанныеДопСтрок) Экспорт
	
	Если ТипЗнч(ДанныеДопСтрок) <> Тип("Массив") Тогда
		
		МассивДанныхДопСтрок = Новый Массив;
		МассивДанныхДопСтрок.Добавить(ДанныеДопСтрок);
		
	Иначе
		
		МассивДанныхДопСтрок = ДанныеДопСтрок;
		
	КонецЕсли;
	
	Для Каждого ДопСтроки Из МассивДанныхДопСтрок Цикл
		
		ТЗ = ДанныеФормыВЗначение(ДопСтроки, Тип("ТаблицаЗначений"));
		
		Если ТипЗнч(ТЗ) = Тип("ТаблицаЗначений") Тогда
			
			Для ИндексТЗ = 0 По ТЗ.Количество() - 1 Цикл
				
				Для Каждого КолонкаТЗ Из ТЗ.Колонки Цикл
					
					ТекЗначение = Неопределено;
					
					Если СтруктураДанных.Свойство(КолонкаТЗ.Имя + "_" + Формат(ИндексТЗ + 1, "ЧГ="), ТекЗначение) Тогда
						
						Если ТекЗначение = ТЗ[ИндексТЗ][КолонкаТЗ.Имя] Тогда
							
							Продолжить;
							
						Иначе
							
							Возврат Ложь;
							
						КонецЕсли;
						
					Иначе
						
						Возврат Ложь;
						
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

#Если ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение Тогда

// Пытается проставить номер страницы НомерЛиста в соответствующие ячейки табличного документа ТаблДок.
// Возвращает Истина, если удалось проставить номер. В противном случае возвращает Ложь.
Функция УдалосьПроставитьНомерСтраницы(ТаблДок,Знач НомерЛиста)
	ОбластиСНомерамиЛистов = Новый СписокЗначений;
	Для Каждого Обл Из ТаблДок.Значение.Области Цикл
		Если Обл.ТипОбласти <> ТипОбластиЯчеекТабличногоДокумента.Прямоугольник ИЛИ Обл.СодержитЗначение <> Истина Тогда
			Продолжить;
		КонецЕсли;
		Если Лев(ВРЕГ(Обл.Имя), 6) = "НОМСТР" И (Прав(Обл.Имя, 1) = "1" ИЛИ Прав(Обл.Имя, 1) = "2" ИЛИ Прав(Обл.Имя, 1) = "3" ИЛИ Прав(Обл.Имя, 1) = "4" ИЛИ Прав(Обл.Имя, 1) = "5" ИЛИ Прав(Обл.Имя, 1) = "6")Тогда
			ОбластиСНомерамиЛистов.Добавить(Обл);
		КонецЕсли;
		//Если ОбластиСНомерамиЛистов.Количество() = 3 Тогда
		//	Прервать;
		//КонецЕсли;
	КонецЦикла;
	
	Если ОбластиСНомерамиЛистов.Количество() < 3 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПервоеЧисло = Формат(НомерЛиста % 10, "ЧЦ=1; ЧН=0; ЧГ=");
	НомерЛиста = Цел(НомерЛиста / 10);
	ВтороеЧисло = Формат(НомерЛиста % 10, "ЧЦ=1; ЧН=0; ЧГ=");
	НомерЛиста = Цел(НомерЛиста / 10);
	ТретьеЧисло = Формат(НомерЛиста % 10, "ЧЦ=1; ЧН=0; ЧГ=");
	НомерЛиста = Цел(НомерЛиста / 10);
	ЧетвертоеЧисло = Формат(НомерЛиста % 10, "ЧЦ=1; ЧН=0; ЧГ=");
	НомерЛиста = Цел(НомерЛиста / 10);
	ПятоеЧисло = Формат(НомерЛиста % 10, "ЧЦ=1; ЧН=0; ЧГ=");
	НомерЛиста = Цел(НомерЛиста / 10);
	ШестоеЧисло = Формат(НомерЛиста % 10, "ЧЦ=1; ЧН=0; ЧГ=");
	
	Если ОбластиСНомерамиЛистов.Количество() = 3 Тогда
		ОбластиСНомерамиЛистов.Получить(0).Значение.Значение = ТретьеЧисло;
		ОбластиСНомерамиЛистов.Получить(1).Значение.Значение = ВтороеЧисло;
		ОбластиСНомерамиЛистов.Получить(2).Значение.Значение = ПервоеЧисло;
	Иначе
		ОбластиСНомерамиЛистов.Получить(0).Значение.Значение = ШестоеЧисло;
		ОбластиСНомерамиЛистов.Получить(1).Значение.Значение = ПятоеЧисло;
		ОбластиСНомерамиЛистов.Получить(2).Значение.Значение = ЧетвертоеЧисло;
		ОбластиСНомерамиЛистов.Получить(3).Значение.Значение = ТретьеЧисло;
		ОбластиСНомерамиЛистов.Получить(4).Значение.Значение = ВтороеЧисло;
		ОбластиСНомерамиЛистов.Получить(5).Значение.Значение = ПервоеЧисло;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции // УдалосьПроставитьНомерСтраницы()
	
// Проставляет номера листов на каждом листе и общее количество листов на титульном;
// после нумерации выводит листыв в общую форму ПечатьРегламентированныхОтчетов.
// Параметры:
// Форма - объект типа Форма, из которого была вызвана печать.
// ВидПечати - строка, задающая действие, которое следует произвести с печатными формами: 
// непосредственная печать или предварительный просмотр.
// ПризнакНумеруемыхФорм - данный параметр следует установить в Ложь для тех
// печатных форм, в которых не предусмотрены области для нумерации листов и 
// указания общего количества листов (например, форма 4ФСС и т.п.).
Процедура ПроставитьНомераЛистов(Форма, ВидПечати, ПризнакНумеруемыхФорм = Истина) Экспорт;
	
	Если ПризнакНумеруемыхФорм Тогда
		Если Форма.мСчетчикСтраниц <> Истина Тогда
			НомерЛиста = 1;
			Для Каждого Эл Из Форма.мПечатныеФормы Цикл
				Если НЕ УдалосьПроставитьНомерСтраницы(Эл.Значение, НомерЛиста) Тогда
					Сообщить(НСтр("ru='Не удалось проставить номер страницы для ';uk='Не вдалося проставити номер сторінки для '") + Эл.Представление);
					Продолжить;
				КонецЕсли;
				НомерЛиста = НомерЛиста + 1;
			КонецЦикла;
			
			Если Форма.мПечатныеФормы.Количество() <> 0 Тогда
				ТаблДок = Форма.мПечатныеФормы.Получить(0).Значение.Значение;
				Если ТаблДок.Области.Найти("СоставленаНа6") <> Неопределено Тогда
					ВсегоЛистов = Формат(НомерЛиста - 1, "ЧЦ=6; ЧН=0; ЧВН=; ЧГ=");
					Попытка
						ТаблДок.Области.СоставленаНа1.Значение = Сред(ВсегоЛистов, 1, 1);
						ТаблДок.Области.СоставленаНа2.Значение = Сред(ВсегоЛистов, 2, 1);
						ТаблДок.Области.СоставленаНа3.Значение = Сред(ВсегоЛистов, 3, 1);
						ТаблДок.Области.СоставленаНа4.Значение = Сред(ВсегоЛистов, 4, 1);
						ТаблДок.Области.СоставленаНа5.Значение = Сред(ВсегоЛистов, 5, 1);
						ТаблДок.Области.СоставленаНа6.Значение = Сред(ВсегоЛистов, 6, 1);
					Исключение
						//Сообщить("Не удалось проставить общее количество листов на титульном листе отчета!", СтатусСообщения.Внимание);
					КонецПопытки;
				Иначе
					ВсегоЛистов = Формат(НомерЛиста - 1, "ЧЦ=3; ЧН=0; ЧВН=; ЧГ=");
					Попытка
						ТаблДок.Области.СоставленаНа1.Значение = Сред(ВсегоЛистов, 1, 1);
						ТаблДок.Области.СоставленаНа2.Значение = Сред(ВсегоЛистов, 2, 1);
						ТаблДок.Области.СоставленаНа3.Значение = Сред(ВсегоЛистов, 3, 1);
					Исключение
						//Сообщить("Не удалось проставить общее количество листов на титульном листе отчета!", СтатусСообщения.Внимание);
					КонецПопытки;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	//Если НЕ НаложитьДвухмерныйШтрихКод(Форма) Тогда
	//	Сообщить(НСтр("ru='Не удалось сгенерировать двухмерный штрих-код.';uk='Не вдалося згенерувати двомірний штрих-код.'"), СтатусСообщения.Внимание);
	//	Возврат;
	//КонецЕсли;
	
	НомераЛистов = Новый СписокЗначений;
	
	ПредПросмотр = ПолучитьОбщуюФорму("ПечатьРегламентированныхОтчетов", , Форма);
	Если ПредПросмотр.Открыта() Тогда
		ПредПросмотр.Закрыть();
		ПредПросмотр = ПолучитьОбщуюФорму("ПечатьРегламентированныхОтчетов", , Форма);
	КонецЕсли;
	НомерЛиста = 1;
	Для Каждого Эл Из Форма.мПечатныеФормы Цикл
		НовСтр = ПредПросмотр.СписокПечатаемыхЛистов.Добавить();
		НомЛиста = НомераЛистов.НайтиПоЗначению(Эл.Представление);
		Если НомЛиста = Неопределено Тогда
			НомЛиста = НомераЛистов.Добавить(Эл.Представление, "1");
			НЛиста = 1;
		Иначе
			НЛиста = Число(НомЛиста.Представление) + 1;
			НомЛиста.Представление = Строка(Число(НомЛиста.Представление) + 1);
		КонецЕсли;
		НовСтр.Наименование = Эл.Представление + НСтр("ru='. Лист №';uk='. Аркуш №'") + НЛиста;
		Если ТипЗнч(Эл.Значение) <> Тип("ТабличныйДокумент") Тогда
			НовСтр.ТабличныйДокумент = Эл.Значение.Значение;
		Иначе
			НовСтр.ТабличныйДокумент = Эл.Значение;
		КонецЕсли;
		НомерЛиста = НомерЛиста + 1;
	КонецЦикла;
	ПредПросмотр.ВидПечати = ВидПечати;
	ПредПросмотр.Открыть();
	
КонецПроцедуры // ПроставитьНомераЛистов()

//Предлагает пользователю указать каталог для выгрузки декларации в электронном виде
Функция ПолучитьПутьВыгрузки(ПутьДляВыгрузки = Неопределено) Экспорт

	ФормаПараметровСохранения = ПолучитьОбщуюФорму("НастройкаПараметровСохраненияРегламентированногоОтчета");
	ФормаПараметровСохранения.ПутьДляВыгрузки = ПутьДляВыгрузки;

	РезВыбора = ФормаПараметровСохранения.ОткрытьМодально();
	Если РезВыбора = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	Если НЕ РезВыбора Тогда
		Возврат Ложь;
	Иначе
		Возврат ФормаПараметровСохранения.ПутьДляВыгрузки;
	КонецЕсли;

КонецФункции
#КонецЕсли

