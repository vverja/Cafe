////////////////////////////////////////////////////////////////////////////////
// ЭлектронноеВзаимодействиеСлужебный: общий механизм обмена электронными документами.
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Получает сокращенное наименование организации.
//
// Параметры:
//  Организация - СправочникСсылка.Организации - ссылка на организацию.
//
// Возвращаемое значение:
//  Строка - сокращенное наименование организации.
//
Функция СокращенноеНаименованиеОрганизации(Организация) Экспорт
	
	РеквизитНаименованиеОрганизации = ЭлектронноеВзаимодействиеСлужебныйПовтИсп.ИмяНаличиеОбъектаРеквизитаВПрикладномРешении(
		"СокращенноеНаименованиеОрганизации");
	Если НЕ ЗначениеЗаполнено(РеквизитНаименованиеОрганизации) Тогда
		РеквизитНаименованиеОрганизации = "Наименование";
	КонецЕсли;
	Возврат ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Организация, РеквизитНаименованиеОрганизации);
	
КонецФункции

// Только для внутреннего использования
Функция НемедленнаяОтправкаЭД() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Возврат НЕ Константы.ИспользоватьОтложеннуюОтправкуЭлектронныхДокументов.Получить();
	
КонецФункции

Процедура ПроверитьМодификациюОбъектаДляОбменаЭД(Источник, ПризнакИзменения = Ложь) Экспорт
	
	Если ПризнакИзменения ИЛИ Источник.ЭтоНовый() Тогда
		ЗарегистрироватьОбъект = Истина;
	Иначе
		ЗарегистрироватьОбъект = НадоЗарегистрироватьОбъект(Источник, Источник.Метаданные());
	КонецЕсли;
	
	Источник.ДополнительныеСвойства.Вставить("ЗарегистрироватьОбъект", ЗарегистрироватьОбъект);
	
КонецПроцедуры

// Вызывается из подписки на событие КонтрольНеразделенныхОбъектовПриЗаписиБЭД.
// В подписке на событие КонтрольНеразделенныхОбъектовПриЗаписиБЭД необходимо заменить Обработчик на
// РаботаВМоделиСервиса.КонтрольНеразделенныхОбъектовПриЗаписи
Процедура КонтрольНеразделенныхОбъектовПриЗаписиБЭДОбработкаПроверкиЗаполнения(Источник, Отказ, ПроверяемыеРеквизиты) Экспорт
	// не используется
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Запись событий в журнал регистрации. Обработка ошибок

// Данная процедура используется для стандартизации всех записей событий подсистемы ЭлектронноеВзаимодействие
// в журнал регистрации. В результате в журнал добавляется группировка записей с иерархией:
//  Электронное взаимодействие
//  |_ Ошибка
//    |_ Общая подсистема
//    |_ Обмен с банками
//    |_ Обмен с контрагентами
//    |_ Обмен с сайтами
//    |_ Регламентные задания
//  |_ Информация
//    |_ Общая подсистема
//    |_ Обмен с банками
//    |_ Обмен с контрагентами
//    |_ Обмен с сайтами
//    |_ Регламентные задания
//
// Параметры:
//   ОписаниеСобытия - Строка - описание содержания события, которое требуется записать в журнал регистрации.
//   КодСобытия - Число - код события, используется для стандартизации иерархии событий.
//                Может принимать значения: 0 - Общая подсистема, 1 - Обмен с банками, 2 - Обмен с контрагентами.
//                                          3 - Обмен с сайтами, 4 - Регламентные задания.
//   УровеньВажности - УровеньЖурналаРегистрации - один из доступных уровней журнала регистрации (Ошибка, Информация, ...).
//   ОбъектМетаданных - ОбъектМетаданных - объект метаданных, к которому относится событие.
//   ДанныеСсылка - Произвольный - данные, с которыми связано событие. Рекомендуется указывать ссылки на объекты данных
//                  (элементы справочников, документы, к которым относится событие).
//   РежимТранзакции - РежимТранзакцииЗаписиЖурналаРегистрации - указывает отношение записи к текущей транзакции.
//
Процедура ВыполнитьЗаписьСобытияПоЭДВЖурналРегистрации(ОписаниеСобытия,
														КодСобытия = 0,
														УровеньВажности = Неопределено,
														ОбъектМетаданных = Неопределено,
														ДанныеСсылка = Неопределено,
														РежимТранзакции = Неопределено) Экспорт
	
	Уровень = "Общая подсистема";
	Если КодСобытия = 1 Тогда
		Уровень = "Обмен с банками";
	ИначеЕсли КодСобытия = 2 Тогда
		Уровень = "Обмен с контрагентами";
	ИначеЕсли КодСобытия = 3 Тогда
		Уровень = "Обмен с сайтами";
	ИначеЕсли КодСобытия = 4 Тогда
		Уровень = "Регламентные задания";
	КонецЕсли;
	УровеньВажностиСобытия = ?(ТипЗнч(УровеньВажности) = Тип("УровеньЖурналаРегистрации"),
		УровеньВажности, УровеньЖурналаРегистрации.Ошибка);
	Шаблон = НСтр("ru='Электронное взаимодействие.%1';uk='Електронне взаємодія.%1'");
	ИмяСобытия = СтрЗаменить(Шаблон, "%1", Уровень);
	ЗаписьЖурналаРегистрации(ИмяСобытия,
		УровеньВажностиСобытия, ОбъектМетаданных, ДанныеСсылка, ОписаниеСобытия, РежимТранзакции);
	
КонецПроцедуры

// Выводит сообщение пользователю о нехватки прав доступа.
Процедура СообщитьПользователюОНарушенииПравДоступа() Экспорт
	
	ТекстСообщения = НСтр("ru='Нарушение прав доступа';uk='Порушення прав доступу'");
	ЭлектронноеВзаимодействиеПереопределяемый.ПодготовитьТекстСообщенияОНарушенииПравДоступа(ТекстСообщения);
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Операции для работы с HTTP

// Функция формирует прокси по настройкам прокси (передаваемому параметру).
//
// Параметры:
//  Протокол - Строка - протокол для которого устанавливаются параметры прокси сервера, например "http", "https", "ftp".
// 
Функция СформироватьПрокси(Протокол) Экспорт
	
	// НастройкаПроксиСервера - Соответствие:
	//  ИспользоватьПрокси - использовать ли прокси-сервер
	//  НеИспользоватьПроксиДляЛокальныхАдресов - использовать ли прокси-сервер для локальных адресов
	//  ИспользоватьСистемныеНастройки - использовать ли системные настройки прокси-сервера
	//  Сервер       - адрес прокси-сервера
	//  Порт         - порт прокси-сервера
	//  Пользователь - имя пользователя для авторизации на прокси-сервере
	//  Пароль       - пароль пользователя
	НастройкаПроксиСервера = ПолучениеФайловИзИнтернета.НастройкиПроксиНаСервере();
	Если НастройкаПроксиСервера <> Неопределено Тогда
		ИспользоватьПрокси = НастройкаПроксиСервера.Получить("ИспользоватьПрокси");
		ИспользоватьСистемныеНастройки = НастройкаПроксиСервера.Получить("ИспользоватьСистемныеНастройки");
		Если ИспользоватьПрокси Тогда
			Если ИспользоватьСистемныеНастройки Тогда
				// Системные настройки прокси-сервера.
				Прокси = Новый ИнтернетПрокси(Истина);
			Иначе
				// Ручные настройки прокси-сервера.
				Прокси = Новый ИнтернетПрокси;
				Прокси.Установить(Протокол, НастройкаПроксиСервера["Сервер"], НастройкаПроксиСервера["Порт"],
					НастройкаПроксиСервера["Пользователь"], НастройкаПроксиСервера["Пароль"]);
				Прокси.НеИспользоватьПроксиДляЛокальныхАдресов = НастройкаПроксиСервера["НеИспользоватьПроксиДляЛокальныхАдресов"];
			КонецЕсли;
		Иначе
			// Не использовать прокси-сервер.
			Прокси = Новый ИнтернетПрокси(Ложь);
		КонецЕсли;
	Иначе
		Прокси = Неопределено;
	КонецЕсли;
	
	Возврат Прокси;
	
КонецФункции

// Только для внутреннего использования
Процедура ОпределитьПараметрыСайта(Знач АдресСайта, ЗащищенноеСоединение, Адрес, Протокол) Экспорт
	
	АдресСайта = СокрЛП(АдресСайта);
	
	АдресСайта = СтрЗаменить(АдресСайта, "\", "/");
	АдресСайта = СтрЗаменить(АдресСайта, " ", "");
	
	Если НРег(Лев(АдресСайта, 7)) = "http://" Тогда
		Протокол = "http";
		Адрес = Сред(АдресСайта,8);
		ЗащищенноеСоединение = Неопределено;
	ИначеЕсли НРег(Лев(АдресСайта, 8)) = "https://" Тогда
		Протокол =  "https";
		Адрес = Сред(АдресСайта,9);
		
		СертификатыУдостоверяющихЦентров = Неопределено;
		Если Не ОбщегоНазначения.ЭтоLinuxСервер() И Не ОбщегоНазначенияПовтИсп.РазделениеВключено() Тогда
			// Ошибка фреша при работе с вебсервисами. Не работает проверка доверенных сертификатов при установке соединения.
			СертификатыУдостоверяющихЦентров = Новый СертификатыУдостоверяющихЦентровWindows;
		КонецЕсли;
		ЗащищенноеСоединение = Новый ЗащищенноеСоединениеOpenSSL( , СертификатыУдостоверяющихЦентров);
	КонецЕсли;
	
КонецПроцедуры 

// Функция раскладывает строку на элементы массива
Функция МассивПодстрок(Знач Строка, Разделитель) Экспорт
	
	Результат = Новый Массив;
	Если ПустаяСтрока(Строка) Тогда
		Возврат Результат;
	КонецЕсли;
	
	НачПозицияПервогоЭлемента = СтрНайти(Строка, "{");
	КонПозицияПервогоЭлемента = СтрНайти(Строка, "}");
	Если НачПозицияПервогоЭлемента > 0 И КонПозицияПервогоЭлемента > 0 Тогда
		ПервыйЭлемент = Сред(Строка, НачПозицияПервогоЭлемента, КонПозицияПервогоЭлемента);
		Результат.Добавить(СокрЛП(ПервыйЭлемент));
		Строка = СокрЛП(Сред(Строка,КонПозицияПервогоЭлемента + 2));
	КонецЕсли;
	
	Пока Истина Цикл
		Позиция = СтрНайти(Строка, Разделитель);
		Если Позиция = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Результат.Добавить(СокрЛП(Лев(Строка,Позиция - 1)));
		Строка = СокрЛП(Сред(Строка,Позиция + 1));
	КонецЦикла;
	
	Результат.Добавить(СокрЛП(Строка));
	
	Возврат Результат;
	
КонецФункции 

////////////////////////////////////////////////////////////////////////////////
// Файловые операция

// Только для внутреннего использования
Процедура ВыгрузитьЭДвФайл(ЭД, ИмяФайла, УказаниеТипа = Истина, ТипКодировки = "windows-1251") Экспорт
	
	НоваяЗаписьXML = Новый ЗаписьXML;
	НоваяЗаписьXML.ОткрытьФайл(ИмяФайла, ТипКодировки);
	НоваяЗаписьXML.ЗаписатьОбъявлениеXML();
	ФабрикаXDTO.ЗаписатьXML(НоваяЗаписьXML, ЭД, , , , ?(УказаниеТипа, НазначениеТипаXML.Явное, НазначениеТипаXML.Неявное));
	НоваяЗаписьXML.Закрыть();
	
КонецПроцедуры

// Возвращает временный рабочий каталог для работы с файлами ЭДО.
// Каталог создается в каталоге временных файлов системы или ином предопределенном каталоге.
//
// Параметры:
//  Подкаталог - Строка - Вложенный каталог первого уровня.
//  КлючУникальности - Строка - Вложенный каталог второго уровня.
//
Функция РабочийКаталог(Знач Подкаталог = "", КлючУникальности = "") Экспорт
	
	ИмяКаталога = ТекущийКаталогВременныхФайлов() 
		+ ?(ПустаяСтрока(Подкаталог + КлючУникальности), "", "v8_")
		+ ?(ПустаяСтрока(Подкаталог), "", Подкаталог + "_")
		+ КлючУникальности
		+ ?(ПустаяСтрока(Подкаталог + КлючУникальности), "", ПолучитьРазделительПути());
					
	КаталогНаДиске = Новый Файл(ИмяКаталога);
	
	Если КаталогНаДиске.Существует() И Не ПустаяСтрока(КлючУникальности) Тогда
		// Если структура существует, очистим файлы
		УдалитьФайлы(КаталогНаДиске, "*");
	Иначе
		СоздатьКаталог(ИмяКаталога);
	КонецЕсли;

	Возврат ИмяКаталога;
	
КонецФункции

// Только для внутреннего использования
Функция ТекущийКаталогВременныхФайлов() Экспорт
	
	ТекущийКаталог = "";
	ЭлектронноеВзаимодействиеПереопределяемый.ТекущийКаталогВременныхФайлов(ТекущийКаталог);
	Если НЕ ЗначениеЗаполнено(ТекущийКаталог) Тогда
		ТекущийКаталог = КаталогВременныхФайлов();
	КонецЕсли;
	
	Возврат ТекущийКаталог;
	
КонецФункции

// Определяет возможно ли без ошибки извлечь файлы из архива.
// Проверяется максимальная длина полного имени файла в 255 символов.
// 
// Параметры:
//  ZipЧтение - ЧтениеZIPФайла - открытий zip архив.
//  ПапкаРаспаковки - Строка - папка, в которую будут извлечены данные.
//  ИмяСоздаваемогоФайла - Строка - имя файла, который не может быть извлечен.
//
// Возвращаемое значение:
//  Булево
//
Функция ВозможноИзвлечьФайлы(ZipЧтение, ПапкаРаспаковки, ИмяСоздаваемогоФайла="") Экспорт
	
	ДлинаПутиПапки = СтрДлина(ПапкаРаспаковки);
	
	Для Каждого Элемент Из ZipЧтение.Элементы Цикл
		ИмяФайла = Элемент.ПолноеИмя;
		ДлинаИмениФайла = СтрДлина(ИмяФайла);
		ПолнаяДлина = ДлинаПутиПапки + ДлинаИмениФайла + 1;
		Если ПолнаяДлина > 255 Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Криптография

// Создает на сервере менеджер криптографии.  Пароль не устанавливается
//
// Возвращаемое значение:
//   МенеджерКриптографии  - менеджер криптографии
Функция МенеджерКриптографии(Отказ = Ложь, Операция = "", ПоказатьОшибку = Ложь, ОписаниеОшибки = "", Программа = Неопределено) Экспорт
	
	МенеджерКриптографии = ЭлектроннаяПодпись.МенеджерКриптографии(Операция, ПоказатьОшибку, ОписаниеОшибки, Программа);
	
	Отказ = (МенеджерКриптографии = Неопределено);
	
	Возврат МенеджерКриптографии;
	
КонецФункции

// Проверяет действительность подписи, без учета списка отозванных сертификатов.
// В случае ошибки генерирует исключение.
//
// Параметры:
//  МенеджерКриптографии  - МенеджерКриптографии - менеджер криптографии.
//  ДвоичныеДанныеФайла   - ДвоичныеДанные - двоичные данные файла.
//  ДвоичныеДанныеПодписи - ДвоичныеДанные - двоичные данные подписи.
//
Процедура ПроверитьПодпись(МенеджерКриптографии, ДвоичныеДанныеФайла, ДвоичныеДанныеПодписи) Экспорт
	
	МенеджерКриптографии.ПроверитьПодпись(ДвоичныеДанныеФайла, ДвоичныеДанныеПодписи);
	
КонецПроцедуры

// Получает фактическую дату установки электронной подписи и двоичных данных подписи.
//
// Параметры:
//  ДвоичныеДанныеПодписи - ДвоичныеДанные - подпись.
//
// Возвращаемое значение:
//  Дата, Неопределено - дата установки.
//
Функция ДатаУстановкиПодписи(ДвоичныеДанныеПодписи) Экспорт
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
	ДвоичныеДанныеПодписи.Записать(ИмяВременногоФайла);
	ЧтениеТекста = Новый ЧтениеТекста(ИмяВременногоФайла);
	Символ = ЧтениеТекста.Прочитать(1);
	Пока Символ <> Неопределено Цикл
		Если КодСимвола(Символ) = 15 Тогда
			Символ = ЧтениеТекста.Прочитать(2);
			Если КодСимвола(Символ, 1) = 23 И КодСимвола(Символ, 2) = 13 Тогда
				ДатаПодписания = ЧтениеТекста.Прочитать(12);
				ДатаПодписиНайдена = Истина;
				ЧтениеТекста.Закрыть();
				УдалитьФайлы(ИмяВременногоФайла);
				Возврат МестноеВремя(Дата("20" + ДатаПодписания));
			КонецЕсли;
		КонецЕсли;
		Символ = ЧтениеТекста.Прочитать(1);
	КонецЦикла;
	
	ЧтениеТекста.Закрыть();
	УдалитьФайлы(ИмяВременногоФайла);
	Возврат Неопределено;

КонецФункции

// Формирует данные подписи объекта
//
// Параметры
//  МенеджерКриптографии  - МенеджерКриптографии - менеджер криптографии
//  ОбъектДляПодписиСсылка  - любая ссылка - ссылка на подписываемый объект
//  ДвоичныеДанные  - ДвоичныеДанные - двоичные данные подписи
//  СтруктураПараметровПодписи  - Структура - информация о подписи - выбранный сертификат, пароль, комментарий
//
// Возвращаемое значение:
//   Структура   - данные для занесения в табличную часть ЭП
Функция СформироватьДанныеПодписи(МенеджерКриптографии, ОбъектДляПодписиСсылка, ДвоичныеДанные, СтруктураПараметровПодписи) Экспорт
	
	МенеджерКриптографии.ПарольДоступаКЗакрытомуКлючу = СтруктураПараметровПодписи.ПарольПользователя;
	ДатаПодписи = Дата('00010101');
	
	НоваяПодписьДвоичныеДанные = МенеджерКриптографии.Подписать(ДвоичныеДанные, СтруктураПараметровПодписи.Сертификат);
	
	Отпечаток = Base64Строка(СтруктураПараметровПодписи.Сертификат.Отпечаток);
	КомуВыданСертификат = ЭлектроннаяПодписьКлиентСервер.ПредставлениеСубъекта(СтруктураПараметровПодписи.Сертификат);
	ДвоичныеДанныеСертификата = СтруктураПараметровПодписи.Сертификат.Выгрузить();
	
	ДанныеПодписи = Новый Структура;
	ДанныеПодписи.Вставить("ОбъектСсылка",               ОбъектДляПодписиСсылка);
	ДанныеПодписи.Вставить("Отпечаток",                  Отпечаток);
	ДанныеПодписи.Вставить("ДатаПодписи",                ДатаПодписи);
	ДанныеПодписи.Вставить("Комментарий",                СтруктураПараметровПодписи.Комментарий);
	ДанныеПодписи.Вставить("ИмяФайлаПодписи",            "");
	ДанныеПодписи.Вставить("КомуВыданСертификат",        КомуВыданСертификат);
	ДанныеПодписи.Вставить("АдресФайла",                 "");
	ДанныеПодписи.Вставить("Подпись",                    НоваяПодписьДвоичныеДанные);
	ДанныеПодписи.Вставить("Сертификат",                 ДвоичныеДанныеСертификата);
	
	Возврат ДанныеПодписи;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Дерево разбора

// Только для внутреннего использования
Функция ЗначениеРеквизитаСтрокиДереваРазбора(ДеревоРазбора, СтрокаДерева, ПутьКРеквизиту) Экспорт
	
	ПозТочки = СтрНайти(ПутьКРеквизиту, ".");
	Если ПозТочки > 0 Тогда
		ИмяГлавногоРеквизита     = Лев(ПутьКРеквизиту, ПозТочки - 1);
		ИмяПодчиненногоРеквизита = Прав(ПутьКРеквизиту, СтрДлина(ПутьКРеквизиту) - ПозТочки);
	Иначе
		ИмяГлавногоРеквизита     = ПутьКРеквизиту;
		ИмяПодчиненногоРеквизита = "";
	КонецЕсли;
	
	ГлавныйРеквизит = СтрокаДерева.Строки.Найти(ИмяГлавногоРеквизита, "Реквизит");
	
	Если ГлавныйРеквизит <> Неопределено Тогда
		ЗначениеГлавногоРеквизита = ГлавныйРеквизит.ЗначениеРеквизита;
		Если ИмяПодчиненногоРеквизита <> "" Тогда
			СтрокаПоСсылке = Неопределено;
			Если ЭтоСсылочноеЗначениеДереваРазбора(ДеревоРазбора, ЗначениеГлавногоРеквизита, СтрокаПоСсылке) Тогда
				Возврат ЗначениеРеквизитаСтрокиДереваРазбора(ДеревоРазбора, СтрокаПоСсылке, ИмяПодчиненногоРеквизита);
			КонецЕсли;
			
			// Нет возможности получить значение подчиненного реквизита.
			Возврат Неопределено;
		Иначе
			// Не требуется получать значение подчиненного реквизита.
			Возврат ЗначениеГлавногоРеквизита
		КонецЕсли;
	Иначе
		// Нет такого реквизита.
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

Функция ЭтоСсылочноеЗначениеДереваРазбора(ДеревоРазбора, Значение, СтрокаПоСсылке = Неопределено)
	
	ЗначениеСтрокой = Строка(Значение);
	
	Если СтрНайти(ЗначениеСтрокой, "_") > 0 Тогда
		СтрокаПоСсылке =  ДеревоРазбора.Строки.Найти(ЗначениеСтрокой, "ИндексСтроки", Истина);
	КонецЕсли;
	
	Возврат ?(СтрокаПоСсылке = Неопределено, Ложь, Истина);
	
КонецФункции

// Создает пустой объект ДереваРазбора
//
// Возвращаемое значение:
//   ДеревоЗначений - пустое дерево с колонками
//
Функция ИнициализироватьДеревоРазбора() Экспорт
	
	ДеревоРазбора = Новый ДеревоЗначений;
	ДеревоРазбора.Колонки.Добавить("ТипОбъекта");
	ДеревоРазбора.Колонки.Добавить("СсылкаНаОбъект");
	ДеревоРазбора.Колонки.Добавить("ОписаниеТипа");
	ДеревоРазбора.Колонки.Добавить("ИндексСтроки");
	ДеревоРазбора.Колонки.Добавить("Реквизит");
	ДеревоРазбора.Колонки.Добавить("ЗначениеРеквизита");
	ДеревоРазбора.Колонки.Добавить("ОписаниеОбъекта");
	ДеревоРазбора.Колонки.Добавить("ВидЭД");
	ДеревоРазбора.Колонки.Добавить("ИД");
	ДеревоРазбора.Колонки.Добавить("НаправлениеЭД");
	ДеревоРазбора.Колонки.Добавить("ДопДанные");
	
	Возврат ДеревоРазбора;
	
КонецФункции

// Находит или создает новый тип в дереве разбора
//
// Параметры:
//    ДеревоРазбора - ДеревоЗначений - исходное дерево значений
//    ЗначениеТипаОбъекта - Произвольный - искомый тип объекта
//
// Возвращаемое значение:
//  СтрокаДереваЗначений - найденая или созданная строка
//
Функция НайтиСоздатьТипОбъектаВДеревеРазбора(ДеревоРазбора, ЗначениеТипаОбъекта) Экспорт
	
	НайденнаяСтрока = ДеревоРазбора.Строки.Найти(ЗначениеТипаОбъекта, "ТипОбъекта");
	Если НайденнаяСтрока = Неопределено Тогда
		НайденнаяСтрока = ДеревоРазбора.Строки.Добавить();
		НайденнаяСтрока.ТипОбъекта = ЗначениеТипаОбъекта;
		НайденнаяСтрока.ИндексСтроки = Строка(ДеревоРазбора.Строки.Индекс(НайденнаяСтрока));
	КонецЕсли;
	
	Возврат НайденнаяСтрока;
	
КонецФункции

// только для внутреннего использования
Процедура ДобавитьРеквизитШапкиОбъекта(СтрокаЭлементов, ИмяРеквизита, ЗначениеРеквизита, СсылкаНаОбъект = Неопределено) Экспорт
	
	НовСтрока = СтрокаЭлементов.Строки.Добавить();
	НовСтрока.Реквизит = ИмяРеквизита;
	НовСтрока.ЗначениеРеквизита = ЗначениеРеквизита;
	Если СсылкаНаОбъект <> Неопределено Тогда
		НовСтрока.СсылкаНаОбъект = СсылкаНаОбъект;
	КонецЕсли;
	
КонецПроцедуры

// Только для внутреннего использования
Процедура ДобавитьРеквизитыТЧОбъекта(СтрокаЭлементов, ИмяТЧ, СписокРеквизитов) Экспорт
	
	// Добавить в реквизиты ТЧ ОбменСКонтрагентами
	НовСтрока          = СтрокаЭлементов.Строки.Добавить();
	НовСтрока.Реквизит = ИмяТЧ;
	Для Каждого ТекЭлСписка Из СписокРеквизитов Цикл
		НовСтрокаТЧ                   = НовСтрока.Строки.Добавить();
		НовСтрокаТЧ.Реквизит          = ТекЭлСписка.Представление;
		НовСтрокаТЧ.ЗначениеРеквизита = ТекЭлСписка.Значение;
	КонецЦикла;
	
КонецПроцедуры

// Только для внутреннего использования
Процедура ДобавитьДопРеквизиты(СтрокаДереваРазбора, ДопРеквизиты, ДеревоРазбора, Отказ = Ложь) Экспорт
	
	Для Каждого ТекЭл Из ДопРеквизиты Цикл
		
		Если НЕ ТипЗнч(ТекЭл.Значение) = Тип("ОбъектXDTO") Тогда
					
			Если ЗначениеЗаполнено(ТекЭл.Значение) Тогда
				Если ТипЗнч(ТекЭл.Значение) = Тип("Массив") И НЕ ТекЭл.Ключ = "ЗначенияСвойств" И НЕ ТекЭл.Ключ = "Картинки" Тогда
					Для Каждого ТекЭлМассива Из ТекЭл.Значение Цикл
						Если ТипЗнч(ТекЭлМассива) = Тип("Структура") Тогда
							ДобавитьДопРеквизиты(СтрокаДереваРазбора, ТекЭлМассива, ДеревоРазбора, Отказ);
						КонецЕсли;
					КонецЦикла;
				Иначе
					// Поищем, возможно уже есть такой реквизит с таким же значением.
					НайденнаяСтрока = СтрокаДереваРазбора.Строки.Найти(ТекЭл.Ключ, "Реквизит", Истина);
					Если НайденнаяСтрока <> Неопределено И НайденнаяСтрока.ЗначениеРеквизита = ТекЭл.Значение Тогда
						Продолжить;
					КонецЕсли;
					
					НовСтрока = СтрокаДереваРазбора.Строки.Добавить();
					НовСтрока.Реквизит          = ТекЭл.Ключ;
					НовСтрока.ЗначениеРеквизита = ТекЭл.Значение;
					// Если ИндексСтроки, то попытка найти СсылкуНаОбъект.
					Если ТипЗнч(НовСтрока.ЗначениеРеквизита) = Тип("Строка") Тогда
						НайденнаяСтрока = ДеревоРазбора.Строки.Найти(НовСтрока.ЗначениеРеквизита, "ИндексСтроки", Истина);
						Если НайденнаяСтрока <> Неопределено Тогда
							Если ЗначениеЗаполнено(НайденнаяСтрока.СсылкаНаОбъект) Тогда
								НовСтрока.СсылкаНаОбъект = НайденнаяСтрока.СсылкаНаОбъект;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Определяет тип объекта по текстовому представлению.
//
// Параметры:
//  ОписаниеТипаОбъекта - строка, текстовое представление типа объекта.
//
// Возвращаемое значение;
//  Строка - Тип справочника
//
Функция ТипОбъекта(ОписаниеТипаОбъекта) Экспорт
	
	ТипОбъекта = Неопределено;
	
	ИмяПрикладногоСправочника = ЭлектронноеВзаимодействиеСлужебныйПовтИсп.ИмяПрикладногоСправочника(ОписаниеТипаОбъекта);
	Если ЗначениеЗаполнено(ИмяПрикладногоСправочника) Тогда
		ТипОбъекта = "СправочникСсылка." + ИмяПрикладногоСправочника;
	КонецЕсли;
	
	Возврат ТипОбъекта;
	
КонецФункции

// Только для внутреннего использования
Функция ЗначениеРеквизитаВДереве(ДеревоДанных, ПолныйПуть, СообщатьОбОшибке = Истина) Экспорт
	
	НайденнаяСтрока = ДеревоДанных.Строки.Найти(ПолныйПуть, "ПолныйПуть", Истина);
	Если НайденнаяСтрока <> Неопределено Тогда
		Возврат НайденнаяСтрока.Значение;
	ИначеЕсли СообщатьОбОшибке Тогда
		ТекстСообщения = НСтр("ru='Не найдено поле в дереве данных по полному пути <%1>';uk='Не знайдено поле в дереві даних за повного шляху <%1>'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстСообщения, ПолныйПуть);
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения);
	КонецЕсли;
	
КонецФункции

// Только для внутреннего использования
Процедура ДобавитьЗначениеВДерево(ДеревоДанных, ИмяРеквизита, ЗначениеРеквизита) Экспорт
	
	НовСтрока = ДеревоДанных.Строки.Добавить();
	НомерУровня = СтрЧислоВхождений(ИмяРеквизита, ".") + 1;
	НовСтрока.ПолныйПуть = ИмяРеквизита;
	НовСтрока["Уровень" + НомерУровня] = ЭлектронноеВзаимодействие.НазваниеКолонки(ИмяРеквизита);
	НовСтрока.Значение = ЗначениеРеквизита;

КонецПроцедуры

// Проверяет заполнение обязательных реквизитов дерева
// Параметры:
//  ДеревоДанных - деревоЗначений - дерево с данными.
//  ТекстОшибки - Строка - содержит текст ошибки
//
Процедура ПроверитьЗаполнениеОбязательныхРеквизитовРекурсивно(ДеревоДанных, ТекстОшибки, ЭтоТаблица = Ложь, НомерСтроки = Неопределено) Экспорт
	
	// Если в дереве есть поле ТестОшибки значит на этапе формирования дерева возникли ошибки
	// например, не сопоставлена номенклатура с номенклатурой поставщика.
	ТекстОшибкиСопоставления = ЗначениеРеквизитаВДереве(ДеревоДанных, "ТекстОшибки", Ложь);
	Если ЗначениеЗаполнено(ТекстОшибкиСопоставления) Тогда
		ТекстОшибки = ТекстОшибкиСопоставления;
		Возврат;
	КонецЕсли;
	
	Для Каждого Строка Из ДеревоДанных.Строки Цикл
		
		Если Строка.Обязательное = "Да" И Не ЗначениеЗаполнено(Строка.Значение)
										И Не ТипЗнч(Строка.Значение) = Тип("Число") Тогда
			ПрикладноеПредставление = ЭлектронноеВзаимодействиеСлужебныйПовтИсп.ПрикладноеПредставлениеРеквизита(Строка.КодПредставления);
			Если Не ЗначениеЗаполнено(ПрикладноеПредставление) Тогда
				ПрикладноеПредставление = СтрЗаменить(Строка.ПолныйПуть, ".", " - ");
			КонецЕсли;
			Если ЭтоТаблица Тогда
				ШаблонОшибки = НСтр("ru='Не заполнено обязательное поле таблицы: ""%1."" в строке %2';uk='Не заповнено обов''язкове поле таблиці ""%1."" в рядку %2'");
				ТекстОшибки = ТекстОшибки
							+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонОшибки, ПрикладноеПредставление, НомерСтроки)
							+ Символы.ПС;
			Иначе
				ШаблонОшибки = НСтр("ru='Не заполнено обязательное поле: ""%1.""';uk='Не заповнено обов''язкове поле: ""%1.""'");
				ТекстОшибки = ТекстОшибки
							+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонОшибки, ПрикладноеПредставление)
							+ Символы.ПС;
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		
		Если Строка.Признак = "Таблица" И (ТипЗнч(Строка.Значение) = Тип("Число") И Строка.Значение > 0 ИЛИ Строка.Обязательное = "Да")Тогда
			Для Каждого СтрокаТаблицы Из Строка.Строки Цикл
				ПроверитьЗаполнениеОбязательныхРеквизитовРекурсивно(СтрокаТаблицы, ТекстОшибки, Истина, СтрокаТаблицы.Значение);
			КонецЦикла
		ИначеЕсли Строка.Признак = "Выбор" И Строка.Обязательное = "Да" Тогда
			ПроверяемаяСтрока = Строка.Строки.Найти(Строка.ПолныйПуть + "." + Строка.Значение, "ПолныйПуть");
			Если ЗначениеЗаполнено(ПроверяемаяСтрока) Тогда
				ПроверитьЗаполнениеОбязательныхРеквизитовРекурсивно(ПроверяемаяСтрока, ТекстОшибки);
			Иначе
				ПрикладноеПредставление = ЭлектронноеВзаимодействиеСлужебныйПовтИсп.ПрикладноеПредставлениеРеквизита(Строка.КодПредставления);
				Если Не ЗначениеЗаполнено(ПрикладноеПредставление) Тогда
					ПрикладноеПредставление = СтрЗаменить(Строка.ПолныйПуть, ".", " - ");
				КонецЕсли;
				ШаблонОшибки = НСтр("ru='Не заполнено обязательное поле: ""%1.""';uk='Не заповнено обов''язкове поле: ""%1.""'");
				ТекстОшибки = ТекстОшибки
							+ СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонОшибки, ПрикладноеПредставление)
							+ Символы.ПС;
			КонецЕсли;
		ИначеЕсли Строка.Признак = "Группа" И Строка.Значение = Истина И Строка.Строки.Количество() > 0 Тогда
			ПроверитьЗаполнениеОбязательныхРеквизитовРекурсивно(Строка, ТекстОшибки);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Только для внутреннего использования
Процедура ЗаполнитьВидыЭДДляСертификатаЭППередЗаписью(Источник, Отказ) Экспорт
	
	Если Источник.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	СсылкаНаОбъект = Источник.Ссылка;
	Если СсылкаНаОбъект.Пустая() Тогда
		СсылкаНаОбъект = Источник.ПолучитьСсылкуНового();
		Если СсылкаНаОбъект.Пустая() Тогда
			СсылкаНаОбъект = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Источник.Ссылка).ПолучитьСсылку();
			Источник.УстановитьСсылкуНового(СсылкаНаОбъект);
		КонецЕсли;
		РегистрыСведений.ПодписываемыеВидыЭД.СохранитьПодписываемыеВидыЭД(СсылкаНаОбъект);
	КонецЕсли;

КонецПроцедуры

// Скрытие областей табличного документа.
//
// Параметры:
//  ТабличныйДокумент	 - ТабличныйДокумент - табличный документ, где скрываются области.
//  ИмяОбласти			 - Строка - Имена скрываемых областей через запятую.
//  ТипСмещения			 - ТипСмещенияТабличногоДокумента - тип смещения удалемой области.
//
Процедура СкрытьОбластиТабличногоДокумента(ТабличныйДокумент, ИменаОбластей, Знач ТипСмещения = Неопределено) Экспорт
	
	Если ТипСмещения = Неопределено Тогда
		ТипСмещения = ТипСмещенияТабличногоДокумента.ПоГоризонтали;
	КонецЕсли;
	
	Если ТипЗнч(ИменаОбластей) <> Тип("Массив") Тогда
		Области = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов(ИменаОбластей, ",");
	КонецЕсли;
	
	Для каждого ИмяОбласти Из Области Цикл
		
		ЕстьОбластьДД = ТабличныйДокумент.Области.Найти(СокрЛП(ИмяОбласти));
		
		Если ЕстьОбластьДД <> Неопределено Тогда
			ОбластьШапки = ТабличныйДокумент.Области.Найти("Шапка");
			ОбластьТаблицы = ТабличныйДокумент.Область(ИмяОбласти);
			
			Верх = ?(ОбластьТаблицы.Лево = 0 И ОбластьТаблицы.Право = 0 ИЛИ ОбластьШапки = Неопределено,
				ОбластьТаблицы.Верх, ОбластьШапки.Низ + 1);
				
			Если ТипСмещения = ТипСмещенияТабличногоДокумента.ПоГоризонтали Тогда
				УдаляемаяОбласть = ТабличныйДокумент.Область(Верх, ОбластьТаблицы.Лево,
					ТабличныйДокумент.ВысотаТаблицы, ОбластьТаблицы.Право);
			ИначеЕсли ТипСмещения = ТипСмещенияТабличногоДокумента.БезСмещения Тогда 
				УдаляемаяОбласть = ТабличныйДокумент.Область(Верх, ОбластьТаблицы.Лево,
					ОбластьТаблицы.Низ, ОбластьТаблицы.Право);
				Если ИмяОбласти = "ИдентификаторДокумента" Тогда
					ТипСмещения = ТипСмещенияТабличногоДокумента.ПоГоризонтали;	
				КонецЕсли;
			Иначе
				Низ = ТабличныйДокумент.ВысотаТаблицы;
				УдаляемаяОбласть = ТабличныйДокумент.Область(Верх, , Низ,);
			КонецЕсли; 
				
			ТабличныйДокумент.УдалитьОбласть(УдаляемаяОбласть, ТипСмещения);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция НадоЗарегистрироватьОбъект(Источник, ОбъектМетаданных)
	
	ИмяОбъекта = ОбъектМетаданных.ПолноеИмя();
	ТаблицаРеквизитовРегистрации = ЭлектронноеВзаимодействиеСлужебныйПовтИсп.ПолучитьТаблицуКлючевыхРеквизитовОбъекта(ИмяОбъекта);
	
	Если ТаблицаРеквизитовРегистрации.Количество() = 0 Тогда
		
		// Если перечень реквизитов не задан, то считаем, что объект модифицирован всегда
		Возврат Истина;
	КонецЕсли;
	
	Для Каждого СтрокаТаблицыРеквизитовРегистрации Из ТаблицаРеквизитовРегистрации Цикл
		
		ЕстьИзмененияВерсийОбъектов = ОпределитьИзмененияВерсийОбъекта(Источник, СтрокаТаблицыРеквизитовРегистрации);
		
		Если ЕстьИзмененияВерсийОбъектов Тогда
			
			Возврат Истина;
		КонецЕсли;
		
	КонецЦикла;
	
	// Если дошли до конца, то объект не изменился по реквизитам регистрации;
	// Регистрация не нужна
	Возврат Ложь;
	
КонецФункции

Функция ОпределитьИзмененияВерсийОбъекта(Объект, СтрокаТаблицыРеквизитовРегистрации)
	
	Если ПустаяСтрока(СтрокаТаблицыРеквизитовРегистрации.ИмяТабличнойЧасти) Тогда
		
		ТаблицаРеквизитовРегистрацииВерсияОбъектаДоИзменения = ПолучитьТаблицуРеквизитовРегистрацииШапкиДоИзменения(Объект,
			СтрокаТаблицыРеквизитовРегистрации);
		ТаблицаРеквизитовРегистрацииВерсияОбъектаПослеИзменения = ПолучитьТаблицуРеквизитовРегистрацииШапкиПослеИзменения(
			Объект, СтрокаТаблицыРеквизитовРегистрации);
	Иначе
		
		ТаблицаРеквизитовРегистрацииВерсияОбъектаДоИзменения = ПолучитьТаблицуРеквизитовРегистрацииТабличнойЧастиДоИзменения(
			Объект, СтрокаТаблицыРеквизитовРегистрации);
		ТаблицаРеквизитовРегистрацииВерсияОбъектаПослеИзменения = ПолучитьТаблицуРеквизитовРегистрацииТабличнойЧастиПослеИзменения(
			Объект, СтрокаТаблицыРеквизитовРегистрации);
	КонецЕсли;
	
	Возврат НЕ ТаблицыРеквизитовОбъектовОдинаковые(ТаблицаРеквизитовРегистрацииВерсияОбъектаДоИзменения,
												   ТаблицаРеквизитовРегистрацииВерсияОбъектаПослеИзменения,
												   СтрокаТаблицыРеквизитовРегистрации.РеквизитыОбъекта);
	
КонецФункции

// Проверяет переданные таблицы реквизитов на совпадения.
//
// Параметры:
//  Таблица1 - ТаблицаЗначений - первая таблица проверки, реквизиты, которые надо проверить на совпадение.
//  Таблица2 - ТаблицаЗначений - вторая таблица проверки.
//  РеквизитыОбъекта - Строка - реквизиты, перечисленные через запятую.
//  ДопПараметры - Структура - структура дополнительных параметров, по которым надо проводить сравнение.
//
Функция ТаблицыРеквизитовОбъектовОдинаковые(Таблица1, Таблица2, РеквизитыОбъекта, ДопПараметры = Неопределено)
	
	ДобавитьИтераторТаблице(Таблица1, +1);
	ДобавитьИтераторТаблице(Таблица2, -1);
	
	ТаблицаРезультат = Таблица1.Скопировать();
	
	ОбщегоНазначенияКлиентСервер.ДополнитьТаблицу(Таблица2, ТаблицаРезультат);
	
	ТаблицаРезультат.Свернуть(РеквизитыОбъекта, "ИтераторТаблицыРеквизитовОбъекта");
	
	КоличествоОдинаковыхСтрок = ТаблицаРезультат.НайтиСтроки(Новый Структура("ИтераторТаблицыРеквизитовОбъекта", 0)).Количество();
	
	КоличествоСтрокТаблицы = ТаблицаРезультат.Количество();
	ПризнакСовпадения = КоличествоОдинаковыхСтрок = КоличествоСтрокТаблицы;
	
	Если НЕ ПризнакСовпадения И ЗначениеЗаполнено(ДопПараметры) Тогда
		Если ДопПараметры.Свойство("ИмяТабличнойЧасти") Тогда
			ИмяТабличнойЧасти = ДопПараметры.ИмяТабличнойЧасти;
		КонецЕсли;
		Если ДопПараметры.Свойство("СтрокаДереваСравнения") Тогда
			СтрокаДереваСравнения = ДопПараметры.СтрокаДереваСравнения;
		КонецЕсли;
		
		Если ИмяТабличнойЧасти = "Шапка" Тогда
			
			НовСтрокаДереваМесто = СтрокаДереваСравнения.Строки.Добавить();
			НовСтрокаДереваМесто.Место = "Реквизиты шапки";
			Для Каждого ТекСтрокаТаб1 Из Таблица1 Цикл
				Для Каждого ТекКолонка Из Таблица1.Колонки Цикл
					ИмяКолонки = ТекКолонка.Имя;
					Если ИмяКолонки = "ИтераторТаблицыРеквизитовОбъекта" Тогда
						Продолжить;
					КонецЕсли;
					НайденнаяСтрокаТаб2 = Таблица2.Найти( - ТекСтрокаТаб1.ИтераторТаблицыРеквизитовОбъекта,
						"ИтераторТаблицыРеквизитовОбъекта");
					Если НЕ ЗначениеЗаполнено(НайденнаяСтрокаТаб2) 
						ИЛИ	НайденнаяСтрокаТаб2[ИмяКолонки] = ТекСтрокаТаб1[ИмяКолонки] Тогда
						Продолжить;
					КонецЕсли;
					НовСтрокаДереваРекв = НовСтрокаДереваМесто.Строки.Добавить();
					НовСтрокаДереваРекв.Реквизит  = ИмяКолонки;
					НовСтрокаДереваЗнч            = НовСтрокаДереваРекв.Строки.Добавить();
					НовСтрокаДереваЗнч.ЗначениеБД = ТекСтрокаТаб1[ИмяКолонки];
					НовСтрокаДереваЗнч.ЗначениеЭД = НайденнаяСтрокаТаб2[ИмяКолонки];
					
				КонецЦикла;
			КонецЦикла;
		Иначе
			НовСтрокаДереваМесто = СтрокаДереваСравнения.Строки.Добавить();
			НовСтрокаДереваМесто.Место = "Табличная часть <" + ИмяТабличнойЧасти + ">";
			НовСтрокаДереваРекв = НовСтрокаДереваМесто.Строки.Добавить();
			НовСтрокаДереваРекв.Реквизит = "<Изменена>";
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПризнакСовпадения;
	
КонецФункции

Процедура ДобавитьИтераторТаблице(Таблица, ЗначениеИтератора)
	
	Таблица.Колонки.Добавить("ИтераторТаблицыРеквизитовОбъекта");
	Таблица.ЗаполнитьЗначения(ЗначениеИтератора, "ИтераторТаблицыРеквизитовОбъекта");
	
КонецПроцедуры

Функция ПолучитьТаблицуРеквизитовРегистрацииТабличнойЧастиПослеИзменения(Объект, СтрокаТаблицыРеквизитовРегистрации)
	
	ТаблицаРеквизитовРегистрации = Объект[СтрокаТаблицыРеквизитовРегистрации.ИмяТабличнойЧасти].Выгрузить(,
		СтрокаТаблицыРеквизитовРегистрации.РеквизитыОбъекта);
		
	Возврат ТаблицаРеквизитовРегистрации;
	
КонецФункции

Функция ПолучитьТаблицуРеквизитовРегистрацииТабличнойЧастиДоИзменения(Объект, СтрокаТаблицыРеквизитовРегистрации)
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ "+ СтрокаТаблицыРеквизитовРегистрации.РеквизитыОбъекта + " ИЗ "
	+ СтрокаТаблицыРеквизитовРегистрации.ИмяОбъекта + "." + СтрокаТаблицыРеквизитовРегистрации.ИмяТабличнойЧасти
	+ " КАК ТекущийОбъектИмяТабличнойЧасти
	|ГДЕ
	|	ТекущийОбъектИмяТабличнойЧасти.Ссылка = &Ссылка";
	Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка);
	
	Возврат Запрос.Выполнить().Выгрузить();
		
КонецФункции

Функция ПолучитьТаблицуРеквизитовРегистрацииШапкиПослеИзменения(Объект, СтрокаТаблицыРеквизитовРегистрации)
	
	ТаблицаРеквизитовРегистрации = Новый ТаблицаЗначений;
	
	СтруктураРеквизитовРегистрации = СтрокаТаблицыРеквизитовРегистрации.СтруктураРеквизитовОбъекта;
	Для Каждого РеквизитРегистрации Из СтруктураРеквизитовРегистрации Цикл
		ТаблицаРеквизитовРегистрации.Колонки.Добавить(РеквизитРегистрации.Ключ);
	КонецЦикла;
	
	СтрокаТаблицы = ТаблицаРеквизитовРегистрации.Добавить();
	Для Каждого РеквизитРегистрации Из СтруктураРеквизитовРегистрации Цикл
		
		СтрокаТаблицы[РеквизитРегистрации.Ключ] = Объект[РеквизитРегистрации.Ключ];
	КонецЦикла;
	
	Возврат ТаблицаРеквизитовРегистрации;
	
КонецФункции

Функция ПолучитьТаблицуРеквизитовРегистрацииШапкиДоИзменения(Объект, СтрокаТаблицыРеквизитовРегистрации)

	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ " + СтрокаТаблицыРеквизитовРегистрации.РеквизитыОбъекта + " ИЗ "
	+ СтрокаТаблицыРеквизитовРегистрации.ИмяОбъекта + " КАК ТекущийОбъект
	|ГДЕ
	|	ТекущийОбъект.Ссылка = &Ссылка";
	Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка);
	
	Возврат Запрос.Выполнить().Выгрузить();
		
КонецФункции

#КонецОбласти