
#Область ПрограммныйИнтерфейс

#Область ПроцедурыИФункцииОбщегоНазначения

// Рассчитывает дату окончания периода
//
// Параметры:
// ДатаНачала          - дата начала, от которой будет рассчитана дата окончания периода
// Периодичность      - значение перечисления "Периодичность"
// КоличествоПериодов - количество повторов периода
//
// Возвращаемое значение:
// Дата
// Дата окончания периода
//
Функция РассчитатьДатуОкончанияПериода(ДатаНачала, Периодичность, КоличествоПериодов) Экспорт

	ОдинДень = 86400;

	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда 
		
		ДатаОкончания = ДатаНачала + ОдинДень * КоличествоПериодов;

	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда
		
		ДатаОкончания = ДатаНачала + ОдинДень * 7 * КоличествоПериодов;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада")) Тогда
		
		ДеньМесяца = День(ДатаНачала);
		НачМесяца = НачалоМесяца(ДатаНачала);
		Если ДеньМесяца <= 10 Тогда
			НомерДекады = 1;
		ИначеЕсли ДеньМесяца <= 20 Тогда
			НомерДекады = 2;
		Иначе
			НомерДекады = 3;
		КонецЕсли;
			
		НомерДекады = НомерДекады + КоличествоПериодов;
		
		Если НомерДекады > 0 Тогда
			Месяцев = Цел((НомерДекады-1)/3);
		Иначе
			Месяцев = -1 - Цел((-НомерДекады)/3);
		КонецЕсли;
			
		НомерДекады = НомерДекады - 3*Месяцев;
		Дт = ДобавитьМесяц(НачМесяца, Месяцев) + (НомерДекады-1) * 10 * ОдинДень;

		Если КоличествоПериодов > 0 Тогда
			ДатаОкончания = Дт;
		
		Иначе 
			ДеньМесяца = День(Дт);

			Если ДеньМесяца <= 10 Тогда
				ДатаОкончания = КонецДня(НачалоМесяца(Дт) + ОдинДень * 9);
			ИначеЕсли ДеньМесяца <= 20 Тогда
				ДатаОкончания = КонецДня(НачалоМесяца(Дт) + ОдинДень * 19);
			Иначе
				ДатаОкончания = КонецМесяца(Дт);
			КонецЕсли;
		КонецЕсли;

	ИначеЕсли (Периодичность= ПредопределенноеЗначение("Перечисление.Периодичность.Месяц")) Тогда
		
		ДатаОкончания = ДобавитьМесяц(ДатаНачала, КоличествоПериодов);

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал")) Тогда
		
		ДатаОкончания = ДобавитьМесяц(ДатаНачала, 3 * КоличествоПериодов);

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие")) Тогда
		
		ДатаОкончания = ДобавитьМесяц(ДатаНачала, 6 * КоличествоПериодов);

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год")) Тогда
		
		ДатаОкончания = ДобавитьМесяц(ДатаНачала, 12 * КоличествоПериодов);

	КонецЕсли;
			
	Возврат КонецДня(ДатаОкончания-ОдинДень);

КонецФункции // РассчитатьДатуОкончанияПериода()

// Рассчитывает ближайшую к указанной дату начала периода
//
// Параметры
// ДатаНачала          - дата, к которой будет рассчитана ближайшая дата начала периода
// Периодичность       - значение перечисления "Периодичность"
//
// Возвращаемое значение:
// Дата
// Дата начала ближайшего периода
//
Функция РассчитатьДатуНачалаБлижайшегоПериода(ДатаНачала, Периодичность) Экспорт
	
	ОдинДень = 86400;
	
	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда
		
		БлижайшаяДата = ДатаНачала;
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда
		
		Если ДатаНачала = НачалоНедели(ДатаНачала) Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = КонецНедели(ДатаНачала) + ОдинДень;
		КонецЕсли;
		
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада")) Тогда
		
		ДеньМесяца   = День(ДатаНачала);
		НачалоМесяца = НачалоМесяца(ДатаНачала);
		
		Если ДеньМесяца = 1 Или ДеньМесяца = 11 Или ДеньМесяца = 21 Тогда
			БлижайшаяДата = ДатаНачала;
		ИначеЕсли ДеньМесяца <= 10 Тогда // Первая декада
			БлижайшаяДата = НачалоМесяца + ОдинДень * 10;
		ИначеЕсли ДеньМесяца <= 20 Тогда // Вторая декада
			БлижайшаяДата = НачалоМесяца + ОдинДень * 20;
		Иначе // Третья декада
			БлижайшаяДата = КонецМесяца(НачалоМесяца) + ОдинДень;
		КонецЕсли;
		
	ИначеЕсли (Периодичность= ПредопределенноеЗначение("Перечисление.Периодичность.Месяц")) Тогда
		
		Если ДатаНачала = НачалоМесяца(ДатаНачала) Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = КонецМесяца(ДатаНачала) + ОдинДень;
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал")) Тогда
		
		Если ДатаНачала = НачалоКвартала(ДатаНачала) Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = КонецКвартала(ДатаНачала) + ОдинДень;
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие")) Тогда
		
		НачалоГода      = НачалоГода(ДатаНачала);
		НачалоПолугодия = ДобавитьМесяц(НачалоГода,6);
		
		Если ДатаНачала = НачалоПолугодия Или ДатаНачала = НачалоГода Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = ?(ДатаНачала > НачалоПолугодия, КонецГода(ДатаНачала) + ОдинДень, НачалоПолугодия);
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год")) Тогда
		
		Если ДатаНачала = НачалоГода(ДатаНачала) Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = КонецГода(ДатаНачала) + ОдинДень;
		КонецЕсли;

	КонецЕсли;
	
	Возврат БлижайшаяДата;
	
КонецФункции // РассчитатьДатуНачалаБлижайшегоПериода()

// Сравнивает значения переданных стуктур по указанным свойствам
// Параметры
// 	Стуктура1,Стуктура2 - сравниваемые стуктуры
//	Свойства - имена свойств, по которым нужно проводить сравнение, 
//			Тип - массив строк с именами свойств, или строка (именя перечисляются через запятую)
// Возвращаемое значение - ИСТИНА, если структуры равны по значениниям переданных свойств,
//							ЛОЖЬ - в противном случае
Функция СтруктурыРавны(Стуктура1, Стуктура2, Свойства) Экспорт
	Если ТипЗнч(Свойства) = Тип("Строка") Тогда
		МассивСвойств = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Свойства);
	Иначе
		МассивСвойств = Свойства
	КонецЕсли;
	
	Для Каждого СтрМас из МассивСвойств Цикл
		Если Стуктура1[СтрМас]<> Стуктура2[СтрМас] Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

// Возвращает структуру, содержащую ключи, имеющиеся в обеих исходных структурах.
//
Функция ПолучитьОбщиеКлючиСтруктур(Структура1, Структура2) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого КлючИЗначение Из Структура1 Цикл
		Если Структура2.Свойство(КлючИЗначение.Ключ) Тогда
			Результат.Вставить(КлючИЗначение.Ключ);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Проверяет структуру на наличие одного ключа или всех сразу из переданного набора
//
// Параметры:
// 		Структура - Структура - Проверяемая структура
// 		Ключи - Строка - Перечисленные через запятую ключи
// 		ПроверятьВсе - Булево - Признак необходимости проверки наличия всех ключей из набора
//
// Возвращаемое значение:
// 		Булево - Признак наличия одного или всех ключей набора в данной структуре
//
Функция СтруктураСодержитКлючи(Структура, Ключи, ПроверятьВсе=Ложь) Экспорт
	
	ТребуемыеКлючи = Новый Структура(Ключи);
	Для Каждого КлючИЗначение Из ТребуемыеКлючи Цикл
		Если ПроверятьВсе И Не Структура.Свойство(КлючИЗначение.Ключ) Тогда
			Возврат Ложь;
		КонецЕсли;
		Если Не ПроверятьВсе И Структура.Свойство(КлючИЗначение.Ключ) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПроверятьВсе;
	
КонецФункции

// Дополняет структуру приемник полями структуры источника
//
// Параметры:
// 		СтруктураПриемник - Структура - Структура, в которую необходимо скопировать поля
// 		СтруктураИсточник - Структура - Структура, из которой необходимо скопировать поля
// 		КопироватьЗначения - Булево - Истина, если надо копировать значения
//
Процедура ДополнитьСтруктуру(СтруктураПриемник, СтруктураИсточник, КопироватьЗначения=Ложь) Экспорт
	
	Для Каждого Элемент Из СтруктураИсточник Цикл
		СтруктураПриемник.Вставить(Элемент.Ключ, ?(КопироватьЗначения, Элемент.Значение, Неопределено));
	КонецЦикла;
	
КонецПроцедуры // ДополнитьСтруктуру()

// Возвращает период, увеличенный на количество периодов
//Параметры:
//БазоваяДата - дата, относительно которой рассчитывается период
//Периодичность - размер периода,
//КоличествоПериодов - количество периодов, на которое нужно расширить базовый.
//                     если = 0, то возвращается период, в котором находится базовая дата,
//                     если < 0, то возвращаются период, соответсвующий предыдущим периодам,
//                     если > 0, то возвращаются период, соответсвующий следующим периодам.
//
Функция РасширенныйПериод(БазоваяДата, Периодичность, КоличествоПериодов = 0) Экспорт

	ОдинДень = 86400;
	Период = Новый СтандартныйПериод;
	Период.Вариант = ВариантСтандартногоПериода.ПроизвольныйПериод;

	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда

		Период.ДатаНачала    = НачалоДня(БазоваяДата);
		Период.ДатаОкончания = КонецДня(БазоваяДата);

		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = Период.ДатаНачала + ОдинДень * КоличествоПериодов;
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = Период.ДатаОкончания + ОдинДень * КоличествоПериодов;
		КонецЕсли;

	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда

		Период.ДатаНачала    = НачалоНедели(БазоваяДата);
		Период.ДатаОкончания = КонецНедели(БазоваяДата);

		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = Период.ДатаНачала + ОдинДень * 7 * КоличествоПериодов;
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = Период.ДатаОкончания + ОдинДень * 7 * КоличествоПериодов;
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада")) Тогда

		ДеньМесяца = День(БазоваяДата);
		Если ДеньМесяца <= 10 Тогда
			НомерДекады = 1;
		ИначеЕсли ДеньМесяца <= 20 Тогда
			НомерДекады = 2;
		Иначе
			НомерДекады = 3;
		КонецЕсли;

		НомерДекады = НомерДекады + КоличествоПериодов;

		Если НомерДекады > 0 Тогда
			СмещениеМесяцев = Цел((НомерДекады-1)/3);
		Иначе
			СмещениеМесяцев = -1 - Цел((-НомерДекады)/3);
		КонецЕсли;

		НомерДекады = НомерДекады - 3*СмещениеМесяцев;
		СмещеннаяДата = ДобавитьМесяц(НачалоМесяца(БазоваяДата), СмещениеМесяцев) + (НомерДекады-1) * 10 * ОдинДень;
		ДеньМесяца = День(СмещеннаяДата);

		Если ДеньМесяца <= 10 Тогда
			Период.ДатаНачала    = НачалоМесяца(СмещеннаяДата);
			Период.ДатаОкончания = Период.ДатаНачала + ОдинДень * 9;
		ИначеЕсли ДеньМесяца <= 20 Тогда
			Период.ДатаНачала    = НачалоМесяца(СмещеннаяДата) + ОдинДень * 9;
			Период.ДатаОкончания = НачалоМесяца(СмещеннаяДата) + ОдинДень * 19;
		Иначе
			Период.ДатаНачала    = НачалоМесяца(СмещеннаяДата) + ОдинДень * 19;
			Период.ДатаОкончания = КонецМесяца(СмещеннаяДата);
		КонецЕсли;

	ИначеЕсли (Периодичность= ПредопределенноеЗначение("Перечисление.Периодичность.Месяц")) Тогда

		Период.ДатаНачала    = НачалоМесяца(БазоваяДата);
		Период.ДатаОкончания = КонецМесяца(БазоваяДата);

		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала = ДобавитьМесяц(Период.ДатаНачала, КоличествоПериодов);
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = ДобавитьМесяц(Период.ДатаОкончания, КоличествоПериодов);
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал")) Тогда

		Период.ДатаНачала    = НачалоКвартала(БазоваяДата);
		Период.ДатаОкончания = КонецКвартала(БазоваяДата);

		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = ДобавитьМесяц(Период.ДатаНачала, 3*КоличествоПериодов);
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = ДобавитьМесяц(Период.ДатаОкончания, 3*КоличествоПериодов);
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие")) Тогда

		Если Месяц(БазоваяДата) < 7 Тогда
			Период.ДатаНачала    = НачалоГода(БазоваяДата);
			Период.ДатаОкончания = КонецГода(ДобавитьМесяц(Период.ДатаНачала, - 6));
		Иначе
			Период.ДатаНачала    = ДобавитьМесяц(НачалоГода(БазоваяДата), 6);
			Период.ДатаОкончания = КонецГода(БазоваяДата);
		КонецЕсли;

		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = ДобавитьМесяц(Период.ДатаНачала, 6*КоличествоПериодов);
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = ДобавитьМесяц(Период.ДатаОкончания, 6*КоличествоПериодов);
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год")) Тогда

		Период.ДатаНачала    = НачалоГода(БазоваяДата);
		Период.ДатаОкончания = КонецГода(БазоваяДата);

		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = ДобавитьМесяц(Период.ДатаНачала, 12*КоличествоПериодов);
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = ДобавитьМесяц(Период.ДатаОкончания, 12*КоличествоПериодов);
		КонецЕсли;

	КонецЕсли;

	Возврат Период;

КонецФункции

// Проверяет строку с адресом электронной почты на корректность введенных данных
//
// Параметры
//  ПроверяемыйАдрес  - Строка - содержит строку с адресом электронной почты,
//                 		которую необходимо проверить.
// Возвращаемое значение:
//   Булево   		 - Ложь, если проверка закончилась успешно, Истина в обратном случае.
//
Функция ПроверитьЗаполнениеПочтовогоАдреса(ПроверяемыйАдрес) Экспорт
	
	Отказ = Ложь;
	АдресДляПроверки = ПроверяемыйАдрес;
	
	Попытка
		Результат =  ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСПочтовымиАдресами(АдресДляПроверки);	 
	Исключение 		
		Отказ = Истина;
	КонецПопытки;
	
	Если НЕ Отказ Тогда
		Если Результат.Количество() = 0 Тогда
			Отказ =  Истина;
		Иначе	
			АдресДляПроверки = Результат[0].Адрес;
			Если СтрЧислоВхождений(АдресДляПроверки,"@") <> 1 Тогда 
				Отказ = Истина;
			Иначе
				ДоменныйАдрес = Прав(АдресДляПроверки, СтрДлина(АдресДляПроверки) - СтрНайти(АдресДляПроверки,"@"));
				Если СтрДлина(ДоменныйАдрес) > 0 Тогда
					Если СтрЧислоВхождений(ДоменныйАдрес,".") < 1 ИЛИ Лев(ДоменныйАдрес,1) = "." ИЛИ Прав(ДоменныйАдрес,1) = "." Тогда
						Отказ = Истина;
					КонецЕсли;
				Иначе
					Отказ = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;	
	КонецЕсли;	
	
	Возврат Отказ;
	
КонецФункции // ПроверитьЗаполнениеПочтовогоАдреса() 

// Вычисляет значение идентификатора из строки соответствии с правилами
// именования идентификаторов
//
// Возвращаемое значение:
// Строка
// Идентификатор, соответствующий правилам именования идентификаторов
//
Функция ПолучитьИдентификатор(СтрНаименование) Экспорт
	
	Разделители	=  " .,+,-,/,*,?,=,<,>,(,)%!@#$%&*""№:;{}[]?()\|/`~'^_";
	
	Идентификатор = "";
	БылСпецСимвол = Ложь;
	
	Для НомСимвола = 1 По СтрДлина(СтрНаименование) Цикл
		
		Символ = Сред(СтрНаименование, НомСимвола, 1);
		
		Если СтрНайти(Разделители, Символ) <> 0 Тогда
			БылСпецСимвол = Истина;
		ИначеЕсли БылСпецСимвол Тогда
			БылСпецСимвол = Ложь;
			Идентификатор = Идентификатор + ВРег(Символ);
		Иначе
			Идентификатор = Идентификатор + Символ;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Идентификатор;
	
КонецФункции // ПолучитьИдентификатор()

// Заполняет все строки указанных колонок коллекции указанным значением
//
// Параметры:
// 		Коллекция - ДанныеФормыКоллекция - Коллекция для заполнения строк
// 		Значение - Значение для подстановки
// 		Колонки - Строка - Строка перечисленных через запятую имен колонок коллекции
//
Процедура ЗаполнитьЗначенияСвойствКоллекции(Коллекция, Значение, Колонки) Экспорт
	
	СтруктураЗаполнения = Новый Структура(Колонки);
	Для Каждого Колонка Из СтруктураЗаполнения Цикл
		СтруктураЗаполнения[Колонка.Ключ] = Значение;
	КонецЦикла;
	
	Для н = 0 По Коллекция.Количество() - 1 Цикл
		ЗаполнитьЗначенияСвойств(Коллекция[н], СтруктураЗаполнения);
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьЗначенияКолонокКоллекции()

// Используется для преобразования страниц саммари
//
// Параметры:
//  СтрокаКПреобразованию - Строка - Строка, из которой необходиомо удалить блок
//  СтрокаОграничивающая - Строка - ограчитель блока, который подлежит удалению
//
Процедура УдалитьИзСтрокиПодстроку(СтрокаКПреобразованию, СтрокаОграничивающая) Экспорт
	
	ИндексПервогоВхождения = СтрНайти(СтрокаКПреобразованию, СтрокаОграничивающая);
	ДлинаВходящейСтроки = СтрДлина(СтрокаКПреобразованию);
	ЛеваяЧасть =  ЛЕВ(СтрокаКПреобразованию, ИндексПервогоВхождения-1);
	ПраваяЧастьСтрокиКОбработке = Прав(СтрокаКПреобразованию, СтрДлина(СтрокаКПреобразованию) - ИндексПервогоВхождения-4);
	ИндексВторогоВхождения = СтрНайти(ПраваяЧастьСтрокиКОбработке, СтрокаОграничивающая);
	ПраваяЧасть = ПРАВ(ПраваяЧастьСтрокиКОбработке,СтрДлина(ПраваяЧастьСтрокиКОбработке) - ИндексВторогоВхождения -4);
	
	СтрокаКПреобразованию = ЛеваяЧасть +  ПраваяЧасть;
	
КонецПроцедуры

// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения
//
// Параметры:
//		ИсхСумма - распределяемая сумма
//		МассивКоэф - массив коэффициентов распределения
//		Точность - точность округления при распределении. Необязателен.
//
//	Возврат:
//		МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//			суммы в соответствии с весом коэффициента (из массива коэффициентов)
//          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2) Экспорт

	Если МассивКоэф.Количество() = 0 Или ИсхСумма = 0 Или ИсхСумма = Null Тогда
		Возврат Неопределено;
	КонецЕсли;

	ИндексМакс = 0;
	МаксЗнач   = 0;
	РаспрСумма = 0;
	СуммаКоэф  = 0;

	Для К = 0 По МассивКоэф.Количество() - 1 Цикл

		МодульЧисла = ?(МассивКоэф[К] > 0, МассивКоэф[К], - МассивКоэф[К]);

		Если МаксЗнач < МодульЧисла Тогда
			МаксЗнач = МодульЧисла;
			ИндексМакс = К;
		КонецЕсли;

		СуммаКоэф = СуммаКоэф + МассивКоэф[К];

	КонецЦикла;

	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;

	МассивСумм = Новый Массив(МассивКоэф.Количество());

	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		МассивСумм[К] = Окр(ИсхСумма * МассивКоэф[К] / СуммаКоэф, Точность, 1);
		РаспрСумма = РаспрСумма + МассивСумм[К];
	КонецЦикла;

	// Погрешности округления отнесем на коэффициент с максимальным весом
	Если Не РаспрСумма = ИсхСумма Тогда
		МассивСумм[ИндексМакс] = МассивСумм[ИндексМакс] + ИсхСумма - РаспрСумма;
	КонецЕсли;

	Возврат МассивСумм;

КонецФункции // РаспределитьПропорционально()

// Проверяет, что авторизован внешний пользователь
//
// Возвращаемое значение:
//   Булево   - Истина, если авторизован внешний пользователь. Ложь, в обратном случае
//
Функция АвторизованВнешнийПользователь() Экспорт

	Возврат ТипЗнч(ПользователиКлиентСервер.АвторизованныйПользователь()) =  Тип("СправочникСсылка.ВнешниеПользователи");

КонецФункции

// Функция формирует список значений, содержащий значения времени, рассчитанные
// с указанным интервалом
//Параметры:
//ТекущееЗначение - исходное значение времени
//Интервал - интервал, с которым необходимо заполнить список, по умолчанию час
//
Функция СписокВремени(Знач ТекущееЗначение = '00010101000000', Интервал = 3600) Экспорт
	
	НачалоРабочегоДня      = '00010101000000';
	ОкончаниеРабочегоДня   = '00010101235959';

	СписокВремен = Новый СписокЗначений;
	НачалоРабочегоДня = НачалоЧаса(НачалоДня(ТекущееЗначение) +
		Час(НачалоРабочегоДня) * 3600 +
		Минута(НачалоРабочегоДня)*60);
	ОкончаниеРабочегоДня = КонецЧаса(НачалоДня(ТекущееЗначение) +
		Час(ОкончаниеРабочегоДня) * 3600 +
		Минута(ОкончаниеРабочегоДня)*60);

	ВремяСписка = НачалоРабочегоДня;
	Пока НачалоЧаса(ВремяСписка) <= НачалоЧаса(ОкончаниеРабочегоДня) Цикл
		Если НЕ ЗначениеЗаполнено(ВремяСписка) Тогда
			ПредставлениеВремени = "00:00";
		Иначе
			ПредставлениеВремени = Формат(ВремяСписка,"ДФ=ЧЧ:мм");
		КонецЕсли;

		СписокВремен.Добавить(ВремяСписка, ПредставлениеВремени);

		ВремяСписка = ВремяСписка + Интервал;
	КонецЦикла;
	
	Возврат СписокВремен;
	
КонецФункции

// Функция преобразует строку к множественному числу
//
// Параметры: 
//  Слово1 - форма слова в ед числе      ("шкаф")
//  Слово2 - форма слова для числит 2-4  ("шкафа")
//  Слово3 - форма слова для числит 5-10 ("шкафов")
//  ЦелоеЧисло - целое число
//
// Возвращаемое значение:
//  строку - одну из строк в зависимости от параметра ЦелоеЧисло
//
// Описание:
//  Предназначена для формирования "правильной" подписи к числительным
//
Функция ФормаМножественногоЧисла(Слово1, Слово2, Слово3, Знач ЦелоеЧисло) Экспорт
	
	// Изменим знак целого числа, иначе отрицательные числа будут неправильно преобразовываться
	Если ЦелоеЧисло < 0 Тогда
		ЦелоеЧисло = -1 * ЦелоеЧисло;
	КонецЕсли;
	
	Если ЦелоеЧисло <> Цел(ЦелоеЧисло) Тогда 
		// для нецелых чисел - всегда вторая форма
		Возврат Слово2;
	КонецЕсли;
	
	// остаток
	Остаток = ЦелоеЧисло%10;
	Если (ЦелоеЧисло >10) И (ЦелоеЧисло<20) Тогда
		// для второго десятка - всегда третья форма
		Возврат Слово3;
	ИначеЕсли Остаток=1 Тогда
		Возврат Слово1;
	ИначеЕсли (Остаток>1) И (Остаток<5) Тогда
		Возврат Слово2;
	Иначе
		Возврат Слово3;
	КонецЕсли;

КонецФункции

// Определяет, является ли контрагент юридическим лицом
//
//Параметры:
//ЮридическоеФизическоеЛицо - Перечисления.ЮридическоеФизическоеЛицо - вид контрагента
//
// Возвращаемое значение:
//  Булево - Истина, если это юридическое лицо, Ложь в обратном случае.
//
Функция ЭтоЮрЛицо(ЮридическоеФизическоеЛицо) Экспорт
	
	Если ТипЗнч(ЮридическоеФизическоеЛицо) = Тип("ПеречислениеСсылка.ЮридическоеФизическоеЛицо") Тогда
		Возврат ЮридическоеФизическоеЛицо = ПредопределенноеЗначение("Перечисление.ЮридическоеФизическоеЛицо.ЮридическоеЛицо");
	Иначе
		Возврат ЮридическоеФизическоеЛицо = ПредопределенноеЗначение("Перечисление.ЮрФизЛицо.ЮрЛицо");
	КонецЕсли;

КонецФункции

// Возвращает слово в разных склонениях (в соответсвии с числом)
// Основное назначение - использование для склонения надписей единиц измерения в формах
// для различных числовых полей
//
// Параметры
//	Число - Число - число, определяет склонение
//	ЕдЧислоИменительный - Строка - единственное число именительный падеж. Например, "день" или "неделя"
//	ЕдЧислоРодительный - Строка - единственное число родительный падеж. Например, "дня" или "недели"
//	МнЧислоРодительный - Строка - множественное число родительный падеж. Например, "дней" или "недель"
//	Пол - Строка - м – мужской род (ж – женский род, с - средний род); 
//
// Возвращаемое значение:
//  СловоПрописью - Строка - слово в правильном склонении
//
Функция СклонениеСлова(ЧислоДляСклонения, ЕдЧислоИменительный, ЕдЧислоРодительный, МнЧислоРодительный, Пол) Экспорт
	
	СловоПрописью = "";
	ФорматнаяСтрока = "L = ru_RU";
	ПараметрыПредметаИсчиления = ЕдЧислоИменительный + ", " + ЕдЧислоРодительный + ", " + МнЧислоРодительный + ", " + Пол;
	
	СловоПрописью = ЧислоПрописью(ЧислоДляСклонения, ФорматнаяСтрока, ПараметрыПредметаИсчиления);
	
	Если СтрНайти(СловоПрописью, МнЧислоРодительный) Тогда
		СловоПрописью = МнЧислоРодительный;
	ИначеЕсли СтрНайти(СловоПрописью, ЕдЧислоРодительный) Тогда
		СловоПрописью = ЕдЧислоРодительный;
	ИначеЕсли СтрНайти(СловоПрописью, ЕдЧислоИменительный) Тогда
		СловоПрописью = ЕдЧислоИменительный;
	КонецЕсли;
	
	Возврат СловоПрописью;
	
КонецФункции

#КонецОбласти

#Область МетодыРаботыСРеквизитамиОбъектов

Функция ЕстьРеквизитОбъекта(Объект, ИмяРеквизита) Экспорт
	
	КлючУникальности   = Новый УникальныйИдентификатор;
	СтруктураРеквизита = Новый Структура(ИмяРеквизита, КлючУникальности);

	ЗаполнитьЗначенияСвойств(СтруктураРеквизита, Объект);
	
	Возврат СтруктураРеквизита[ИмяРеквизита] <> КлючУникальности;
	
КонецФункции

#КонецОбласти

#Область ВспомогательныеПроцедурыРаботыСОтчетами

// Устанавливает значение свойства элемента формы, если находит элемент на форме
//
// Параметры
//  ЭлементыФормы - ВсеЭлементыФормы - элементы формы, среди которых содержится искомый элемент.
//  ИмяЭлемента   - Строка - имя искомого элемента.
//  ИмяСвойства   - Строка - имя свойства, для которого будет устанавливаться значение.
//  Значение      - Произвольный - значение, которое будет установлено
//  УстанавливатьДляПодчиненных - Булево - установить аналогичное свойство для подчиненных элементов искомого элемента
//
Процедура УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства, Значение, УстанавливатьДляПодчиненных = Ложь) Экспорт
	
	Элемент = ЭлементыФормы.Найти(ИмяЭлемента);
	Если Элемент = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если НРег(ИмяСвойства) = "толькопросмотр"
		И ТипЗнч(Элемент) = Тип("КнопкаФормы") Тогда
			
		ИмяСвойстваЭлемента = "Доступность";
		ЗначениеСвойства    = НЕ Значение;
	Иначе
		ИмяСвойстваЭлемента = ИмяСвойства;
		ЗначениеСвойства    = Значение;
	КонецЕсли;
	
	Если Элемент[ИмяСвойстваЭлемента] <> ЗначениеСвойства Тогда
		Элемент[ИмяСвойстваЭлемента] = ЗначениеСвойства;
	КонецЕсли;
	
	ТипыЭлементовФормыСПодчиненнымиЭлементами = Новый ОписаниеТипов("УправляемаяФорма, ГруппаФормы, ТаблицаФормы");
	
	Если УстанавливатьДляПодчиненных И ТипыЭлементовФормыСПодчиненнымиЭлементами.СодержитТип(ТипЗнч(Элемент)) Тогда
		Для Каждого ПодчиненныйЭлемент Из Элемент.ПодчиненныеЭлементы Цикл
			УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ПодчиненныйЭлемент.Имя, ИмяСвойства, Значение, Истина);
		КонецЦикла;
 	КонецЕсли;
 	
КонецПроцедуры // УстановитьСвойствоЭлементаФорма()

// Устанавливает значение свойства элементов формы, если находит элемент на форме
//
// Параметры
//  ЭлементыФормы  - ВсеЭлементыФормы - элементы формы, среди которых содержится искомый элемент.
//  ИменаЭлементов - Массив, Строка, Структура - имена искомых элементов.
//  ИмяСвойства    - Строка - имя свойства, для которого будет устанавливаться значение.
//  Значение       - Произвольный - значение, которое будет установлено
//  УстанавливатьДляПодчиненных - Булево - установить аналогичное свойство для подчиненных элементов искомых элементов
//
Процедура УстановитьСвойствоЭлементовФормы(ЭлементыФормы, ИменаЭлементов, ИмяСвойства, Значение, УстанавливатьДляПодчиненных = Ложь) Экспорт
	
	Если ТипЗнч(ИменаЭлементов) = Тип("Массив") Тогда
		
		Для Каждого ИмяЭлемента Из ИменаЭлементов Цикл
			УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства, Значение, УстанавливатьДляПодчиненных);
		КонецЦикла
		
	Иначе
		
		Если ТипЗнч(ИменаЭлементов) = Тип("Строка") Тогда
			СтруктураИменЭлементов = Новый Структура(ИменаЭлементов);
		Иначе
			СтруктураИменЭлементов = ИменаЭлементов;
		КонецЕсли;
		
		Для Каждого ИмяЭлемента Из СтруктураИменЭлементов Цикл
			УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ИмяЭлемента.Ключ, ИмяСвойства, Значение, УстанавливатьДляПодчиненных);
		КонецЦикла
		
	КонецЕсли;
	
КонецПроцедуры // УстановитьСвойствоЭлементовФормы()

// Процедура заполняет массив непроверяемых реквизитов значениями, не используемыми при выбранной хозяйственной операции документа.
//
// Параметры:
//	МассивВсехРеквизитов - Массив - Массив всех реквизитов документа
//	МассивРеквизитовОперации - Массив - Массив реквизитов документа, которые относятся к хозяйственной операции документа
//	МассивНепроверяемыхРеквизитов - Массив реквизитов объекта, не требующих проверки
//
Процедура ЗаполнитьМассивНепроверяемыхРеквизитов(МассивВсехРеквизитов, МассивРеквизитовОперации, МассивНепроверяемыхРеквизитов) Экспорт
	
	Для Каждого ЭлементМассива Из МассивВсехРеквизитов Цикл
		
		// Если реквизит не используется для хозяйственной операции, исключаем данный реквизит из проверки.
		Если МассивРеквизитовОперации.Найти(ЭлементМассива) = Неопределено Тогда
			МассивНепроверяемыхРеквизитов.Добавить(ЭлементМассива);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьМассивНепроверяемыхРеквизитов()

// Сбрасывает служебный реквизит - ПодразделениеОбязательно, если его заполнение не требуется.
//
// Параметры:
// Товары - Булево - ДанныеФормыКоллекция - таблица формы Товары
// Подразделение - СправочникСсылка.СтруктураПредприятия - подразделение, реквизит Формы.
// ПодразделениеОбязательно - Булево - служебный реквизит Формы, определяет необходимость заполнения подразделения.
// НеУчитыватьОтмененныеСтроки - Булево.
//
// Возвращаемое значение:
// Булево.
//
Функция ПроверитьНеобходимостьОбновленияПодразделения(Товары,
	                                                    Подразделение,
	                                                    ПодразделениеОбязательно,
	                                                    НеУчитыватьОтмененныеСтроки=Ложь) Экспорт
	Если Товары.Количество() = 0 Или ЗначениеЗаполнено(Подразделение) Тогда
		ПодразделениеОбязательно = Ложь;
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции // ПроверитьНеобходимостьОбновленияПодразделения()

#КонецОбласти

#Область ВспомогательныеПроцедурыРаботыСПодсистемойКонтрольИАнализ

Функция ПолучитьПерсональныеНастройкиМонитораЦелевыхПоказателейПоУмолчанию() Экспорт
	
	НастройкиПоУмолчанию = Новый Структура;
	
	// порядок вывода показателей
	НастройкиПоУмолчанию.Вставить("ВариантГруппировкиПоказателей", "ПоВажности");
	НастройкиПоУмолчанию.Вставить("КоличествоКолонокМонитораПоказателей", 3);
	
	// Внешний вид показателей
	НастройкиПоУмолчанию.Вставить("РазмерДиаграмм", 1);
	НастройкиПоУмолчанию.Вставить("ВариантОтображенияДеталей", "ПоказыватьТолькоТекущееЗначение");
	
	// Обновление данных
	НастройкиПоУмолчанию.Вставить("ПериодАвтообновления", 15);
	
	Возврат НастройкиПоУмолчанию;
	
КонецФункции

#КонецОбласти

#Область ВспомогательныеПроцедурыРаботыСФормами

// Получить массив отмеченных элементов табличной части формы по массиву идентификаторов
// выделенных строк таблицы формы.
//
// Параметры:
//	Коллекция - ДанныеФормыКоллекция, табличная часть основного реквизита формы.
//	Идентификаторы - массив целых чисел, свойство ВыделенныеСтроки таблицы формы.
//
// Возвращаемое значение:
//	Массив - Массив выделенных строк
//
Функция ВыделенныеЭлементыКоллекции(Коллекция, Идентификаторы) Экспорт
	
	ВыделенныеЭлементы = Новый Массив;
	Для Каждого ИндексСтроки Из Идентификаторы Цикл
		ЭлементКоллекции = Коллекция.НайтиПоИдентификатору(ИндексСтроки);
		Если ЭлементКоллекции <> Неопределено Тогда
			ВыделенныеЭлементы.Добавить(ЭлементКоллекции);
		КонецЕсли;
	КонецЦикла;
	Возврат ВыделенныеЭлементы;
	
КонецФункции

// Устанавливается свойство ОтображениеПредупрежденияПриРедактировании элемента формы.
//
Процедура ОтображениеПредупрежденияПриРедактировании(Элемент, Отображать) Экспорт
	
	Если Отображать Тогда
		Элемент.ОтображениеПредупрежденияПриРедактировании = ОтображениеПредупрежденияПриРедактировании.Отображать;
	Иначе
		Элемент.ОтображениеПредупрежденияПриРедактировании = ОтображениеПредупрежденияПриРедактировании.НеОтображать;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ФункцииДляПоддержкиФормированияПечатныхФорм

// Возвращает заголовок документа в том виде, в котором его формирует платформа для представления ссылки на документ.
//
// Параметры
//  Шапка - Структура с ключами
//          Номер - строка или число - номер документа
//          Дата  - дата - дата документа
//  НазваниеДокумента - Строка - название документа (например, синоним объекта метаданных)
//
// Возвращаемое значение 
//  Строка - заголовок документа
//
Функция СформироватьЗаголовокДокумента(Шапка, знач НазваниеДокумента = "", знач КодЯзыка = "ru", УдалитьТолькоЛидирующиеНулиИзНомераОбъекта = Ложь, ПоДСТУ = Ложь) Экспорт
	
	Если Типзнч(КодЯзыка) = Тип("Булево") Тогда
		ВызватьИсключение НСтр("ru='Передано некорректное значение';uk='Передано некоректне значення'");
	КонецЕсли;
	
	ДанныеДокумента = Новый Структура("Номер,Дата,Представление");
	ЗаполнитьЗначенияСвойств(ДанныеДокумента, Шапка);
	
	// Если название документа не передано, получим название по представлению документа
	Если ПустаяСтрока(НазваниеДокумента) И ЗначениеЗаполнено(ДанныеДокумента.Представление) Тогда
		НазваниеДокумента = ПредставлениеОбъектаИзПредставленияСсылки(ДанныеДокумента);
	КонецЕсли;

	Если УдалитьТолькоЛидирующиеНулиИзНомераОбъекта Тогда
		НомерНаПечать = ПрефиксацияОбъектовКлиентСервер.УдалитьЛидирующиеНулиИзНомераОбъекта(ДанныеДокумента.Номер);
	Иначе 
		// кроме лидирующих нулей будут удалены также префикс организации и префикс информационной базы 
		НомерНаПечать = ПрефиксацияОбъектовКлиентСервер.ПолучитьНомерНаПечать(ДанныеДокумента.Номер);
	КонецЕсли;
	
	Если ПоДСТУ Тогда
		Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru='%1 № %2 от %3 г.';uk= '%1 № %2 від %3 р.'", КодЯзыка),
					ВРег(НазваниеДокумента), НомерНаПечать, Формат(ДанныеДокумента.Дата, "ДФ='дд ММММ гггг';Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка)));
	Иначе
		Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru='%1 № %2 от %3';uk= '%1 № %2 від %3'", КодЯзыка),
					НазваниеДокумента, НомерНаПечать, Формат(ДанныеДокумента.Дата, "ДЛФ=DD;Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка)));
	КонецЕсли;
	
КонецФункции

// Функция - Пример: представление объекта "Заказ клиента 00001 от 22.01.2014 0:00:00", функция вернет "Заказ клиента"
//
// Параметры:
//  ДанныеДокумента - Структура 
//		* Представление - Строка - представление ссылки
//		* Номер - Строка - номер документа
// Возвращаемое значение:
//   Строка - представление объекта
//
Функция ПредставлениеОбъектаИзПредставленияСсылки(Знач ДанныеДокумента) Экспорт 
	
	ПоложениеНомера = СтрНайти(ДанныеДокумента.Представление, ДанныеДокумента.Номер);
	
	Если ПоложениеНомера > 0 Тогда
        НазваниеДокумента = СокрЛП(Лев(ДанныеДокумента.Представление, ПоложениеНомера - 1));
	Иначе
		НазваниеДокумента = "";
	КонецЕсли;
	
	Возврат НазваниеДокумента;

КонецФункции

// Добавляет новый параметр в параметры выбора переданного элемента формы с сохранением ранее добавленных
//
// Параметры:
//  Элемент - элемент формы, имеющий свойство "ПараметрыВыбора"
//  ИмяПараметра - Строка - имя параметра, как оно задается в свойстве "ПараВыбора - Имя" без указания слова "Отбор."
//  ЗначениеПараметра - Произвольный - значения параметра выбора. Для единичного отбора передается само значения, для множественного - массив значений
//
Процедура ДобавитьПараметрВыбора(Элемент, ИмяПараметра, ЗначениеПараметра) Экспорт
	Если ТипЗнч(ЗначениеПараметра) = Тип("Массив") Тогда
		ЗначениеПараметраВыбора = Новый ФиксированныйМассив(ЗначениеПараметра);
	ИначеЕсли ТипЗнч(ЗначениеПараметра) = Тип("ФиксированныйМассив") Тогда
		ЗначениеПараметраВыбора = ЗначениеПараметра;
	Иначе
		ЗначениеПараметраВыбора = ЗначениеПараметра;
	КонецЕсли;
	
	Если СтрНайти(ИмяПараметра, "Отбор.") Тогда
		ИмяПараметраВыбора = ИмяПараметра;
	Иначе
		ИмяПараметраВыбора = "Отбор." + ИмяПараметра;
	КонецЕсли;
	
	Если ТипЗнч(Элемент) = Тип("ПолеНабораДанныхСхемыКомпоновкиДанных") Тогда
		ПараметрыВыбора = Элемент.ПараметрыРедактирования.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных("ПараметрыВыбора"));
		ПараметрыВыбора.Использование = Истина;
		
		ДобавляемыйПараметрВыбора = ПараметрыВыбора.Значение.Добавить();
		ДобавляемыйПараметрВыбора.Имя = ИмяПараметраВыбора;
		ДобавляемыйПараметрВыбора.Значение = ЗначениеПараметраВыбора;
	Иначе 
		ИсходныеПараметрыВыбора = Элемент.ПараметрыВыбора;
		
		ДобавляемыйПараметрВыбора = Новый ПараметрВыбора(ИмяПараметраВыбора, ЗначениеПараметраВыбора);
		
		МассивПараметровВыбора = Новый Массив(ИсходныеПараметрыВыбора);
		МассивПараметровВыбора.Добавить(ДобавляемыйПараметрВыбора);
		НовыеПараметрыВыбора = Новый ФиксированныйМассив(МассивПараметровВыбора);
		
		Элемент.ПараметрыВыбора = НовыеПараметрыВыбора;
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область ВыборПериодаИзСписка

Функция НачалоПериодаОтчета(ВидПериода, ДатаПериода) Экспорт
	
	НачалоПериода = ДатаПериода;
	
	Если ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Год") Тогда
		НачалоПериода = НачалоГода(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Полугодие") Тогда
		Если Месяц(ДатаПериода) > 6 Тогда
			НачалоПериода = Дата(Год(ДатаПериода), 7, 1);
		Иначе
			НачалоПериода = Дата(Год(ДатаПериода), 1, 1);
		КонецЕсли;
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Квартал") Тогда
		НачалоПериода = НачалоКвартала(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Месяц") Тогда
		НачалоПериода = НачалоМесяца(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Декада") Тогда
		Если День(ДатаПериода) <= 10 Тогда
			НачалоПериода = Дата(Год(ДатаПериода), Месяц(ДатаПериода), 1);
		ИначеЕсли День(ДатаПериода) > 10 И День(ДатаПериода) <= 20 Тогда
			НачалоПериода = Дата(Год(ДатаПериода), Месяц(ДатаПериода), 11);
		Иначе
			НачалоПериода = Дата(Год(ДатаПериода), Месяц(ДатаПериода), 21);
		КонецЕсли;
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Неделя") Тогда
		НачалоПериода = НачалоНедели(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.День") Тогда
		НачалоПериода = НачалоДня(ДатаПериода);
		
	КонецЕсли;
		
	Возврат НачалоПериода;
	
КонецФункции
 
Функция КонецПериодаОтчета(ВидПериода, ДатаПериода) Экспорт
	
	КонецПериода = ДатаПериода;
	
	Если ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Год") Тогда
		КонецПериода = КонецГода(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Полугодие") Тогда
		Если Месяц(ДатаПериода) > 6 Тогда
			КонецПериода = КонецГода(ДатаПериода);
		Иначе
			КонецПериода = КонецДня(Дата(Год(ДатаПериода), 6, 30));
		КонецЕсли;
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Квартал") Тогда
		КонецПериода = КонецКвартала(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Месяц") Тогда
		КонецПериода = КонецМесяца(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Декада") Тогда
		Если День(ДатаПериода) <= 10 Тогда
			КонецПериода = КонецДня(Дата(Год(ДатаПериода), Месяц(ДатаПериода), 10));
		ИначеЕсли День(ДатаПериода) > 10 И День(ДатаПериода) <= 20 Тогда
			КонецПериода = КонецДня(Дата(Год(ДатаПериода), Месяц(ДатаПериода), 20));
		Иначе
			КонецПериода = КонецМесяца(ДатаПериода);
		КонецЕсли;
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Неделя") Тогда
		КонецПериода = КонецНедели(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.День") Тогда
		КонецПериода = КонецДня(ДатаПериода);
		
	КонецЕсли;
		
	Возврат КонецПериода;
	
КонецФункции

Функция ПолучитьСписокПериодов(Знач НачалоПериода, Знач ВидПериода) Экспорт
	                                                                                                  
	СписокПериодов = Новый СписокЗначений;
	Если НачалоПериода = '00010101' Тогда
		Возврат Новый СписокЗначений;
	Иначе
		ЗначениеНачалоПериода = НачалоПериода;
	КонецЕсли;
	
	Если ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Год") Тогда
		ТекущийГод = Год(ЗначениеНачалоПериода);
		СписокПериодов.Добавить(Дата(ТекущийГод - 7, 1, 1), НСтр("ru='Предыдущие года';uk='Попередні роки'"));
		Для Сч = ТекущийГод - 3 По ТекущийГод + 3 Цикл
			СписокПериодов.Добавить(Дата(Сч, 1, 1), Формат(Сч, "ЧГ=0"));
		КонецЦикла;
		СписокПериодов.Добавить(Дата(ТекущийГод + 7, 1, 1), НСтр("ru='Последующие года';uk='Наступні роки'"));
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Полугодие") Тогда
		ТекущийГод = Год(ЗначениеНачалоПериода);
		СписокПериодов.Добавить(Дата(ТекущийГод - 2, 1, 1), Формат(ТекущийГод - 2, "ЧГ=0") + "...");
		Для Сч = ТекущийГод - 1 По ТекущийГод + 1 Цикл
			СписокПериодов.Добавить(Дата(Сч, 1, 1), НСтр("ru='I полугодие';uk='I півріччя'")  + " " + Формат(Сч, "ЧГ=0"));
			СписокПериодов.Добавить(Дата(Сч, 7, 1), НСтр("ru='II полугодие';uk='II півріччя'") + " " + Формат(Сч, "ЧГ=0"));
		КонецЦикла;
		СписокПериодов.Добавить(Дата(ТекущийГод + 2, 1, 1), Формат(ТекущийГод + 2, "ЧГ=0") + "...");
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Квартал") Тогда
		ТекущийГод = Год(ЗначениеНачалоПериода);
		СписокПериодов.Добавить(Дата(ТекущийГод - 2, 1, 1), Формат(ТекущийГод - 2, "ЧГ=0") + "...");
		Для Сч = ТекущийГод - 1 По ТекущийГод Цикл
			СписокПериодов.Добавить(Дата(Сч, 1, 1), НСтр("ru='I квартал';uk='I квартал'")   + " " + Формат(Сч, "ЧГ=0"));
			СписокПериодов.Добавить(Дата(Сч, 4, 1), НСтр("ru='II квартал';uk='II квартал'")  + " " + Формат(Сч, "ЧГ=0"));
			СписокПериодов.Добавить(Дата(Сч, 7, 1), НСтр("ru='III квартал';uk='III квартал'") + " " + Формат(Сч, "ЧГ=0"));
			СписокПериодов.Добавить(Дата(Сч, 10, 1),НСтр("ru='IV квартал';uk='IV квартал'")  + " " + Формат(Сч, "ЧГ=0"));
		КонецЦикла;
		СписокПериодов.Добавить(Дата(ТекущийГод + 1, 1, 1), Формат(ТекущийГод + 1, "ЧГ=0") + "...");
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Месяц") Тогда
		ТекущийГод = Год(ЗначениеНачалоПериода);
		СписокПериодов.Добавить(Дата(ТекущийГод - 1, 1, 1), Формат(ТекущийГод - 1, "ЧГ=0") + "...");
		Для Сч = 1 По 12 Цикл
			СписокПериодов.Добавить(Дата(ТекущийГод, Сч, 1), Формат(Дата(ТекущийГод, Сч, 1), "ДФ='MMMM yyyy'"));
		КонецЦикла;
		СписокПериодов.Добавить(Дата(ТекущийГод + 1, 1, 1), Формат(ТекущийГод + 1, "ЧГ=0") + "...");

	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Декада") Тогда
		ТекущийГод   = Год(ЗначениеНачалоПериода);
		ТекущийМесяц = Месяц(ЗначениеНачалоПериода);
		
		СчМесяц = ?(ТекущийМесяц - 4 < 1, 12 + ТекущийМесяц - 4, ТекущийМесяц - 4);
		СчГод   = ?(ТекущийМесяц - 4 < 1, ТекущийГод - 1       , ТекущийГод);
		Сч = 6;
		
		Период = Дата(?(СчМесяц <> 1, СчГод, СчГод - 1), ?(СчМесяц > 1, СчМесяц - 1, 12), 1);
		СписокПериодов.Добавить(Период, Формат(Период, "ДФ='MMMM yyyy'") + "...");
		Пока Сч >0 Цикл
			СписокПериодов.Добавить(Дата(СчГод, СчМесяц, 1),  НСтр("ru='I дек.';uk='I дек.'")   + " " + Нрег(Формат(Дата(СчГод, СчМесяц, 1), "ДФ='MMMM yyyy'")));
			СписокПериодов.Добавить(Дата(СчГод, СчМесяц, 11), НСтр("ru='II дек.';uk='II дек.'")  + " " + Нрег(Формат(Дата(СчГод, СчМесяц, 1), "ДФ='MMMM yyyy'")));
			СписокПериодов.Добавить(Дата(СчГод, СчМесяц, 21), НСтр("ru='III дек.';uk='III дек.'") + " " + Нрег(Формат(Дата(СчГод, СчМесяц, 1), "ДФ='MMMM yyyy'")));
			СчМесяц = СчМесяц + 1;
			Если СчМесяц > 12 Тогда
				СчГод = СчГод + 1;
				СчМесяц = 1;
			КонецЕсли;
			Сч = Сч - 1;
		КонецЦикла;
		СписокПериодов.Добавить(Дата(СчГод, СчМесяц, 1), Формат(Дата(СчГод, СчМесяц, 1), "ДФ='MMMM yyyy'") + "...");
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Неделя") Тогда
		НачалоНедели = НачалоНедели(ЗначениеНачалоПериода) - 21 * 86400;
		
		СписокПериодов.Добавить(НачалоНедели - 7 * 86400, НСтр("ru='Пред. недели';uk='Попер. тижня'") + " ...");
		Для Сч = 0 По 6 Цикл
			НачНедели = НачалоНедели + 7 * Сч * 86400;  
			КонНедели = КонецНедели(НачНедели);
			СписокПериодов.Добавить(НачНедели, Формат(НачНедели, "ДФ=dd.MM") + " - " + Формат(КонНедели, "ДФ=dd.MM"));
		КонецЦикла;
		СписокПериодов.Добавить(НачалоНедели + 7 * 86400, НСтр("ru='След. недели';uk='Наст. тижня'") + " ...");
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.День") Тогда
		КонецНедели   = КонецНедели(ЗначениеНачалоПериода);
		ДатаДняНедели = НачалоНедели(ЗначениеНачалоПериода);
		
		СписокПериодов.Добавить(ДатаДняНедели - 86400, НСтр("ru='Предыдущая неделя';uk='Попередній тиждень'"));
		
		Пока ДатаДняНедели < КонецНедели Цикл
			ДеньНед = ДеньНедели(ДатаДняНедели);
			
			СписокПериодов.Добавить(ДатаДняНедели, Формат(ДатаДняНедели, "ДФ='dd MMMM yyyy (ddd)'"));
			
			ДатаДняНедели = ДатаДняНедели + 86400;
		КонецЦикла;
		
		СписокПериодов.Добавить(КонецНедели + 1, НСтр("ru='Следующая неделя';uk='Наступний тиждень'"));
	КонецЕсли;
		
	Возврат СписокПериодов;
	
КонецФункции

#КонецОбласти

#Область РаботаСДинамическимиСписками

// Определяет отбор динамического списка в зависимости от наличия режима совместимости
//
// Параметры:
//  Список - ДинамическийСписок - список, для которого надо определить отбор
//
// Возвращаемое значение:
//   Отбор - требуемый отбор
//
Функция ПолучитьОтборДинамическогоСписка(Список) Экспорт
	
	Возврат Список.КомпоновщикНастроек.ФиксированныеНастройки.Отбор;
	
КонецФункции

// Определяет поля группировки динамического списка в зависимости от наличия режима совместимости
//
// Параметры:
//  Список - ДинамическийСписок - список, для которого надо определить группировку
//
// Возвращаемое значение:
//   ПоляГруппировкиКомпоновкиДанных - требуемые поля группировки
//
Функция ПолучитьПоляГруппировкиДинамическогоСписка(Список) Экспорт
	Перем Группировка, ПоляГруппировки;
	
	Для Каждого Элемент Из Список.КомпоновщикНастроек.Настройки.Структура Цикл
		Если ТипЗнч(Элемент) = Тип("ГруппировкаКомпоновкиДанных") Тогда
			Группировка = Элемент;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Группировка = Неопределено Тогда
		Группировка = Список.КомпоновщикНастроек.Настройки.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
		Группировка.Выбор.Элементы.Добавить(Тип("АвтоВыбранноеПолеКомпоновкиДанных"));
	КонецЕсли;
	
	ПоляГруппировки = Группировка.ПоляГруппировки;
		
	Возврат ПоляГруппировки;
	
КонецФункции

// Определяет условное оформление динамического списка в зависимости от наличия режима совместимости
//
// Параметры:
//  Список - ДинамическийСписок - список, для которого надо определить условное оформление
//
// Возвращаемое значение:
//   УсловноеОформление - требуемое условное оформление
//
Функция ПолучитьУсловноеОформлениеДинамическогоСписка(Список) Экспорт
	
	Возврат Список.КомпоновщикНастроек.ФиксированныеНастройки.УсловноеОформление;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ПреобразованиеТиповДанных

// Помещает переданные данные в массив.
//
// Параметры:
//	Элемент - Произвольный
//	ИгнорироватьПустоеЗначение - Булево - если Истина, то пустой Элемент не будет добавлен в результат
//
// Возвращаемое значение:
//	Массив
//
Функция Массив(Элемент, ИгнорироватьПустоеЗначение = Истина) Экспорт
	
	Если ТипЗнч(Элемент) = Тип("Массив") Тогда
		Массив = Элемент;
	ИначеЕсли ТипЗнч(Элемент) = Тип("СписокЗначений") Тогда
		Массив = Элемент.ВыгрузитьЗначения();
	Иначе
		Массив = Новый Массив;
		Если НЕ ИгнорироватьПустоеЗначение ИЛИ ЗначениеЗаполнено(Элемент) Тогда
			Массив.Добавить(Элемент);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции

// Преобразовывает переданную коллекцию в массив.
//
Функция ПреобразоватьСоответствиеИлиСтруктуруВМассив(ИсходныеДанные, ПреобразовыватьКлюч = Истина) Экспорт
	
	Результат = Новый Массив;
	
	Для Каждого КлючИЗначение Из ИсходныеДанные Цикл
		Результат.Добавить(?(ПреобразовыватьКлюч, КлючИЗначение.Ключ, КлючИЗначение.Значение));
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Возвращает строку, длиной не более определенного количества симвовлов.
// Если строка больше - она обрезается и в конец добавляется многоточие
//
// Параметры:
//  ИсходнаяСтрока		 - Строка 
//  МаксимальнаяДлина	 - Число 
// Возвращаемое значение:
//  Строка 
Функция ПредставлениеСтрокиСДлинойНеБолее(ИсходнаяСтрока, МаксимальнаяДлина) Экспорт
	
	Если СтрДлина(ИсходнаяСтрока) <= МаксимальнаяДлина Тогда
		Возврат ИсходнаяСтрока;
	Иначе
		Возврат Лев(ИсходнаяСтрока, СтрДлина(ИсходнаяСтрока) - 3) + "...";
	КонецЕсли;
	
КонецФункции

// Добавляет в массив значение в том случае, если этого значения еще нет в массиве.
//
// Параметры:
//	Массив - Массив
//	Значение - Произвольный
//
// Возвращаемое значение:
//	Булево - было ли произведено добавление элемента
//
Функция ДобавитьНовоеЗначениеВМассив(Массив, Значение) Экспорт
	
	Если Массив.Найти(Значение) = Неопределено Тогда 
		Массив.Добавить(Значение);
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Проверяет, что в переданной структуре нет элементов с заполненными значениями.
//
// Параметры:
//	Данные - Структура
//
// Возвращаемое значение:
//	Булево - Истина, если в структуре нет ни одного заполненного значения
//
Функция ЗначенияСтруктурыНеЗаполнены(Данные) Экспорт
	
	ПустыеЗначения = Истина;
	
	Для Каждого КлючИЗначение Из Данные Цикл
		
		Если (ТипЗнч(КлючИЗначение.Значение) = Тип("Булево") И КлючИЗначение.Значение)
		 ИЛИ (ТипЗнч(КлючИЗначение.Значение) <> Тип("Булево") И ЗначениеЗаполнено(КлючИЗначение.Значение)) Тогда
			ПустыеЗначения = Ложь;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ПустыеЗначения;
	
КонецФункции

#КонецОбласти

#КонецОбласти
