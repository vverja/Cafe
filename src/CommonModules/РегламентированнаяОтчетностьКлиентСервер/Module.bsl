
Функция ВернутьЗначениеПараметраСЛиста(Форма, СтраницаПанели, ОсновнаяЧасть) Экспорт

	ТекОбласть = Форма.ТабличныйДокумент;

	#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
		Результат = ТекОбласть.Области[ОсновнаяЧасть].Значение;
	#Иначе
		Результат = ТекОбласть.Области[ОсновнаяЧасть].Текст;
	#КонецЕсли

	Возврат Результат;

КонецФункции


Функция ПолучитьСвойствоРаздела(Форма, Знач ИмяСтраницы, Знач ИмяСвойства, ВозвращаемоеЗначение = Неопределено) Экспорт

	Результат = Неопределено;

	Если ТипЗнч(Форма.мСвойстваРазделовДекларации) <> Тип("ДанныеФормыДерево") Тогда
		Возврат Результат;
	КонецЕсли;
    	
	ИмяСтраницыП = ИмяСтраницы;
	
	Для Каждого СтрокаУровня1 Из Форма.мСвойстваРазделовДекларации.ПолучитьЭлементы() Цикл
		Если ИмяСтраницыП = СтрокаУровня1.ИмяСтраницы Тогда
			
			Если СвойствоОпределено(СтрокаУровня1, ИмяСвойства) Тогда
				
				Результат = СтрокаУровня1[ИмяСвойства];
				
			Иначе
				
				Результат = ВозвращаемоеЗначение;
				
			КонецЕсли;

			Прервать;
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;

КонецФункции


Функция СвойствоОпределено(Объект, ИмяСвойства) Экспорт
	
	ГУИД = Новый УникальныйИдентификатор;
	ВремСтрукт = Новый Структура(ИмяСвойства, ГУИД);
	ЗаполнитьЗначенияСвойств(ВремСтрукт, Объект);
	Возврат (ВремСтрукт[ИмяСвойства] <> ГУИД);
	
КонецФункции


Процедура СохранитьДанныеМногостраничногоРазделаВактивнойСтранице(Форма, ИмяТекущейСтраницы, ОчищатьРазделЕслиЕстьМногострочность) Экспорт
	Перем ТаблицаСтраницРаздела;

	ИмяТекТабличногоПоля = "ТабличныйДокумент";
	ТекТабличноеПоле     = Форма[ИмяТекТабличногоПоля];
    	
	Если Не Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяТекущейСтраницы, ТаблицаСтраницРаздела) Тогда
		Возврат;
	КонецЕсли;
	
	ТаблицаСтраницРаздела = Форма[ТаблицаСтраницРаздела];

	// Возьмем активную страницу
	СтрТаблицаСтраницы = ТаблицаСтраницРаздела.НайтиСтроки(Новый Структура("АктивнаяСтраница", Истина));

	// Если нет активной страницы - то выход
	Если СтрТаблицаСтраницы.Количество() = 0 Тогда
		
		Если ОчищатьРазделЕслиЕстьМногострочность Тогда
			#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
				Форма.ОчиститьТабличноеПолеНаКлиенте(ИмяТекущейСтраницы);
			#Иначе
				Форма.ОчиститьТабличноеПолеНаСервере(ИмяТекущейСтраницы);
			#КонецЕсли
		КонецЕсли;
		
		Возврат;
		
	Иначе
		СтрТаблицаСтраницы = СтрТаблицаСтраницы[0];
	КонецЕсли;
    
	// Сохраним данные текущей страницы.
	// В каждой декларации функция СобратьДанныеТекущегоТаблПоля - разные !
	#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
		СтруктураДанныхТекущейТаблицы = Форма.СобратьДанныеТекущегоТаблПоляНаКлиенте(ИмяТекТабличногоПоля);
	#Иначе
		СтруктураДанныхТекущейТаблицы = Форма.СобратьДанныеТекущегоТаблПоляНаСервере(ИмяТекТабличногоПоля);
	#КонецЕсли
	
	КолМногострочныхЧастей = ПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницы, "МногострочностьВРазделе").Количество();
		
	// Определяет, как работать с многострочностью в документе, либо как с ТаблЗначений или со структурой

	СохранятьМногострКакТЗ = ПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницы, "СохранятьМногострКакТЗ");

	// Если лист является многострочным и многостраничным, то необходимо добавить в поле данные доп. строк
	// в этой декларации не используется, т.к. многострочность одна на листе
	Если (КолМногострочныхЧастей > 0) И (НЕ СохранятьМногострКакТЗ) Тогда

		ВРазделеДекларацииЕстьМногострочность = Истина;
		// Определим ИмяГруппы дополнительных строк, по необходимой страницы
		// Если на листе больше одной многострочной части, то алгорит сбора будет другим

		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			СтруктураДанныхДопСтрокРаздела = Форма.СформироватьСтруктуруДанныхДопСтрокСтраницыКлиент(ИмяТекущейСтраницы);
		#Иначе
			СтруктураДанныхДопСтрокРаздела = Форма.СформироватьСтруктуруДанныхДопСтрокСтраницы(Форма, ИмяТекущейСтраницы);
		#КонецЕсли
			
		ТаблицаДопСтрокРаздела = СтруктураДанныхДопСтрокРаздела;

	ИначеЕсли (КолМногострочныхЧастей > 0) И (СохранятьМногострКакТЗ) Тогда

		ВРазделеДекларацииЕстьМногострочность = Истина;
		// Блок для разделов, где хранится только одна многострочная часть
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			ИмяГруппыДопСтрок = Форма.ОпределитьИдМногострочногоРазделаПоАктивнойСтраницеНаКлиенте(ИмяТекущейСтраницы);
			Форма.ОбновитьСтруктуруМногострочногоРазделаНаКлиенте(ИмяГруппыДопСтрок);
		#Иначе
			ИмяГруппыДопСтрок = Форма.ОпределитьИдМногострочногоРазделаПоАктивнойСтраницеНаСервере(ИмяТекущейСтраницы);
			Форма.ОбновитьСтруктуруМногострочногоРазделаНаСервере(ИмяГруппыДопСтрок);
		#КонецЕсли

		// Получим таблицу значений, содержащую данные дополнительных строк.
		ПромТаблицаДопСтрокРаздела = Неопределено;
		Форма.мСтруктураМногострочныхРазделов.Свойство(ИмяГруппыДопСтрок, ПромТаблицаДопСтрокРаздела);
		ПромТаблицаДопСтрокРаздела = Форма[ПромТаблицаДопСтрокРаздела];
											
		ТаблицаДопСтрокРаздела = Форма["Хранилище" + ИмяГруппыДопСтрок].Добавить().Таблица;
						
		КопироватьДанныеФормы(ПромТаблицаДопСтрокРаздела, ТаблицаДопСтрокРаздела);
		                        		
	ИначеЕсли КолМногострочныхЧастей = 0 Тогда

		ВРазделеДекларацииЕстьМногострочность = Ложь;

	КонецЕсли;

	// Сохраним данные
	СтрТаблицаСтраницы.Данные.Очистить();
	СтрТаблицаСтраницы.Данные.Добавить(СтруктураДанныхТекущейТаблицы);
		
	Если ВРазделеДекларацииЕстьМногострочность Тогда
        		
		Если ОчищатьРазделЕслиЕстьМногострочность Тогда
			#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
				Форма.ОчиститьТабличноеПолеНаКлиенте(ИмяТекущейСтраницы);
			#Иначе
				Форма.ОчиститьТабличноеПолеНаСервере(ИмяТекущейСтраницы);
			#КонецЕсли
		КонецЕсли;
        		
		// Запишем данные доп. строк
						
		Если (СтрТаблицаСтраницы.ДанныеДопСтрок.Количество() > 0) 
		   И (СтрТаблицаСтраницы.ДанныеДопСтрок[0].Представление = "ДанныеФормыКоллекцияТаблицаДопСтрокРаздела") Тогда
			
			СтрТаблицаСтраницы.ДанныеДопСтрок[0].Значение = ТаблицаДопСтрокРаздела;
			
		Иначе
			
		   СтрТаблицаСтраницы.ДанныеДопСтрок.Добавить(ТаблицаДопСтрокРаздела, "ДанныеФормыКоллекцияТаблицаДопСтрокРаздела");
			
		КонецЕсли;
		
	КонецЕсли;

	// Попытаемся определить представление, только по текущей странице (по активной), последний параметр Истина
	ОпределитьПредставлениеДопСтраниц(Форма, ИмяТекущейСтраницы, Истина);

КонецПроцедуры

Процедура ОпределитьПредставлениеДопСтраниц(Форма, ИмяСтраницы = Неопределено, ТолькоУАктивнойСтраницы = Неопределено)
	Перем ТаблицаСтраницРаздела;
	Перем ТекущееПредставлениеСтраницы;

	ТолькоАктивная = ?(ТолькоУАктивнойСтраницы = Неопределено, Ложь, ТолькоУАктивнойСтраницы);
	
	Для Каждого Страница Из Форма.мСтруктураМногостраничныхРазделов Цикл
		ИмяТекСтраницы        = Страница.Ключ;
		ТаблицаСтраницРаздела = Форма[Страница.Значение];

		Если ИмяСтраницы <> Неопределено Тогда
			Если ИмяТекСтраницы <> ИмяСтраницы Тогда
				Продолжить; // Пропускаем не нужные страницы
			КонецЕсли;
		КонецЕсли;

		// Если есть хоть одна страница - определим её представление
		Если ТаблицаСтраницРаздела.Количество() > 0 Тогда

			НомерСтраницы = 0;

			Для Каждого СтрокаТаблицы Из ТаблицаСтраницРаздела Цикл

				НомерСтраницы = НомерСтраницы + 1;

				СохрПредставлениеСтраницы = СтрокаТаблицы.Представление;

				// Если колонки нет, тогда автоматическое представление включено по умолчанию.
				Если ТаблицаСтраницРаздела[0].Свойство("АвтоматическоеПредставление") Тогда
					АвтоматическоеПредставление = СтрокаТаблицы.АвтоматическоеПредставление;
				Иначе
					АвтоматическоеПредставление = Истина;
				КонецЕсли;

				Если НЕ АвтоматическоеПредставление Тогда
					Продолжить;
				КонецЕсли;

				// Определяем представление дополнительной страницы
				СтруктураДанныхСтраницы = СтрокаТаблицы.Данные[0].Значение;

				ИмяПредставления = ПолучитьСвойствоРаздела(Форма, ИмяТекСтраницы, "ИмяПредставления");

				Если НЕ ЗначениеЗаполнено(ИмяПредставления) Тогда
					ТекущееПредставлениеСтраницы = Неопределено;
				Иначе
					СтруктураДанныхСтраницы.Свойство(ИмяПредставления, ТекущееПредставлениеСтраницы);
				КонецЕсли;

				Если (НЕ ТолькоАктивная) Или ((ТолькоАктивная) И (СтрокаТаблицы.АктивнаяСтраница))Тогда

					ТекущееПредставлениеСтраницы = ?(НЕ ЗначениеЗаполнено(ТекущееПредставлениеСтраницы), "Лист N " + Строка(НомерСтраницы), ТекущееПредставлениеСтраницы + ". Лист N " + Строка(НомерСтраницы));
					Если Не ПустаяСтрока(ТекущееПредставлениеСтраницы) Тогда
						СтрокаТаблицы.Представление = ТекущееПредставлениеСтраницы;
					Иначе
						СтрокаТаблицы.Представление = "Новая страница";
					КонецЕсли;

				КонецЕсли; // ТолькоАктивная

			КонецЦикла;

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры


Функция ЯвляетсяЧислом(Значение) Экспорт

	Если ТипЗнч(Значение) = Тип("Число") Тогда

		Возврат Истина

	Иначе

		Если ТипЗнч(Значение) = Тип("Строка") Тогда
			Если Значение = "" Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;

		Попытка
			Р = Число(Значение);
		Исключение
			Возврат Ложь;
		КонецПопытки;
			Возврат Истина;

	КонецЕсли;

КонецФункции


Процедура ОбновитьСтруктуруМногострочногоРаздела(Форма, ИмяГруппы) Экспорт
	Перем СтруктураГруппы;
    	
	Форма.мСтруктураМногострочныхРазделов.Свойство(ИмяГруппы, СтруктураГруппы);
	
	СтруктураГруппы = Форма[СтруктураГруппы];
	
	ТекТабличноеПолеИмя = "ТабличныйДокумент";
	
	ТекТабличноеПоле = Форма[ТекТабличноеПолеИмя];
	
	КолонкиГруппы = Форма.СтруктураРеквизитовФормы.КолонкиМногострочныхРазделов[ИмяГруппы];
	
	Для НСтр = 1 По СтруктураГруппы.Количество() Цикл
		ТекСтрокаТаблицы = СтруктураГруппы[НСтр - 1];
		НСтрСтр = Формат(НСтр, "ЧГ=0");
		
		Для Каждого ИмяКолонки Из КолонкиГруппы Цикл
		
			Если СтруктураГруппы[0].Свойство(ИмяКолонки) Тогда
				
				ИмяЯчейки     = ИмяКолонки + "_" + НСтрСтр;
				ОбластьЯчейки = ТекТабличноеПоле.Области[ИмяЯчейки];
				
				Если ОбластьЯчейки.СодержитЗначение = Истина Тогда
					ЗначениеЯчейки = ОбластьЯчейки.Значение;
				Иначе
					ЗначениеЯчейки = ОбластьЯчейки.Текст;
				КонецЕсли;
				
				ТекСтрокаТаблицы[ИмяКолонки] = ЗначениеЯчейки;
				
			КонецЕсли;
				
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры


Процедура ОчиститьТабличноеПоле(Форма, Знач ВыбТабличноеПолеИмя) Экспорт

	// Проверяем многострочные блоки в разделе.
	НастройкиМнгЧ = ПолучитьСвойствоРаздела(Форма, ВыбТабличноеПолеИмя, "МногострочностьВРазделе");
	ЕстьМногострочныеБлоки = (ТипЗнч(НастройкиМнгЧ) = Тип("ДанныеФормыКоллекция")) И (НастройкиМнгЧ.Количество() > 0);
	Если ЕстьМногострочныеБлоки Тогда
		Для каждого Блок Из НастройкиМнгЧ Цикл
			МногострочныйБлок = Блок.ИдГруппы;
			УдалитьДопСтрокиМногострочнойЧастиРегОтчета(Форма, МногострочныйБлок, Ложь);
		КонецЦикла;
	КонецЕсли;
	
	ВыбТабличноеПоле = Форма.ТабличныйДокумент;

	// Непосредственно очищаем ячейки табличного документа.
	Для Инд = 0 По ВыбТабличноеПоле.Области.Количество() - 1 Цикл
		ТекущаяОбласть = ВыбТабличноеПоле.Области[Инд];

		Если НЕ Тип(ТекущаяОбласть) = Тип("РисунокТабличногоДокумента") И Не ТекущаяОбласть.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Прямоугольник Тогда
			Продолжить;
		КонецЕсли;

		Если ТекущаяОбласть.СодержитЗначение <> Истина Тогда
			Продолжить;
		КонецЕсли;

		
		Если Найти(Врег(ТекущаяОбласть.Имя), ВРег("Штампик")) > 0  Тогда
			Продолжить;
		КонецЕсли;
		
		Если Тип(ТекущаяОбласть) = Тип("РисунокТабличногоДокумента") Тогда
			ТекущаяОбласть.Значение = "";
		Иначе
			ТекущаяОбласть.Очистить();
		КонецЕсли;
		
	КонецЦикла;

	ИмяСтраницыПанели = ВыбТабличноеПолеИмя;

	Если ЕстьМногострочныеБлоки Тогда
		Для каждого Блок Из НастройкиМнгЧ Цикл
			МногострочныйБлок = Блок.ИдГруппы;
			
			#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
				Форма.ОбновитьСтруктуруМногострочногоРазделаНаКлиенте(МногострочныйБлок);
			#Иначе
				Форма.ОбновитьСтруктуруМногострочногоРазделаНаСервере(МногострочныйБлок);
			#КонецЕсли
			
		КонецЦикла;
		
		// Расчет всегда запускаем только в многострочных листах. В не многострочных, запускается при вставки доп. страницы, или интерактивно в коде.
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			Форма.РасчетНаКлиенте(ИмяСтраницыПанели);
		#Иначе
			Форма.РасчетНаСервере(ИмяСтраницыПанели);
		#КонецЕсли
				
	КонецЕсли;

КонецПроцедуры


Процедура УдалитьДопСтрокиМногострочнойЧастиРегОтчета(Форма, ИдГруппы, ОбновлятьБлок = Истина)
	Перем ТаблицаДопСтрок;
	Перем ИсходноеКоличествоСтрокГруппы;

	Форма.мСтруктураМногострочныхРазделов.Свойство(ИдГруппы, ТаблицаДопСтрок);
	
	ТаблицаДопСтрок = Форма[ТаблицаДопСтрок];
	
	Форма.мСтруктураИсхКолвоСтрокРазделов.Свойство(ИдГруппы, ИсходноеКоличествоСтрокГруппы);
	ТекущееКоличествоСтрок = ТаблицаДопСтрок.Количество();
	
	#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
		ТекТабличноеПолеИмя = Форма.ОпределитьТабличноеПолеПоИдМногострочногоРазделаНаКлиенте(ИдГруппы);
	#Иначе
		ТекТабличноеПолеИмя = Форма.ОпределитьТабличноеПолеПоИдМногострочногоРазделаНаСервере(ИдГруппы);
	#КонецЕсли
	
	ТекТабличноеПоле = Форма.ТабличныйДокумент;
	
	Если ТекущееКоличествоСтрок > ИсходноеКоличествоСтрокГруппы Тогда

		НастройкиМнгЧ = ПолучитьСвойствоРаздела(Форма, ТекТабличноеПолеИмя, "МногострочностьВРазделе").НайтиСтроки(Новый Структура("ИдГруппы", ИдГруппы))[0];
		МнгЧастьОбластьИмя = НастройкиМнгЧ.Область;
		ВысотаСтроки = НастройкиМнгЧ.ВысотаСтроки;

		МнгЧастьОбласть = ТекТабличноеПоле.Области.Найти(МнгЧастьОбластьИмя);
		Низ = ТекТабличноеПоле.Области.Найти(МнгЧастьОбластьИмя).Низ + 1;
		
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			Текст = МнгЧастьОбласть.Текст;
			РегламентированнаяОтчетностьВызовСервера.УдалитьОбластьИзТабличногоДокумента(ТекТабличноеПоле, Низ, Низ + ((ТекущееКоличествоСтрок - ИсходноеКоличествоСтрокГруппы) * ВысотаСтроки) - 1);
			Форма.ТабличныйДокумент = ТекТабличноеПоле;
		#Иначе
			РегламентированнаяОтчетностьВызовСервера.УдалитьОбластьИзТабличногоДокумента(ТекТабличноеПоле, Низ, Низ + ((ТекущееКоличествоСтрок - ИсходноеКоличествоСтрокГруппы) * ВысотаСтроки) - 1);
		#КонецЕсли
				
		ТаблицаДопСтрок.Очистить();
		Для Инд = 1 По ИсходноеКоличествоСтрокГруппы Цикл
			ТаблицаДопСтрок.Добавить();
		КонецЦикла;
		Если ОбновлятьБлок Тогда
			#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
				Форма.ОбновитьСтруктуруМногострочногоРазделаНаКлиенте(ИдГруппы);
			#Иначе
				Форма.ОбновитьСтруктуруМногострочногоРазделаНаСервере(ИдГруппы);
			#КонецЕсли
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры


Процедура ПроставлениеНомеровЛистов(Форма, ПризнакНумеруемыхФорм = Истина, СписокПечатаемыхЛистов) Экспорт
	
	Если ПризнакНумеруемыхФорм Тогда
		НомерЛиста = 1;
		Для Каждого Эл Из Форма.СтруктураРеквизитовФормы.мПечатныеФормы Цикл
			НомерЛиста = НомерЛиста + 1;
		КонецЦикла;
		Если Форма.СтруктураРеквизитовФормы.мПечатныеФормы.Количество() <> 0 Тогда
			ТаблДок = Форма.СтруктураРеквизитовФормы.мПечатныеФормы.Получить(0).Значение;
			ЦифрВОбщемКоличествеЛистов = 0;
			Для ОбратныйИндекс = 1 По 9 Цикл
				Индекс = 10 - ОбратныйИндекс;
				Если ТаблДок.Области.Найти("СоставленаНа" + Индекс) <> Неопределено Тогда
					ЦифрВОбщемКоличествеЛистов = Индекс;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			ВсегоЛистов = Формат(НомерЛиста - 1, "ЧЦ=" + ЦифрВОбщемКоличествеЛистов + "; ЧН=0; ЧВН=; ЧГ=");
			Для Инд = 1 По ЦифрВОбщемКоличествеЛистов Цикл
				ТекИнд = ЦифрВОбщемКоличествеЛистов - Инд + 1;
				Попытка
					ТаблДок.Области["СоставленаНа" + ТекИнд].Значение = Сред(ВсегоЛистов, ТекИнд, 1);
				Исключение
				КонецПопытки;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	НомераЛистов = Новый СписокЗначений;
		
	НомерЛиста = 1;
	
	Для Каждого Эл Из Форма.СтруктураРеквизитовФормы.мПечатныеФормы Цикл
				
		НомЛиста = НомераЛистов.НайтиПоЗначению(Эл.Представление);
		Если НомЛиста = Неопределено Тогда
			НомЛиста = НомераЛистов.Добавить(Эл.Представление, "1");
			НЛиста = 1;
		Иначе
			НЛиста = Число(НомЛиста.Представление) + 1;
			НомЛиста.Представление = Строка(Число(НомЛиста.Представление) + 1);
		КонецЕсли;
		
		Значение = Новый Массив;
		Значение.Добавить(ПоместитьВоВременноеХранилище(Эл.Значение, Форма.УникальныйИдентификатор));
		Значение.Добавить(Форма.УникальныйИдентификатор);
		Значение.Добавить(Форма.Заголовок);
		
		СписокПечатаемыхЛистов.Добавить(Значение, Эл.Представление + ". Лист №" + НЛиста);
				
		НомерЛиста = НомерЛиста + 1;
		
	КонецЦикла;
	
	Форма.СтруктураРеквизитовФормы.мПечатныеФормы.Очистить();
	
КонецПроцедуры


Процедура ПроставитьВКвадратыЗначения(Форма, Знач Лист, Знач Показатель, Знач Размерность, Знач Значение, ДополнитьЗначение = Ложь, НольКакНоль = Ложь) Экспорт

	Раздел = Форма["ТабличныйДокумент"];

	ТекЛист = Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела;

	ДопРазряд = ""; // дополнительный разряд в счетчике
	ТестОк = Истина;

	Если ТекЛист = Лист Тогда
		Если Раздел.Области.Найти(Показатель + ДопРазряд + "1") = Неопределено Тогда
			ТестОк = Ложь;
		КонецЕсли;
	Иначе
		Если Форма["СтруктураДанных" + Лист].Свойство(Показатель + ДопРазряд + "1") = Ложь Тогда
			ТестОк = Ложь;
		КонецЕсли;	
	КонецЕсли;
	
	Если НЕ ТестОк Тогда
		Если ДопРазряд = "0" Тогда
			ДопРазряд = "";
		Иначе
			ДопРазряд = "0";
		КонецЕсли;
	КонецЕсли;

	// Если и с противоположным индексом показателя на листе нет, то не выполняем процедуру.
	Если ТекЛист = Лист Тогда
		
		Если Раздел.Области.Найти(Показатель + ДопРазряд + "1") = Неопределено Тогда
			Возврат;
		КонецЕсли;
    Иначе
		
		Если Форма["СтруктураДанных" + Лист].Свойство(Показатель + ДопРазряд + "1") = Ложь Тогда
			Возврат;
		КонецЕсли;	
		
	КонецЕсли;	
		
	СтрокаФорматаЯчейки = СтрЗаменить(Форма.СтруктураРеквизитовФормы.мСтрокаФормата, "; ЧН=-", "");
	// Убираем пробелы между группами разрядов числа
	СтрокаФорматаЯчейки = СтрокаФорматаЯчейки + "; ЧГ=0";

	Если (ДополнитьЗначение) Или ((ЯвляетсяЧислом(Значение)) И (Значение = 0)) Тогда

		Если ((ЯвляетсяЧислом(Значение)) И (Значение = 0)) Тогда

			Если НольКакНоль Тогда
				ЗначениеДопСтрока = ДополнитьСтроку("0", Размерность," ");
			Иначе
				ЗначениеДопСтрока = ДополнитьСтроку("", Размерность," ");
			КонецЕсли;

		Иначе

			ЗначениеДопСтрока = Формат(Значение, СтрокаФорматаЯчейки);
			ЗначениеДопСтрока = ДополнитьСтроку(ЗначениеДопСтрока, Размерность," ");

		КонецЕсли;

	Иначе

		ЗначениеДопСтрока = Значение;

	КонецЕсли; // ДополнитьЗначение

	ДопЗначение = 0;

	Если ТекЛист = Лист Тогда
	
		Для НомЯчейки = 1 По Размерность Цикл

			Раздел.Области[Показатель + ?(СтрДлина(НомЯчейки) = 1, ДопРазряд + НомЯчейки, НомЯчейки)].Значение = Сред(ЗначениеДопСтрока, НомЯчейки, 1);
			
		КонецЦикла;
		
	Иначе	
		
		Для НомЯчейки = 1 По Размерность Цикл

			Форма["СтруктураДанных" + Лист][Показатель + ?(СтрДлина(НомЯчейки) = 1, ДопРазряд + НомЯчейки, НомЯчейки)] = Сред(ЗначениеДопСтрока, НомЯчейки, 1);
			
		КонецЦикла;
		
	КонецЕсли;	
	
КонецПроцедуры


Функция ДополнитьСтроку(Знач Стр, Длина, Чем=" ", Режим = 0) Экспорт
	
	СимволовДополнить = Длина -  СтрДлина(Стр);
	Добавок = "";
	Для Н=1 по СимволовДополнить Цикл
		Добавок =	Добавок + Чем;
	КонецЦикла;
	Возврат ?(Режим=0, Добавок + Стр, Стр + Добавок);
	
КонецФункции


Процедура ОбновитьСтруктуруМногостраничныхРазделов(Форма, ИмяСтраницы = Неопределено) Экспорт
    	
	Для Каждого Страница Из Форма.мСтруктураМногостраничныхРазделов Цикл
		ИмяТекущейСтраницыПанели = Страница.Ключ;
		ТаблицаТекущейСтраницы   = Форма[Страница.Значение];

		Если ИмяСтраницы <> Неопределено Тогда
			Если ИмяСтраницы <> ИмяТекущейСтраницыПанели Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		// Для декларации по прибыли, специальные два раздела сохраняются особым образом
		// пришлось внести изменения в общий модуль и процедуру для всех отчетов

		Если (ИмяТекущейСтраницыПанели = "Лист03_РазделыБВ1") Или (ИмяТекущейСтраницыПанели = "Лист03_РазделыБВ2") Тогда
			
			#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
				Форма.СохранитьДанныеМногостраничногоРазделаВактивнойСтраницеРешенияКлиент(ИмяТекущейСтраницыПанели);
			#Иначе
				Форма.СохранитьДанныеМногостраничногоРазделаВактивнойСтраницеРешения(ИмяТекущейСтраницыПанели);
			#КонецЕсли
			
		Иначе

		// Обновляя представления сохранения активного листа декларации
		// Параметр Ложь - не позволяет удалять многострочные части, если они есть на листе
			СохранитьДанныеМногостраничногоРазделаВактивнойСтранице(Форма, ИмяТекущейСтраницыПанели, Ложь);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры


Процедура СвойстваГрупповыхЗначений(Форма, ИмяЯчейки, Операция, ЦветФона = Неопределено, ИмяСтраницы = Неопределено) Экспорт

	Если ИмяСтраницы = Неопределено Тогда
		
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			ИмяСтраницыПанели = РегламентированнаяОтчетностьКлиент.ОпределитьСтраницуПанелиПоКодуПоказателяНаКлиенте(Форма, ИмяЯчейки);
		#Иначе
			ИмяСтраницыПанели = РегламентированнаяОтчетностьВызовСервера.ОпределитьСтраницуПанелиПоКодуПоказателяНаСервере(Форма, ИмяЯчейки);
		#КонецЕсли
					
		Если ИмяСтраницыПанели = Неопределено Тогда
			Возврат;
		КонецЕсли;
	Иначе
		ИмяСтраницыПанели = ИмяСтраницы;
	КонецЕсли;

	ИмяПоляТаблДокумента = "ТабличныйДокумент";

	СмысловаяЧасть = ПолучитьСмысловуюЧастьИмениЯчейки(ИмяЯчейки);
	Если СмысловаяЧасть = "" Тогда
	// не групповая ячейка
		Возврат;
	КонецЕсли;
	ТекущийСчетчик = ПолучитьСмысловуюЧастьИмениЯчейки(ИмяЯчейки, Ложь);
	ТекущийСчетчикЦел = Число(ТекущийСчетчик);
	МожноРаботать = Истина;
	Пока МожноРаботать Цикл
		Координата = СмысловаяЧасть + Строка(ТекущийСчетчикЦел);

		Если Форма[ИмяПоляТаблДокумента].Области.Найти(Координата) <> Неопределено Тогда
			Попытка
				Если Операция = "УстановитьЗащиту" Тогда
					Форма[ИмяПоляТаблДокумента].Области[Координата].Защита = Истина;
				КонецЕсли;

				Если Операция = "СнятьЗащиту" Тогда
					Форма[ИмяПоляТаблДокумента].Области[Координата].Защита = Ложь;
				КонецЕсли;

				Если Операция = "ПроставитьЦветРаскраски" Тогда
					Форма[ИмяПоляТаблДокумента].Области[Координата].ЦветФона = ЦветФона;
				КонецЕсли;

				Если Операция = "Очистить" Тогда
					Форма[ИмяПоляТаблДокумента].Области[Координата].Значение = "";
				КонецЕсли;

				ТекущийСчетчикЦел = ТекущийСчетчикЦел + 1; // работаем со следующей ячейкой

			Исключение
				МожноРаботать = Ложь; // далее нет ячеек многоквадратного значения
				Прервать;
			КонецПопытки;

		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры


Функция ПолучитьСмысловуюЧастьИмениЯчейки(ИмяЯчейки, Определение = Истина) Экспорт

	Для Инд = 1 По СтрДлина(ИмяЯчейки) Цикл
		// последний разделитель
		// не пользуемся тут функцией Найти, т.к. разделителей может быть много в одной ячейки, пример ИНН_1_1
		Если Инд >= 4 Тогда
			// считаем, что эта ячейка не многоквадратная и выходим
			Возврат "";
		КонецЕсли;
		
		СимволСтроки = Сред(ИмяЯчейки,СтрДлина(ИмяЯчейки) - Инд + 1 ,1);

		Если СимволСтроки = "_" Тогда 
		// встретился знак "_" считаем его разделителем
			АдресПоследнегоРазделителя = СтрДлина(ИмяЯчейки) - Инд + 1;
			Прервать;
		КонецЕсли; // Сред

		//Если НЕ ЯвляетсяЧислом(СимволСтроки) Тогда
		Если НЕ СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(СимволСтроки) Тогда
		// встретилась буква разделить
			АдресПоследнегоРазделителя = СтрДлина(ИмяЯчейки) - Инд + 1;
			Прервать;
		КонецЕсли; // Сред
	КонецЦикла;

	СмысловаяЧасть = Сред(ИмяЯчейки, 1, АдресПоследнегоРазделителя); // возвращаем ВМЕСТЕ с разделителем
	// Получаем текущий счетчик
	ТекущийСчетчик = Сред(ИмяЯчейки, АдресПоследнегоРазделителя + 1, СтрДлина(ИмяЯчейки) - АдресПоследнегоРазделителя);

	Если Определение Тогда
		Возврат СмысловаяЧасть;
	Иначе
		Возврат ТекущийСчетчик;
	КонецЕсли;

КонецФункции


Процедура ПоказатьСтраницуМногостраничногоРаздела(Форма, Шаг, ИмяТекущейСтраницыПанели, ПоказатьПоИндексу = Ложь) Экспорт
	Перем ТаблицаСтраницРаздела;
	Перем ТаблицаВариантыЗаполнения;
	Перем СтруктураДанныхДопСтрокРаздела;
    	
	ИмяТекТабличногоПоля = "ТабличныйДокумент";
		
	Если Не Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяТекущейСтраницыПанели, ТаблицаСтраницРаздела) Тогда
		Возврат;
	КонецЕсли;

	ТаблицаСтраницРаздела = Форма[ТаблицаСтраницРаздела];
	
	СтрТаблицаСтраницы = ТаблицаСтраницРаздела.НайтиСтроки(Новый Структура("АктивнаяСтраница", Истина));

	Если СтрТаблицаСтраницы.Количество() = 0 Тогда
		Возврат;
	Иначе
		СтрТаблицаСтраницы = СтрТаблицаСтраницы[0];
	КонецЕсли;

	НомерТекущейСтраницы = ТаблицаСтраницРаздела.Индекс(СтрТаблицаСтраницы);
    	
	Если Не ПоказатьПоИндексу Тогда
		НомерСледующейСтраницы = НомерТекущейСтраницы + Шаг;
	Иначе
		НомерСледующейСтраницы = Шаг;
	КонецЕсли;

	Если ((НомерСледующейСтраницы + 1) > ТаблицаСтраницРаздела.Количество()) ИЛИ (НомерСледующейСтраницы < 0) Тогда
		Возврат;
	КонецЕсли;
	    	
	// Сохраним данные активной страницы, с присвоением Представления страницы и с очистной многострочных частей (Истина)
	СохранитьДанныеМногостраничногоРазделаВактивнойСтранице(Форма, ИмяТекущейСтраницыПанели, Истина);
	
	СтрТаблицаСтраницы.АктивнаяСтраница = Ложь;
	
	СтрСледующаяСтраница = ТаблицаСтраницРаздела[НомерСледующейСтраницы];

	СтрСледующаяСтраница.АктивнаяСтраница = Истина;

	#Если НаКлиенте Тогда
		ТаблицаВариантыЗаполнения = РегламентированнаяОтчетностьКлиент.ПолучитьТаблицуВариантовЗаполненияНаКлиенте(Форма, ИмяТекущейСтраницыПанели);
	#Иначе
		ТаблицаВариантыЗаполнения = РегламентированнаяОтчетностьВызовСервера.ПолучитьТаблицуВариантовЗаполненияНаСервере(Форма, ИмяТекущейСтраницыПанели);
	#КонецЕсли
	
	КолМногострочныхЧастей = ПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "МногострочностьВРазделе").Количество();
	
	Если КолМногострочныхЧастей > 0 Тогда

		НовДанныеДопСтрокРаздела = СтрСледующаяСтраница.ДанныеДопСтрок;
		
		Если (ТипЗнч(НовДанныеДопСтрокРаздела) = Тип("СписокЗначений"))
			И (НовДанныеДопСтрокРаздела.Количество() > 0)
			И (НовДанныеДопСтрокРаздела[0].Представление = "ДанныеФормыКоллекцияТаблицаДопСтрокРаздела") Тогда
			
			НовДанныеДопСтрокРаздела = НовДанныеДопСтрокРаздела[0].Значение;
			
		КонецЕсли;
		
		// Способ хранения многострочных частей
		СохранятьМногострКакТЗ = ПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "СохранятьМногострКакТЗ");

	Иначе

		НовТаблицаДопСтрокРаздела = Неопределено; // Многострочности нет
		ИмяГруппыДопСтрок = Неопределено; // Имя группы строк неопределено

	КонецЕсли;

	Если НовДанныеДопСтрокРаздела <> Неопределено Тогда

		// В случае, если многострочных частей больше 1, то хранится структура, иначе, таблица значений с данными
		Если (КолМногострочныхЧастей > 0) И (НЕ СохранятьМногострКакТЗ) Тогда
			Для Каждого ГруппаСтрок Из НовДанныеДопСтрокРаздела Цикл
				ИмяГруппыДопСтрок = ГруппаСтрок.Ключ;
				ДанныеГруппыСтрок = ГруппаСтрок.Значение;
								
				ПромТаблицаГруппыСтрок = Форма["Хранилище" + ИмяГруппыДопСтрок].Добавить().Таблица;
						
				КопироватьДанныеФормы(ДанныеГруппыСтрок, ПромТаблицаГруппыСтрок);

				// Заменяем таблицу значений с данными текущей страницы.
				//Форма.мСтруктураМногострочныхРазделов.Вставить(ИмяГруппыДопСтрок, ПромТаблицаГруппыСтрок);
				КопироватьДанныеФормы(ПромТаблицаГруппыСтрок, Форма[ИмяГруппыДопСтрок]);
				
				// Выводим в табличный документ данные группы дополнительных строк и обновляем структуру многострочного раздела.
				#Если НаКлиенте Тогда
					Форма.ВывестиРазделВТабличныйДокументНаКлиенте(ИмяГруппыДопСтрок, ПромТаблицаГруппыСтрок);
					Форма.ОбновитьСтруктуруМногострочногоРазделаНаКлиенте(ИмяГруппыДопСтрок);
				#Иначе
					Форма.ВывестиРазделВТабличныйДокументНаСервере(ИмяГруппыДопСтрок, ПромТаблицаГруппыСтрок);
					Форма.ОбновитьСтруктуруМногострочногоРазделаНаСервере(ИмяГруппыДопСтрок);
				#КонецЕсли
				
			КонецЦикла;

		ИначеЕсли (КолМногострочныхЧастей > 0) И (СохранятьМногострКакТЗ) Тогда

			#Если НаКлиенте Тогда
				ИмяГруппыДопСтрок = Форма.ОпределитьИдМногострочногоРазделаПоАктивнойСтраницеНаКлиенте(ИмяТекущейСтраницыПанели);
			#Иначе
				ИмяГруппыДопСтрок = Форма.ОпределитьИдМногострочногоРазделаПоАктивнойСтраницеНаСервере(ИмяТекущейСтраницыПанели);
			#КонецЕсли
			
			ПромТаблицаДопСтрокРаздела = Форма["Хранилище" + ИмяГруппыДопСтрок].Добавить().Таблица;
						
			КопироватьДанныеФормы(НовДанныеДопСтрокРаздела, ПромТаблицаДопСтрокРаздела);
			
			// Заменяем таблицу значений с данными текущей страницы.
			//Форма.мСтруктураМногострочныхРазделов.Вставить(ИмяГруппыДопСтрок, ПромТаблицаДопСтрокРаздела);
			КопироватьДанныеФормы(ПромТаблицаДопСтрокРаздела, Форма[ИмяГруппыДопСтрок]);
			
			// Выводим в табличный документ данные группы дополнительных строк и обновляем структуру многострочного раздела
			#Если НаКлиенте Тогда
				Форма.ВывестиРазделВТабличныйДокументНаКлиенте(ИмяГруппыДопСтрок, ПромТаблицаДопСтрокРаздела);
				Форма.ОбновитьСтруктуруМногострочногоРазделаНаКлиенте(ИмяГруппыДопСтрок);
			#Иначе
				Форма.ВывестиРазделВТабличныйДокументНаСервере(ИмяГруппыДопСтрок, ПромТаблицаДопСтрокРаздела);
				Форма.ОбновитьСтруктуруМногострочногоРазделаНаСервере(ИмяГруппыДопСтрок);
			#КонецЕсли
			
		КонецЕсли;
		
	КонецЕсли;

	// отображаем данные следующей страницы
	СтруктураДанныхСледующаяСтраница = СтрСледующаяСтраница.Данные[0].Значение;

	ТекТабличноеПоле = Форма[ИмяТекТабличногоПоля];
	
	Для Каждого Элемент Из СтруктураДанныхСледующаяСтраница Цикл
		ИмяПоказателя      = Элемент.Ключ;
		ЗначениеПоказателя = Элемент.Значение;


			Попытка
				ТекТабличноеПоле.Области[ИмяПоказателя].Значение = ЗначениеПоказателя;
			Исключение
			КонецПопытки;

			Если Не ТаблицаВариантыЗаполнения = Неопределено Тогда
				
				// обновляем примечания к ячейкам табличного документа
				//НайденнаяСтрока = ТаблицаВариантыЗаполнения.НайтиСтроки(Новый Структура("КодПоказателя", ИмяПоказателя));
				
				НайденнаяСтрока = Неопределено;
				
				Для Каждого Элемент Из ТаблицаВариантыЗаполнения Цикл
					
					Если Элемент.КодПоказателя = ИмяПоказателя Тогда
						НайденнаяСтрока = Элемент;
						Прервать;
					КонецЕсли;
					
				КонецЦикла;
				
				Если НЕ НайденнаяСтрока = Неопределено Тогда
					ТекущийКомментарий = ТекТабличноеПоле.Области[ИмяПоказателя].Примечание.Текст;
					НовыйКомментарий   = НайденнаяСтрока.Комментарий;

					// примечание к ячейке устанавливаем тогда, когда изменился текст комментария
					Если Не (ПустаяСтрока(ТекущийКомментарий) И ПустаяСтрока(НовыйКомментарий)) Тогда
						ТекТабличноеПоле.Области[ИмяПоказателя].Примечание.Текст = НовыйКомментарий;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;

	КонецЦикла;

КонецПроцедуры


Процедура ВывестиРазделВТабличныйДокумент(Форма, ИмяГруппы, СтруктураГруппы) Экспорт
	Перем ИсходноеКоличествоСтрокГруппы;

	// определим исходное колво строк многострочного раздела,
	// соответствующее бумажной форме отчета
	Форма.мСтруктураИсхКолвоСтрокРазделов.Свойство(ИмяГруппы, ИсходноеКоличествоСтрокГруппы);

	// реальное кол-во строк (колво заполненных строк)
	ТекущееКоличествоСтрокГруппы = СтруктураГруппы.Количество();
	
	#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
		ТекТабличноеПолеИмя = Форма.ОпределитьТабличноеПолеПоИдМногострочногоРазделаНаКлиенте(ИмяГруппы);
	#Иначе
		ТекТабличноеПолеИмя = Форма.ОпределитьТабличноеПолеПоИдМногострочногоРазделаНаСервере(ИмяГруппы);
	#КонецЕсли
	
	ТекТабличноеПоле = Форма["ТабличныйДокумент"];
				
	ПерерисоватьСтроки = (НЕ ТекущееКоличествоСтрокГруппы > ИсходноеКоличествоСтрокГруппы);

	Раздел = Форма["ТабличныйДокумент"];
		
	// При восстановлении сохраненных данных отчета сравниваем исходное кол-во
	// отображаемых в форме строк многострочного раздела с реальным количеством
	// созданных строк в сохраненном отчете.
	Если ТекущееКоличествоСтрокГруппы > ИсходноеКоличествоСтрокГруппы Тогда

		НастройкиМнгЧ = ПолучитьСвойствоРаздела(Форма, ТекТабличноеПолеИмя, "МногострочностьВРазделе");
				
		РегламентированнаяОтчетностьВызовСервера.ВывестиРазделВТабличныйДокументНаСервере(НастройкиМнгЧ, ИмяГруппы, Раздел, СтруктураГруппы, Форма.СтруктураРеквизитовФормы.КолонкиМногострочныхРазделов);
		
		Форма["ТабличныйДокумент"] = Раздел;
		ТекТабличноеПоле           = Форма["ТабличныйДокумент"];

	КонецЕсли;

	КолонкиГруппы = Форма.СтруктураРеквизитовФормы.КолонкиМногострочныхРазделов[ИмяГруппы];	
	
	// выводим значения строк
	Для Каждого СтрокаТаблицы Из СтруктураГруппы Цикл
		НомерСтрокиВТаблице      = СтруктураГруппы.Индекс(СтрокаТаблицы);
		НомерСтрокиВФормеТаблицы = НомерСтрокиВТаблице + 1;
		НомерСтрокиВФормеТаблицыСтр = Формат(НомерСтрокиВФормеТаблицы, "ЧГ=0");
						
		Для Каждого КолонкаТаблицыИмя Из КолонкиГруппы Цикл
			
			Если СтруктураГруппы[0].Свойство(КолонкаТаблицыИмя) Тогда
				
				ЗначениеЯчейки           = СтрокаТаблицы[КолонкаТаблицыИмя];
				ИмяЯчейки                = КолонкаТаблицыИмя + "_" + НомерСтрокиВФормеТаблицыСтр;
				
				ОбластьЯчейкиТаблицы          = ТекТабличноеПоле.Области[ИмяЯчейки];
				
				Если ОбластьЯчейкиТаблицы.СодержитЗначение = Истина Тогда
					ОбластьЯчейкиТаблицы.Значение = ЗначениеЯчейки;
				Иначе
					ОбластьЯчейкиТаблицы.Текст = ЗначениеЯчейки;
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;

	КонецЦикла;

КонецПроцедуры


Функция ПоказательВходитВМногострочнуюЧасть(Форма, ИмяПоказателя) Экспорт
    	
	Если НЕ СвойствоОпределено(Форма, "мСтруктураМногострочныхРазделов") Тогда
		Возврат 0;
	КонецЕсли;
	
	ПозицияXXXX = Найти(ИмяПоказателя, "XXXX");
	Если ПозицияXXXX = 0 Тогда
		Возврат 0;
	КонецЕсли;
	ИмяГруппы = Лев(ИмяПоказателя, ПозицияXXXX - 1);

	СтруктураГруппы = Неопределено;

	Если НЕ Форма.мСтруктураМногострочныхРазделов.Свойство(ИмяГруппы, СтруктураГруппы) Тогда
		Возврат 0;
	Иначе
		СтруктураГруппы = Форма[СтруктураГруппы];
		Возврат СтруктураГруппы.Количество();
	КонецЕсли;

КонецФункции

Функция ПолучитьТаблицуОтчетовДействующихВВыбранныйПериод(Форма, ДляВыбораПриСозданииОтчета = Истина) Экспорт

	//#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
	#Если НаКлиенте Тогда
		Форма.РезультирующаяТаблица.Очистить();
	#Иначе
		// Объявим таблицу результата.
		РезультирующаяТаблица = Форма.мТаблицаФормОтчета.Выгрузить();
		РезультирующаяТаблица.Очистить();
	#КонецЕсли
	
	// Осуществим перебор по таблице содеражащей формы отчетов и периоды действий.
	Для Каждого ЭлФорма Из Форма.мТаблицаФормОтчета Цикл

		ДатаНачалаДействияФормы = ЭлФорма.ДатаНачалоДействия;
		ДатаКонцаДействияФормы  = КонецДня(?(ЭлФорма.ДатаКонецДействия = ПустоеЗначениеТипа(Тип("Дата")), '20291231', ЭлФорма.ДатаКонецДействия));

		Если Форма.мДатаКонцаПериодаОтчета <= ДатаКонцаДействияФормы
		   И Форма.мДатаКонцаПериодаОтчета >= ДатаНачалаДействияФормы 
		   ИЛИ ДляВыбораПриСозданииОтчета
		   Тогда

			// Перебираемая запись из таблицы форм удовлетворяет текущим параметрам
			// учитывая конец периода отчета.
			//#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			#Если НаКлиенте Тогда
				НоваяФорма = Форма.РезультирующаяТаблица.Добавить();
			#Иначе
				НоваяФорма = РезультирующаяТаблица.Добавить();
			#КонецЕсли
			НоваяФорма.ФормаОтчета        = ЭлФорма.ФормаОтчета;
			НоваяФорма.ОписаниеОтчета     = ЭлФорма.ОписаниеОтчета;
			НоваяФорма.ДатаНачалоДействия = ЭлФорма.ДатаНачалоДействия;
			НоваяФорма.ДатаКонецДействия  = ЭлФорма.ДатаКонецДействия;

		КонецЕсли;

	КонецЦикла;

	//#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
	#Если НаКлиенте Тогда
		Возврат Форма.РезультирующаяТаблица;
	#Иначе
		Возврат РезультирующаяТаблица;
	#КонецЕсли
	
КонецФункции


Процедура ОбновитьСтруктуруМногострочныхРазделов(Форма) Экспорт
	// Заполняет таблицу значений многострочного раздела
	// указанными в соответствующих ячейках значениями

	// Заполнение выполняется синхронно для всех многострочных разделов
	Для Каждого ЭлементСтруктуры Из Форма.мСтруктураМногострочныхРазделов Цикл
		ИмяГруппы = ЭлементСтруктуры.Ключ;
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			Форма.ОбновитьСтруктуруМногострочногоРазделаНаКлиенте(ИмяГруппы);
		#Иначе
			Форма.ОбновитьСтруктуруМногострочногоРазделаНаСервере(ИмяГруппы);
		#КонецЕсли
	КонецЦикла;
	
КонецПроцедуры


Функция КолвоЛистоВРазделе(Форма, ИмяСтраницыПанели) Экспорт

	ФлагИскл = 0;
	КолЛистовВОдномерномЛисте = 1;

	ТекТаблПоле = Форма["ПолеТабличногоДокумента" + ИмяСтраницыПанели];

	Пока ФлагИскл = 0 Цикл

		Если КолЛистовВОдномерномЛисте = 1 Тогда
			КолЛистовВОдномерномЛистеСтр = "";
		Иначе
			КолЛистовВОдномерномЛистеСтр = Формат(Число(КолЛистовВОдномерномЛисте)) + "_";
		КонецЕсли;

		Если ТекТаблПоле.Области.Найти("НомСтр" + КолЛистовВОдномерномЛистеСтр + "1") <> Неопределено Тогда

			КолЛистовВОдномерномЛисте = КолЛистовВОдномерномЛисте + 1;

		Иначе

			КолЛистовВОдномерномЛисте = КолЛистовВОдномерномЛисте - 1;
			ФлагИскл = 1;

		КонецЕсли;

	КонецЦикла;// пока искл = 0

	Возврат КолЛистовВОдномерномЛисте;

КонецФункции


Процедура УстановитьЦветФонаЯчейки(Форма, ИмяЯчейки = Неопределено, ВариантЗаполнения = Неопределено, ИмяТекущейСтраницыПанели = "") Экспорт
	Перем ЦветФона;
	Перем Комментарий;

	// Не нужно разукрашивать табличные поля, если открывается без открытия формы (например печать или просмотр)
	Если Форма.СтруктураРеквизитовФормы.мБезОткрытияФормы Или Форма.СтруктураРеквизитовФормы.мРежимПечати Тогда
		Возврат;
	КонецЕсли;

	Если Не ИмяЯчейки = Неопределено Тогда
		// устанавливаем цвет фона конкретной ячейки
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			ИмяСтраницыПанели = РегламентированнаяОтчетностьКлиент.ОпределитьСтраницуПанелиПоКодуПоказателяНаКлиенте(Форма, ИмяЯчейки);
		#Иначе
			ИмяСтраницыПанели = РегламентированнаяОтчетностьВызовСервера.ОпределитьСтраницуПанелиПоКодуПоказателяНаСервере(Форма, ИмяЯчейки);
		#КонецЕсли
		Если ИмяСтраницыПанели = Неопределено Тогда
			Возврат;
		КонецЕсли;

		ИмяПоляТаблДокумента = "ТабличныйДокумент";

		Ключ = "_" + ВариантЗаполнения;
		Форма.мСтруктураЦветовРаскраски.Свойство(Ключ, ЦветФона);

		// КодПоказателяПоСтруктуре
		ЗначениеВКвадратах = ОбластьЯвляетсяЯчейкойСоставногоПоля(Форма, ИмяЯчейки);

		Если ВариантЗаполнения = 4 Тогда

			Если ЗначениеВКвадратах Тогда
				// если ЗНАЧЕНИЕ КВАДРАТИЧНОЕ
				СвойстваГрупповыхЗначений(Форма, ИмяЯчейки,"УстановитьЗащиту");
			Иначе
				Форма[ИмяПоляТаблДокумента].Области[ИмяЯчейки].Защита = Истина;
			КонецЕсли;

		Иначе

			Если ЗначениеВКвадратах Тогда
				// если ЗНАЧЕНИЕ КВАДРАТИЧНОЕ
				СвойстваГрупповыхЗначений(Форма, ИмяЯчейки,"СнятьЗащиту");
			Иначе
				Форма[ИмяПоляТаблДокумента].Области[ИмяЯчейки].Защита = Ложь;
			КонецЕсли;
			
		КонецЕсли;

		// установим цвет ячейки
		Если ЗначениеВКвадратах Тогда
			СвойстваГрупповыхЗначений(Форма, ИмяЯчейки,"ПроставитьЦветРаскраски", ЦветФона);
		Иначе
			Форма[ИмяПоляТаблДокумента].Области[ИмяЯчейки].ЦветФона = ЦветФона;
		КонецЕсли;

	Иначе
		// устанавливаем цвет фона всех автозаполняемых ячеек активной страницы

		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			ТаблицаВариантыЗаполнения = РегламентированнаяОтчетностьКлиент.ПолучитьТаблицуВариантовЗаполненияНаКлиенте(Форма, ИмяТекущейСтраницыПанели);
		#Иначе
			ТаблицаВариантыЗаполнения = РегламентированнаяОтчетностьВызовСервера.ПолучитьТаблицуВариантовЗаполненияНаСервере(Форма, ИмяТекущейСтраницыПанели);
		#КонецЕсли
		
		Если ТаблицаВариантыЗаполнения = Неопределено Тогда
			Возврат;
		КонецЕсли;

		Для Каждого Строка Из ТаблицаВариантыЗаполнения Цикл
			ИмяПоказателя            =  Строка.КодПоказателя;
			ВариантЗаполнения        =  Строка.ВариантЗаполнения;
			Комментарий              =  Строка.Комментарий;
			КодПоказателяПоСтруктуре =  Строка.КодПоказателяПоСтруктуре;

			КолвоСтрокВМногострочнойЧасти = ПоказательВходитВМногострочнуюЧасть(Форма, ИмяПоказателя);

			Если КолвоСтрокВМногострочнойЧасти > 0 Тогда
				Многострочность = Истина;
				БазоваяЧасть = ИмяПоказателя;
				ОписанияБлоков = ПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "МногострочностьВРазделе");

				Если ТипЗнч(ОписанияБлоков) = Тип("Число") Тогда
					ВБлокеВсеПоказателиЗаполняются = Истина;
				ИначеЕсли ТипЗнч(ОписанияБлоков) = Тип("ДанныеФормыКоллекция") Тогда
					ИмяГруппы = Сред(ИмяПоказателя, 1, 11);
					ВБлокеВсеПоказателиЗаполняются = НЕ ОписанияБлоков.НайтиСтроки(Новый Структура("ИдГруппы", ИмяГруппы))[0].НезаполняемыеПоказателиЕсть;
				КонецЕсли;

			Иначе
				Многострочность = Ложь;
				ВБлокеВсеПоказателиЗаполняются = Истина;
				КолвоСтрокВМногострочнойЧасти = 1;
			КонецЕсли;

			Для Инд = 1 по КолвоСтрокВМногострочнойЧасти Цикл

				Если Многострочность Тогда
					ИмяПоказателя = БазоваяЧасть + "_" + Формат(Инд, "ЧГ=0");
					// Декларация по НДС. В многострочном блоке встречаются строки, которые не должны быть закрашены в стандартный зеленый цвет.
					
				КонецЕсли;

				Если НЕ ВБлокеВсеПоказателиЗаполняются Тогда
					
					#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
						ЭтотПоказательНеЗаполняется = Форма.ЭтотПоказательНеЗаполняетсяНаКлиенте(ИмяПоказателя);
					#Иначе
						ЭтотПоказательНеЗаполняется = Форма.ЭтотПоказательНеЗаполняетсяНаСервере(ИмяПоказателя);
					#КонецЕсли
					
					Если ЭтотПоказательНеЗаполняется Тогда
						Продолжить;
					КонецЕсли;
					
				КонецЕсли;

				ТекОбластьЯчеек = Форма.ТабличныйДокумент.Области[ИмяПоказателя];
				Если (Не ПустаяСтрока(Комментарий)) ИЛИ (Не ПустаяСтрока(ТекОбластьЯчеек.Примечание.Текст)) Тогда
					ТекОбластьЯчеек.Примечание.Текст = Комментарий;
				КонецЕсли;

				Ключ = "_" + ВариантЗаполнения;
				Форма.мСтруктураЦветовРаскраски.Свойство(Ключ, ЦветФона);

				//ЗначениеВКвадратах = ОбластьЯвляетсяЯчейкойСоставногоПоля(Форма, ИмяПоказателя);
				ЗначениеВКвадратах = ?(ПустаяСтрока(КодПоказателяПоСтруктуре), Ложь, Истина);

				Если ВариантЗаполнения = 4 Тогда

					Если ЗначениеВКвадратах Тогда
						// если ЗНАЧЕНИЕ КВАДРАТИЧНОЕ
						СвойстваГрупповыхЗначений(Форма, ИмяПоказателя, "УстановитьЗащиту");
					Иначе
						Форма.ТабличныйДокумент.Области[ИмяПоказателя].Защита = Истина;
					КонецЕсли;

				Иначе

					Если ЗначениеВКвадратах Тогда
						// если ЗНАЧЕНИЕ КВАДРАТИЧНОЕ
						СвойстваГрупповыхЗначений(Форма, ИмяПоказателя,"СнятьЗащиту");
					Иначе
						Форма.ТабличныйДокумент.Области[ИмяПоказателя].Защита = Ложь;
					КонецЕсли;
				КонецЕсли;

				Если ЗначениеВКвадратах Тогда
					СвойстваГрупповыхЗначений(Форма, ИмяПоказателя,"ПроставитьЦветРаскраски", ЦветФона);
				Иначе
					Форма.ТабличныйДокумент.Области[ИмяПоказателя].ЦветФона = ЦветФона;
				КонецЕсли;
			КонецЦикла;

		КонецЦикла;
	КонецЕсли;

КонецПроцедуры


Функция ОбластьЯвляетсяЯчейкойСоставногоПоля(Форма, ИмяЯчейки, БыстраяПроверка = Истина) Экспорт

		СмысловаяЧасть = ПолучитьСмысловуюЧастьИмениЯчейки(ИмяЯчейки);
		Если СмысловаяЧасть = "" Тогда
			// не квадратичная ячейка
			Возврат Ложь;
		КонецЕсли;

		Если БыстраяПроверка Тогда
			Возврат Истина;
		КонецЕсли;

		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			ИмяСтраницыПанели = РегламентированнаяОтчетностьКлиент.ОпределитьСтраницуПанелиПоКодуПоказателяНаКлиенте(Форма, ИмяЯчейки);
		#Иначе
			ИмяСтраницыПанели = РегламентированнаяОтчетностьВызовСервера.ОпределитьСтраницуПанелиПоКодуПоказателяНаСервере(Форма, ИмяЯчейки);
		#КонецЕсли
		
		Если ИмяСтраницыПанели = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;

		ИмяПоляТаблДокумента = "ПолеТабличногоДокумента" + ИмяСтраницыПанели;

		// Получаем текущий счетчик
		//ТекущийСчетчик = Сред(ИмяЯчейки,АдресПоследнегоРазделителя+1,СтрДлина(ИмяЯчейки)-АдресПоследнегоРазделителя);
		ТекущийСчетчик = ПолучитьСмысловуюЧастьИмениЯчейки(ИмяЯчейки,Ложь);
		Если СтрДлина(ТекущийСчетчик) >= 2 Тогда

			Если Сред(ТекущийСчетчик, 1, 1) = "0" Тогда
				ПризнакСчетчикаСнулемВпереди = Истина;
			Иначе
				ПризнакСчетчикаСнулемВпереди = Ложь;
			КонецЕсли;
		Иначе
			ПризнакСчетчикаСнулемВпереди = Ложь; // перед счетчиком нет нуля
		КонецЕсли;

		Если ЯвляетсяЧислом(ТекущийСчетчик) Тогда
			ТекущийСчетчикЦел = ТекущийСчетчик;
		Иначе
			Возврат Ложь;
		КонецЕсли;

		Координата = СмысловаяЧасть + ?(ПризнакСчетчикаСнулемВпереди = Истина,"0" + Формат(ТекущийСчетчикЦел + 1, "ЧГ=0"),ТекущийСчетчикЦел + 1);

		Если Форма[ИмяПоляТаблДокумента].Области.Найти(Координата) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;

		// значение получено
		Возврат Истина;

КонецФункции


Процедура ПрорисоватьПодменюПечать(Форма) Экспорт
	
	Форма.Элементы.ПечататьСразу.Доступность = Истина;
	Форма.Элементы.ПоказатьБланк.Доступность = Истина;
	
	Форма.Элементы.ПечататьСразу.Видимость = Истина;
	Форма.Элементы.ПоказатьБланк.Видимость = Истина;
		
КонецПроцедуры


Процедура УстановитьФорматВывода(Форма, НаимРаздела) Экспорт
	Перем СтруктураГруппы;
	Перем РазмерностьПрописьюТекст;

	ЕдиницаИзмерения = Форма.СтруктураРеквизитовФормы.ЕдиницаИзмерения;
	ТочностьЕдиницыИзмерения = Форма.СтруктураРеквизитовФормы.ТочностьЕдиницыИзмерения;
	Если ЕдиницаИзмерения = Форма.ПорядкиОкругленияОтчетности.ПеречислениеПорядкиОкругленияОтчетностиОкр1 Тогда
		Форма.СтруктураРеквизитовФормы.мДелитель = 1;
		РазмерностьПрописьюТекст = "в гривнях";
		Форма.СтруктураРеквизитовФормы.мСтрокаФормата = "ЧЦ = 17; ЧДЦ = " + ТочностьЕдиницыИзмерения + "; ЧРД=,; ЧН=-; ЧС = 0";

	ИначеЕсли ЕдиницаИзмерения = Форма.ПорядкиОкругленияОтчетности.ПеречислениеПорядкиОкругленияОтчетностиОкр1000 Тогда
		Форма.СтруктураРеквизитовФормы.мДелитель = 1000;
		РазмерностьПрописьюТекст = "в тис. гривень";
		Форма.СтруктураРеквизитовФормы.мСтрокаФормата = "ЧЦ = 17; ЧДЦ = " + ТочностьЕдиницыИзмерения + "; ЧРД=,; ЧН=-; ЧС = 3";
		
	ИначеЕсли ЕдиницаИзмерения = Форма.ПорядкиОкругленияОтчетности.ПеречислениеПорядкиОкругленияОтчетностиОкр1000000 Тогда
		Форма.СтруктураРеквизитовФормы.мДелитель = 1000000;
		РазмерностьПрописьюТекст = "в млн. гривень";
		Форма.СтруктураРеквизитовФормы.мСтрокаФормата = "ЧЦ = 17; ЧДЦ = " + ТочностьЕдиницыИзмерения + "; ЧРД=,; ЧН=-; ЧС = 6";
		
	КонецЕсли;

	Для Каждого СтрПоказатели Из Форма.мТаблицаСоставПоказателей Цикл

		Если НЕ НаимРаздела = СтрПоказатели.ИмяПоляТаблДокумента Тогда
			Продолжить;
		КонецЕсли;
		
		КодПоказателя        = СокрП(СтрПоказатели.КодПоказателяПоСоставу);
		ПризнМногострочность = СокрП(СтрПоказатели.ПризнМногострочности);
		КодПоказателяПоСтруктуре = СокрП(СтрПоказатели.КодПоказателяПоСтруктуре);
		КодПоказателяПоФорме = СокрП(СтрПоказатели.КодПоказателяПоФорме);
        		
		Если КодПоказателя = "===" Тогда
			Прервать;
		КонецЕсли;

		Если (Лев(КодПоказателя, 2) = "//") ИЛИ (КодПоказателя = "###") Тогда
			Продолжить;
		КонецЕсли;

		КодПоказателяВФорме = СокрП(СтрПоказатели.КодПоказателяПоФорме);

		ИмяПоказателя = КодПоказателя;
		Если Не ПустаяСтрока(КодПоказателяВФорме) Тогда
			ИмяПоказателя = КодПоказателяВФорме;
		КонецЕсли;

		ТипДанныхПоказателя = СокрП(СтрПоказатели.ТипДанныхПоказателя);
        		
		Если (ТипДанныхПоказателя = "Е") И (ПустаяСтрока(КодПоказателяПоСтруктуре)) Тогда

			ТекТабличноеПоле = Форма.ТабличныйДокумент;

			Если ПризнМногострочность <> "/" Тогда
				ФорматируемаяОбласть = ТекТабличноеПоле.Области[ИмяПоказателя];
				// Получим установленный в ячейки признак допустимого знака.
				ДопустимыйЗнакПоказателя = ФорматируемаяОбласть.ТипЗначения.КвалификаторыЧисла.ДопустимыйЗнак;

				ЧислоЕЗнак = Форма.СтруктураРеквизитовФормы.мОписаниеТиповЧислоЕ;
				Если ДопустимыйЗнакПоказателя = ДопустимыйЗнак.Неотрицательный Тогда
					// Создадим числовой тип на основе мОписаниеТиповЧислоЕ, с учетом знака отрицательности.
					Массив = Новый Массив;
					Массив.Добавить(Тип("Число"));
					КвалификаторЧисла = Новый КвалификаторыЧисла(ЧислоЕЗнак.КвалификаторыЧисла.Разрядность,ЧислоЕЗнак.КвалификаторыЧисла.РазрядностьДробнойЧасти, ДопустимыйЗнакПоказателя);
					ЧислоЕЗнак = Новый ОписаниеТипов(Массив, КвалификаторЧисла);
				КонецЕсли;
				ФорматируемаяОбласть.ТипЗначения = ЧислоЕЗнак;
				ФорматируемаяОбласть.Формат = Форма.СтруктураРеквизитовФормы.мСтрокаФормата;
			Иначе
				// определяем кол-во строк многострочного раздела
				// и применяем процедуру форматирования к данной графе
				// по всем строкам
				ИмяГруппы = Лев(ИмяПоказателя, 11);
				Форма.мСтруктураМногострочныхРазделов.Свойство(ИмяГруппы, СтруктураГруппы);
				СтруктураГруппы = Форма[СтруктураГруппы];
				ОписанияБлоков = ПолучитьСвойствоРаздела(Форма, НаимРаздела, "МногострочностьВРазделе");
				ОписанияБлоковТип = ТипЗнч(ОписанияБлоков);
				Если ОписанияБлоковТип = Тип("Число") Тогда
					ВБлокеВсеПоказателиЗаполняются = Истина;
				ИначеЕсли ОписанияБлоковТип = Тип("ДанныеФормыКоллекция") Тогда
					#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
						ВБлокеВсеПоказателиЗаполняются = НЕ ОписанияБлоков.НайтиСтроки(Новый Структура("ИдГруппы", ИмяГруппы))[0].НезаполняемыеПоказателиЕсть;
					#Иначе
						ВБлокеВсеПоказателиЗаполняются = НЕ ДанныеФормыВЗначение(ОписанияБлоков, Тип("ТаблицаЗначений")).Найти(ИмяГруппы, "ИдГруппы").НезаполняемыеПоказателиЕсть;
					#КонецЕсли
				КонецЕсли;

				Для НСтр = 1 По СтруктураГруппы.Количество() Цикл
					Если НЕ ВБлокеВсеПоказателиЗаполняются Тогда
						
						#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
							ЭтотПоказательНеЗаполняется = Форма.ЭтотПоказательНеЗаполняетсяНаКлиенте(ИмяПоказателя + "_" + Формат(НСтр, "ЧГ=0"));
						#Иначе
							ЭтотПоказательНеЗаполняется = Форма.ЭтотПоказательНеЗаполняетсяНаСервере(ИмяПоказателя + "_" + Формат(НСтр, "ЧГ=0"));
						#КонецЕсли
						
						Если ЭтотПоказательНеЗаполняется Тогда
							Продолжить;
						КонецЕсли;
						
					КонецЕсли;

					ФорматируемаяОбласть = ТекТабличноеПоле.Области[ИмяПоказателя + "_" + Формат(НСтр, "ЧГ=0")];
					// Получим установленный в ячейки признак допустимого знака.
					ДопустимыйЗнакПоказателя = ФорматируемаяОбласть.ТипЗначения.КвалификаторыЧисла.ДопустимыйЗнак;

					ЧислоЕЗнак = Форма.СтруктураРеквизитовФормы.мОписаниеТиповЧислоЕ;
					Если ДопустимыйЗнакПоказателя = ДопустимыйЗнак.Неотрицательный Тогда
						// Создадим числовой тип на основе мОписаниеТиповЧислоЕ, с учетом знака отрицательности.
						Массив = Новый Массив;
						Массив.Добавить(Тип("Число"));
						КвалификаторЧисла = Новый КвалификаторыЧисла(ЧислоЕЗнак.КвалификаторыЧисла.Разрядность,ЧислоЕЗнак.КвалификаторыЧисла.РазрядностьДробнойЧасти, ДопустимыйЗнакПоказателя);
						ЧислоЕЗнак = Новый ОписаниеТипов(Массив, КвалификаторЧисла);
					КонецЕсли;

					ФорматируемаяОбласть.ТипЗначения = ЧислоЕЗнак;
					ФорматируемаяОбласть.Формат = Форма.СтруктураРеквизитовФормы.мСтрокаФормата;

				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
    
	КонецЦикла;

КонецПроцедуры


Функция ПредставлениеДокументаРеглОтч(Док) Экспорт
	
	Если ТипЗнч(Док) = Тип("ДокументСсылка.РегламентированныйОтчет") Тогда
		Представление = "" + Док.НаименованиеОтчета + " за " + ПредставлениеПериода(НачалоДня(Док.ДатаНачала), КонецДня(Док.ДатаОкончания), "ФП=Истина");
	ИначеЕсли ТипЗнч(Док) = Тип("ДанныеФормыЭлементКоллекции") Тогда
		Представление = "" + Док.Отчет + " за " + ПредставлениеПериода(НачалоДня(Док.ДатаНачала), КонецДня(Док.ДатаОкончания), "ФП=Истина");
	ИначеЕсли ТипЗнч(Док) = Тип("Структура") И Док.Свойство("НаименованиеОтчета") Тогда
		Представление = "" + Док.НаименованиеОтчета + " за " + ПредставлениеПериода(НачалоДня(Док.ДатаНачала), КонецДня(Док.ДатаОкончания), "ФП=Истина");
	Иначе
		Представление = """ за " + ПредставлениеПериода(НачалоДня(Док.ДатаНачала), КонецДня(Док.ДатаОкончания), "ФП=Истина");
	КонецЕсли;
			
	Возврат Представление;
	
КонецФункции


Процедура ПослеВставкиДополнительнойСтраницы(Форма, ИмяВставляемойСтраницы, ПерейтиНаВставленныйЛист = Истина) Экспорт
	
	ТекущийЭлемент = Форма.РазделыОтчета.НайтиПоИдентификатору(Форма.Элементы.РазделыОтчета.ТекущаяСтрока);
	
	Родитель = ТекущийЭлемент.ПолучитьРодителя();

	Если НЕ Родитель = Неопределено Тогда
		ТекущийЭлемент = Родитель;
	КонецЕсли;
    	
	НомерДобавляемойСтраницы = ТекущийЭлемент.ПолучитьЭлементы().Количество() + 1;
    	
	ДобавляемаяСтраница = ТекущийЭлемент.ПолучитьЭлементы().Добавить();
	ДобавляемаяСтраница.КолонкаРазделыОтчета              = НСтр("ru='Стр. ';uk='Стр. '") + НомерДобавляемойСтраницы;
	ДобавляемаяСтраница.КолонкаРазделыОтчетаСокрНаим      = ТекущийЭлемент.КолонкаРазделыОтчетаСокрНаим;
	ДобавляемаяСтраница.КолонкаНомерСтраницыРазделаОтчета = НомерДобавляемойСтраницы;
	ДобавляемаяСтраница.ИндексКартинки                    = 1;
	ДобавляемаяСтраница.РазделМногостраничный             = ТекущийЭлемент.РазделМногостраничный;
	ДобавляемаяСтраница.РазделМногострочный               = ТекущийЭлемент.РазделМногострочный;
	
	Если ПерейтиНаВставленныйЛист Тогда
		Форма.Элементы.РазделыОтчета.ТекущаяСтрока = ДобавляемаяСтраница.ПолучитьИдентификатор();
	КонецЕсли;

КонецПроцедуры


Процедура ОчиститьПоказателиОтчетаЗаполняемыеИзИБ(Форма, НазванияМногостраничныхРазделовДляУдаления = "") Экспорт

	Если НЕ ПустаяСтрока(НазванияМногостраничныхРазделовДляУдаления) Тогда
		НазванияМнгостраничныхРазделов = Новый Структура(НазванияМногостраничныхРазделовДляУдаления);
	Иначе
		НазванияМнгостраничныхРазделов = Новый Структура;
	КонецЕсли;

	Для каждого СтрокаУровня1 из Форма.мСвойстваРазделовДекларации.ПолучитьЭлементы() Цикл
		НазваниеСтраницы           = СтрокаУровня1.ИмяСтраницы;
		МногостраничностьВРазделе  = СтрокаУровня1.МногостраничностьВРазделе;
		РазделАвтозаполняется = СтрокаУровня1.РазделЯвляетсяАвтозаполняемым;

		Если НЕ НазваниеСтраницы = НазванияМногостраничныхРазделовДляУдаления Тогда
			Продолжить;
		КонецЕсли;

		мРазделИмя = "ТабличныйДокумент";
		мРаздел    = Форма[мРазделИмя];
		Если НазванияМнгостраничныхРазделов.Свойство(НазваниеСтраницы) Тогда
			// Очистим текущий лист.
			#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
				Форма.ОчиститьТабличноеПолеНаКлиенте(НазваниеСтраницы);
			#Иначе
				Форма.ОчиститьТабличноеПолеНаСервере(НазваниеСтраницы);
			#КонецЕсли
							
			ТаблицаСтраницРаздела = Неопределено;
			Форма.мСтруктураМногостраничныхРазделов.Свойство(НазваниеСтраницы, ТаблицаСтраницРаздела);
			
			ТаблицаСтраницРаздела = Форма[ТаблицаСтраницРаздела];
			
			ИндексСтраницы = 0;
			Пока Не (ИндексСтраницы > (ТаблицаСтраницРаздела.Количество()-1)) Цикл
				СтрокаТаблицы = ТаблицаСтраницРаздела[ИндексСтраницы];
				Если НЕ СтрокаТаблицы.АктивнаяСтраница Тогда
					// удаляем дополнительную страницу
					ТаблицаСтраницРаздела.Удалить(СтрокаТаблицы);
					Продолжить;
				КонецЕсли;
				ИндексСтраницы = ИндексСтраницы + 1;
			КонецЦикла;
									
			// Варианты заполнения установим в один массив. Все варианты возьмем из Эталона.
			// Цвет ячеек перерисуется в показе статика многостраничного раздела, ниже.
			ОчиститьВариантыЗаполнения(Форма, НазваниеСтраницы, Ложь);
			
			Продолжить;

		КонецЕсли;
		
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			ВариантыАвтозаполнения = РегламентированнаяОтчетностьКлиент.ПолучитьТаблицуВариантовЗаполненияНаКлиенте(Форма, НазваниеСтраницы);
		#Иначе
			ВариантыАвтозаполнения = РегламентированнаяОтчетностьВызовСервера.ПолучитьТаблицуВариантовЗаполненияНаСервере(Форма, НазваниеСтраницы);
		#КонецЕсли

		Если ВариантыАвтозаполнения <> Неопределено Тогда

			Если ВариантыАвтозаполнения[0].Свойство("КодПоказателяПоСтруктуре") Тогда
				ПоказательПоСтруктуре = Истина;
			Иначе
				ПоказательПоСтруктуре = Ложь;
			КонецЕсли;

			// Переберем все показатели, которые могут заполняться из ИБ или автозаполняемые.
			Для каждого Пок Из ВариантыАвтозаполнения Цикл

				Если ПоказательПоСтруктуре Тогда
					Если НЕ ПустаяСтрока(Пок.КодПоказателяПоСтруктуре) Тогда
						// Для показателей квадратичных, очистка произойдет через Расчет()
						Продолжить;
					КонецЕсли;
				КонецЕсли;

				КодПоказателя = Пок.КодПоказателя;
				Если (Пок.ВариантЗаполнения = 3) Тогда // Или (Пок.ВариантЗаполнения = 4) Тогда
					// Если показатель в многострочной части, вернем кол-во строк блока.
					Колво = ПоказательВходитВМногострочнуюЧасть(Форма, КодПоказателя);
					Если Колво = 0 Тогда
						мРаздел.Области[КодПоказателя].Очистить();
					Иначе
						Для Инд = 1 По Колво Цикл
							мРаздел.Области[КодПоказателя + "_" + Формат(Инд, "ЧГ=0")].Очистить();
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;

	КонецЦикла;
	
КонецПроцедуры


Процедура ОчиститьВариантыЗаполнения(Форма, Знач Раздел = Неопределено, УстановитьЦветВРазделе = Истина) Экспорт

	Перем МассивВариантовЗаполненияСтраниц;

	// Данная процедура используется только в новых декларациях, где установлены показатели Е как 14.2
	// Через процеудру УстановитьФормат

	мОписаниеТиповЧислоЕ = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(14, 2));
	ИзмененияЕсть = Ложь;
	Для Каждого СтрокаУровня1 Из Форма.мСвойстваРазделовДекларации.ПолучитьЭлементы() Цикл
		// Считываем название раздела и его свойство в системе автозаполнения
		НазваниеСтраницы = СтрокаУровня1.ИмяСтраницы;
		Если Раздел <> Неопределено Тогда
			Если Раздел <> НазваниеСтраницы Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		//АвтоЗаполнение   = СтрокаУровня1.РазделЯвляетсяАвтозаполняемым;

		Если Форма.мСтруктураВариантыЗаполнения.Свойство(НазваниеСтраницы, МассивВариантовЗаполненияСтраниц) Тогда
			
			МассивВариантовЗаполненияСтраниц = Форма["ТаблицаВариантыЗаполнения" + НазваниеСтраницы];
			
			// Получим ЭТАЛОННЫЙ макет вариантов показателей.
			#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
				ТаблицаВариантыЗаполнения = РегламентированнаяОтчетностьКлиент.ПолучитьТаблицуВариантовЗаполненияНаКлиенте(Форма, НазваниеСтраницы, Истина, мОписаниеТиповЧислоЕ);
			#Иначе
				ТаблицаВариантыЗаполнения = РегламентированнаяОтчетностьВызовСервера.ПолучитьТаблицуВариантовЗаполненияНаСервере(Форма, НазваниеСтраницы, Истина, мОписаниеТиповЧислоЕ);
			#КонецЕсли

			// Сюда попадают Титульные, ФизЛица и др.
			Если ТаблицаВариантыЗаполнения <> Неопределено Тогда
				
				МассивВариантовЗаполненияСтраниц.Очистить();
				
				// Вставим в массив эталонный вариант.
				ТаблВариантов = МассивВариантовЗаполненияСтраниц.Добавить();
				
				#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
					КопироватьДанныеФормы(ТаблицаВариантыЗаполнения, ТаблВариантов);
				#Иначе
					ТаблВариантов.ТаблицаВариантовЗаполнения.Загрузить(ТаблицаВариантыЗаполнения);
				#КонецЕсли
				
				Форма.мСтруктураВариантыЗаполнения.Вставить(НазваниеСтраницы, НазваниеСтраницы);
				
				ИзмененияЕсть = Истина;

			КонецЕсли;

		КонецЕсли;

	КонецЦикла;

	Если (ИзмененияЕсть) И (Форма.СтруктураРеквизитовФормы.ФлажокОтклАвтоРасчет) Тогда
		
		ИзменитьТаблицуВариантовЗаполнения(Форма, НЕ Форма.СтруктураРеквизитовФормы.ФлажокОтклАвтоРасчет);
		
	КонецЕсли;

	Если (ИзмененияЕсть) И (НЕ Форма.СтруктураРеквизитовФормы.ФлажокОтклАвтоРасчет) Тогда
		// Обеспечим простановку цветов ячеек.
		// Автоматически при переходах по вкладкам разделов устанавливаются цвета только
		// Для многостраничных разделов. Поэтому, если раздел не многостраничны и автозаполняется
		// тогда прорисовываем цвета, а также, если многостраничный, автозаполняемый и текущий лист,
		// также перерисуем.
		Для Каждого СтрокаУровня1 Из Форма.мСвойстваРазделовДекларации.ПолучитьЭлементы() Цикл
			ИмяСтраницы = СтрокаУровня1.ИмяСтраницы;

			// Возможно, нужный раздел передали через параметр. Тогда установим цвета только
			// в нужном разделе.
			Если Раздел <> Неопределено Тогда
				Если Раздел <> ИмяСтраницы Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;

			Автозаполняется = ПолучитьСвойствоРаздела(Форма, ИмяСтраницы, "РазделЯвляетсяАвтозаполняемым", Ложь);
			//Многостраничность = РегламентированнаяОтчетностьКлиентСервер.ПолучитьСвойствоРаздела(Форма, ИмяСтраницы, "МногостраничностьВРазделе", Ложь);

			// Перерисовка по цвету происходить должна и для многостр. и для обычного раздела.
			// Т.к. меняются варианты заполнения. Процедура запускается при очистки отчета в целом
			// и перед автозаполнением для многостраничных разделов заполняемых из ИБ (крайние случаи: имущество, прибыль).
			// 
			// В механизме очистки отчета в целом, предусмотре вызов роОчиститьВариантыЗаполнения, поэтому
			// при очистки из отчета, всей декларации необходимо перекрасить ячейки, т.к. варианты при очистка декларации
			// всегда становятся эталонными, а значит, перекрашиваем ячейки в соответствующий цвет.

			Если Автозаполняется И УстановитьЦветВРазделе И ИмяСтраницы = Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела Тогда
				
				#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
					Форма.УстановитьЦветФонаЯчейкиНаКлиенте(,,ИмяСтраницы);
				#Иначе
					Форма.УстановитьЦветФонаЯчейкиНаСервере(,,ИмяСтраницы);
				#КонецЕсли
									
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры


Процедура ИзменитьТаблицуВариантовЗаполнения(Форма, ПолныйРучнойВвод = Ложь) Экспорт

	Перем МассивВариантовЗаполненияСтраниц;
	мДеревоСтраницОтчета = Форма.мДеревоСтраницОтчета;
	ПереборЗнач = мДеревоСтраницОтчета.ПолучитьЭлементы().Количество();

	Пока ПереборЗнач > 0 цикл
		ИмяСтраницы = мДеревоСтраницОтчета.ПолучитьЭлементы()[ПереборЗнач-1].ИмяСтраницы;
		ПереборЗнач = ПереборЗнач-1;
		
		Попытка
			МногостраничностьЕсть = ?(Форма.мСтруктураМногостраничныхРазделов = Неопределено, Ложь, Истина);
		Исключение
			МногостраничностьЕсть = Ложь;
		КонецПопытки;
		
		Если МногостраничностьЕсть Тогда
			КолСтрВРазделе = ПолучитьКоличествоСтраницРаздела(Форма, ИмяСтраницы);
		Иначе
			КолСтрВРазделе = 1;
		КонецЕсли;
		
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			ТаблицаВариантыЗаполнения = РегламентированнаяОтчетностьКлиент.ПолучитьТаблицуВариантовЗаполненияНаКлиенте(Форма, ИмяСтраницы);
		#Иначе
			ТаблицаВариантыЗаполнения = РегламентированнаяОтчетностьВызовСервера.ПолучитьТаблицуВариантовЗаполненияНаСервере(Форма, ИмяСтраницы);
		#КонецЕсли

		Если ТаблицаВариантыЗаполнения = Неопределено Тогда
			Продолжить;
		КонецЕсли;

		Если НЕ ПолныйРучнойВвод Тогда

			Если КолСтрВРазделе = 1 Тогда

				Для Каждого Строка Из ТаблицаВариантыЗаполнения Цикл
					Если Строка.ВариантЗаполнения = 4 Тогда
						Строка.ВариантЗаполнения = 0; 
					КонецЕсли;
				КонецЦикла;

				#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
					Форма.УстановитьЦветФонаЯчейкиНаКлиенте(,,Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела);
				#Иначе
					Форма.УстановитьЦветФонаЯчейкиНаСервере(,,Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела);
				#КонецЕсли	
					
			КонецЕсли; 
			
			Если КолСтрВРазделе >= 2 Тогда

				Если Не Форма.мСтруктураВариантыЗаполнения.Свойство(ИмяСтраницы, МассивВариантовЗаполненияСтраниц) Тогда
					Продолжить;
				КонецЕсли;

				МассивВариантовЗаполненияСтраниц = Форма["ТаблицаВариантыЗаполнения" + ИмяСтраницы];
				
				Для Инд = 0 по МассивВариантовЗаполненияСтраниц.Количество() - 1 Цикл
					Для Каждого Строка Из МассивВариантовЗаполненияСтраниц[Инд].ТаблицаВариантовЗаполнения Цикл
						Если Строка.ВариантЗаполнения = 4 Тогда
							Строка.ВариантЗаполнения = 0;
						КонецЕсли; 
					КонецЦикла; 
				КонецЦикла; 
				
				#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
					Форма.УстановитьЦветФонаЯчейкиНаКлиенте(,,Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела); // текущую обновим
				#Иначе
					Форма.УстановитьЦветФонаЯчейкиНаСервере(,,Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела); // текущую обновим
				#КонецЕсли
									
			КонецЕсли;

		ИначеЕсли ПолныйРучнойВвод Тогда

			Если КолСтрВРазделе = 1 Тогда
				Для Каждого Стр Из ТаблицаВариантыЗаполнения Цикл
					Если Стр.ВариантЗаполнения = 0 Тогда
						Стр.ВариантЗаполнения = 4
					КонецЕсли;
				КонецЦикла;

				#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
					Форма.УстановитьЦветФонаЯчейкиНаКлиенте(,,Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела);
				#Иначе
					Форма.УстановитьЦветФонаЯчейкиНаСервере(,,Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела);
				#КонецЕсли
				
			КонецЕсли;

			Если КолСтрВРазделе >= 2 Тогда
				
				Если Не Форма.мСтруктураВариантыЗаполнения.Свойство(ИмяСтраницы, МассивВариантовЗаполненияСтраниц) Тогда
					Продолжить;
				КонецЕсли;

				МассивВариантовЗаполненияСтраниц = Форма["ТаблицаВариантыЗаполнения" + ИмяСтраницы];
				
				Для Инд = 0 по МассивВариантовЗаполненияСтраниц.Количество() - 1 Цикл
					
					Для Каждого Строка Из МассивВариантовЗаполненияСтраниц[Инд].ТаблицаВариантовЗаполнения Цикл
						Если Строка.ВариантЗаполнения = 0 Тогда
							Строка.ВариантЗаполнения = 4; 
						КонецЕсли; 
					КонецЦикла; 

				КонецЦикла; 

				#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
					Форма.УстановитьЦветФонаЯчейкиНаКлиенте(,,Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела);
				#Иначе
					Форма.УстановитьЦветФонаЯчейкиНаСервере(,,Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела);
				#КонецЕсли
				
			КонецЕсли; 

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры


Функция ПолучитьКоличествоСтраницРаздела(Форма, ИмяТекущейСтраницыПанели)
	
	Перем ТаблицаСтраницРаздела;
    
	Если Не Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяТекущейСтраницыПанели, ТаблицаСтраницРаздела) Тогда
		Возврат 1;
	КонецЕсли;

	ТаблицаСтраницРаздела = Форма[ТаблицаСтраницРаздела];
	
	КоличествоСтраниц    = Макс(ТаблицаСтраницРаздела.Количество(), 1);
	
	Возврат КоличествоСтраниц;
	
КонецФункции


Функция РазобратьСтрокуВМассивПоРазделителю(Знач Стр, СтрРазделитель = ".") Экспорт
	
	Результат = Новый Массив;
	
	ВхождениеРазделителя = Найти(Стр, СтрРазделитель);
	Пока ВхождениеРазделителя <> 0 Цикл
		ЧастьДоРазделителя = СокрЛП(Лев(Стр, ВхождениеРазделителя - 1));
		Результат.Добавить(ЧастьДоРазделителя);
		Стр = СокрЛП(Сред(Стр, ВхождениеРазделителя + 1));
		ВхождениеРазделителя = Найти(Стр, СтрРазделитель);
	КонецЦикла;
	
	Если НЕ ПустаяСтрока(Стр) Тогда
		Результат.Добавить(СокрЛП(Стр));
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции


Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт

	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;

	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";

	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';

	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;

	Иначе
		Возврат Новый (ЗаданныйТип);

	КонецЕсли;

КонецФункции


Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
						 
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);

КонецФункции


Процедура СообщитьОбОшибке(Знач ТекстСообщения, Отказ = Ложь, Заголовок = "", Знач Статус = Неопределено, ВызыватьИсключение = Истина) Экспорт
    	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
	Отказ = Истина;
	
	#Если Сервер Тогда
		ЗаписьЖурналаРегистрации(НСтр("ru='Контрольная запись. Регламентированная отчетность';uk='Контрольний запис. Регламентована звітність'"), УровеньЖурналаРегистрации.Ошибка, , , Заголовок + Символы.ПС + ТекстСообщения);
	
	#ИначеЕсли ВнешнееСоединение Тогда
		
		Если ВызыватьИсключение Тогда
			Если ЗначениеЗаполнено(Заголовок) Тогда
				ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
				Заголовок = "";
			КонецЕсли;
			
			ВызватьИсключение (ТекстСообщения);
		КонецЕсли;
		
	#Иначе
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			
			Сообщение = Новый СообщениеПользователю;

			Сообщение.Текст = Заголовок;

			Сообщение.Сообщить();
						
			Заголовок = "";
			
		КонецЕсли;
		
		Сообщение = Новый СообщениеПользователю;

		Сообщение.Текст = ТекстСообщения;

		Сообщение.Сообщить();
		
	#КонецЕсли
	
КонецПроцедуры


Процедура ПослеОчисткиРегламентированногоОтчета(Форма, ИмяСтраницы, ЗапускатьОтдельнуюОбработкуПослеОчисткиЛиста) Экспорт
	
	Форма.Модифицированность = Истина;
	
	// Если есть экспортная процедура ОперацииВыполняемыеПриУдаленииЭкземпляраМногостраничногоРаздела
	// определяющая действия после удаления экземплярности, тогда вызовем её.
	// Например, в этой процеудуре может быть перерасчет каких-то листов,
	Если ЗапускатьОтдельнуюОбработкуПослеОчисткиЛиста Тогда
		// Иммеет смысл только для многостраничного раздела.
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			Форма.СпециальныеОперацииПослеОчисткиЛистаНаКлиенте(ИмяСтраницы);
		#Иначе
			Форма.СпециальныеОперацииПослеОчисткиЛистаНаСервере(ИмяСтраницы);
		#КонецЕсли	
	Иначе
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			Форма.РасчетНаКлиенте(ИмяСтраницы);
		#Иначе
			Форма.РасчетНаСервере(ИмяСтраницы);
		#КонецЕсли
	КонецЕсли;
	
	Если ПолучитьСвойствоРаздела(Форма, ИмяСтраницы, "РазделЯвляетсяАвтозаполняемым") Тогда
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			Форма.УстановитьЦветФонаЯчейкиНаКлиенте(,, ИмяСтраницы);
		#Иначе
			Форма.УстановитьЦветФонаЯчейкиНаСервере(,, ИмяСтраницы);
		#КонецЕсли	
	КонецЕсли;
		
КонецПроцедуры


Функция НайтиЭлементВДанныхФормыДерево(ЭлементыДанныхФормыДерево, ИмяКолонки, ИскомоеЗначение) Экспорт
	
	Для Ном = 0 По ЭлементыДанныхФормыДерево.Количество() - 1 Цикл
		
		ЭлементДерева = ЭлементыДанныхФормыДерево.Получить(Ном);
		
		Если ЭлементДерева[ИмяКолонки] = ИскомоеЗначение Тогда
			Возврат ЭлементДерева;
		КонецЕсли;
		
		Если ЭлементДерева.ПолучитьЭлементы().Количество() > 0 Тогда
			
			РезультатПоиска = НайтиЭлементВДанныхФормыДерево(ЭлементДерева.ПолучитьЭлементы(), ИмяКолонки, ИскомоеЗначение);
			
			Если НЕ РезультатПоиска = Неопределено Тогда
				Возврат РезультатПоиска;
			КонецЕсли;
			
		КонецЕсли;
				
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции


Функция КоличествоФормСоответствующихВыбранномуПериоду(Форма) Экспорт

	ИтоговоеКоличество = 0;

	Для Каждого ЭлФорма Из Форма.мТаблицаФормОтчета Цикл

		ДатаНачалаДействияФормы = ЭлФорма.ДатаНачалоДействия;
		ДатаКонцаДействияФормы  = КонецДня(?(ЭлФорма.ДатаКонецДействия = РегламентированнаяОтчетностьКлиентСервер.ПустоеЗначениеТипа(Тип("Дата")), '20291231', ЭлФорма.ДатаКонецДействия));

		Если Форма.мДатаКонцаПериодаОтчета <= ДатаКонцаДействияФормы
		   И Форма.мДатаКонцаПериодаОтчета >= ДатаНачалаДействияФормы Тогда

			ИтоговоеКоличество = ИтоговоеКоличество + 1; 

		КонецЕсли;

	КонецЦикла;

	Возврат ИтоговоеКоличество;

КонецФункции


Процедура ВыборФормыРегламентированногоОтчетаПоУмолчанию(Форма) Экспорт
	ТаблицаФормОтчета = РегламентированнаяОтчетностьКлиентСервер.ПолучитьТаблицуОтчетовДействующихВВыбранныйПериод(Форма, Ложь);
	Для Каждого Стр Из ТаблицаФормОтчета Цикл
		Если Стр.ДатаКонецДействия = РегламентированнаяОтчетностьКлиентСервер.ПустоеЗначениеТипа(Тип("Дата")) Тогда
			Стр.ДатаКонецДействия = '20291231';
		КонецЕсли;
	КонецЦикла;

	ТаблицаФормОтчета.Сортировать("ДатаКонецДействия Убыв");

	Для Каждого Строка Из ТаблицаФормОтчета Цикл
		Если (Строка.ДатаНачалоДействия > КонецДня(Форма.мДатаКонцаПериодаОтчета)) ИЛИ
			((Строка.ДатаКонецДействия > '00010101000000') И (Строка.ДатаКонецДействия < НачалоДня(Форма.мДатаКонцаПериодаОтчета))) Тогда

			Продолжить;
		КонецЕсли;
		
		ТестСтруктура = Новый Структура("ПрямойМетод");
		ЗаполнитьЗначенияСвойств(ТестСтруктура, Форма);
		
		Если НЕ ТестСтруктура.ПрямойМетод = Неопределено Тогда
			
			Если  	  Найти(ВРЕГ(Строка.ФормаОтчета), ВРЕГ("НеПрямойМетод")) > 0 И Форма.ПрямойМетод = Ложь Тогда
				
				Форма.мВыбраннаяФорма 		= Строка.ФормаОтчета;
				Форма.ОписаниеНормативДок 	= Строка.ОписаниеОтчета;
				
			ИначеЕсли  Найти(ВРЕГ(Строка.ФормаОтчета), ВРЕГ("НеПрямойМетод")) = 0 И Форма.ПрямойМетод = Истина Тогда
				
				Форма.мВыбраннаяФорма 		= Строка.ФормаОтчета;
				Форма.ОписаниеНормативДок 	= Строка.ОписаниеОтчета;
				
			Иначе
				
				Продолжить;
				
			КонецЕсли;
			
		ИначеЕсли Форма.мПериодичность =  ПредопределенноеЗначение("Перечисление.Периодичность.Месяц") И Найти(Строка.ФормаОтчета, "Мес") > 0 Тогда
			Форма.мВыбраннаяФорма     = Строка.ФормаОтчета;
			Форма.ОписаниеНормативДок = Строка.ОписаниеОтчета;
		ИначеЕсли Форма.мПериодичность =  ПредопределенноеЗначение("Перечисление.Периодичность.Квартал") И Найти(Строка.ФормаОтчета, "Кв") > 0 Тогда
			Форма.мВыбраннаяФорма     = Строка.ФормаОтчета;
			Форма.ОписаниеНормативДок = Строка.ОписаниеОтчета;
		ИначеЕсли (    Форма.мПериодичность =  ПредопределенноеЗначение("Перечисление.Периодичность.Месяц")
				   ИЛИ Форма.мПериодичность =  ПредопределенноеЗначение("Перечисление.Периодичность.Квартал"))
			    И
			      (    Найти(Строка.ФормаОтчета, "Кв") > 0
				   ИЛИ Найти(Строка.ФормаОтчета, "Мес") > 0) Тогда	
			Продолжить;	   
		Иначе
			Форма.мВыбраннаяФорма 	  = Строка.ФормаОтчета;
			Форма.ОписаниеНормативДок = Строка.ОписаниеОтчета;
		КонецЕсли;	

		Возврат;
		
	КонецЦикла;

	// Если не удалось найти форму, соответствующую выбранному периоду,
	// то по умолчанию выдаем текущую (действующую) форму.
	Если Форма.мВыбраннаяФорма = Неопределено Тогда
		Если ТаблицаФормОтчета.Количество() >= 1 Тогда
			Форма.мВыбраннаяФорма = ТаблицаФормОтчета[0].ФормаОтчета;
			Форма.ОписаниеНормативДок = ТаблицаФормОтчета[0].ОписаниеОтчета;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры


Функция ПолучитьПредставлениеНуляИзСтрокиФормата(Знач СтрокаФормата) Экспорт 
	
	Если ПустаяСтрока(СтрокаФормата) Тогда
		Возврат "";
	КонецЕсли;
	
	СтрокаФорматаТекст = СтрЗаменить(СтрокаФормата, ";", Символы.ПС);
	Для НомерСтроки = 1 По СтрЧислоСтрок(СтрокаФорматаТекст) Цикл
		ПодстрокаФормата = СтрПолучитьСтроку(СтрокаФорматаТекст, НомерСтроки);
		Если Найти(ПодстрокаФормата, "ЧН=") > 0 Тогда
			Возврат СокрЛП(ПодстрокаФормата);
		КонецЕсли;
	КонецЦикла;
	
	Возврат "";
	
КонецФункции


Функция ЗаменитьПредставлениеНуляВСтрокеФормата(Знач СтрокаФормата, ПредставлениеНуля) Экспорт 
	
	НоваяСтрокаФормата = "";
	
	РазделительПодстрок = ";";
	СтрокаФорматаТекст = СтрЗаменить(СтрокаФормата, РазделительПодстрок, Символы.ПС);
	Для НомерСтроки = 1 По СтрЧислоСтрок(СтрокаФорматаТекст) Цикл
		ПодстрокаФормата = СокрЛП(СтрПолучитьСтроку(СтрокаФорматаТекст, НомерСтроки));
		Если ПустаяСтрока(ПодстрокаФормата) Тогда
			Продолжить;
		КонецЕсли;
		Если Найти(ПодстрокаФормата, "ЧН=") > 0 Тогда
			ПодстрокаФормата = ПредставлениеНуля;
		КонецЕсли;
		НоваяСтрокаФормата = НоваяСтрокаФормата + ?(ПустаяСтрока(НоваяСтрокаФормата), "", РазделительПодстрок) + ПодстрокаФормата;
	КонецЦикла;
	
	Если ПустаяСтрока(НоваяСтрокаФормата) Тогда
		Возврат ПредставлениеНуля;
	КонецЕсли;

	Возврат НоваяСтрокаФормата;
	
КонецФункции


Функция ПолучитьУникальныйИдентификаторДокумента(ДокументСсылка) Экспорт
	Возврат СтрЗаменить(Строка(ДокументСсылка.УникальныйИдентификатор()), "-", "");
КонецФункции

Функция СобратьДанныеТекущегоТаблПоля(Форма, ИмяТабличногоПоля) Экспорт 

	ТабличноеПоле = Форма[ИмяТабличногоПоля];

	СтруктураДанныхПоля = Новый Структура;

	Для Инд = 0 По ТабличноеПоле.Области.Количество() - 1 Цикл
		ТекущаяОбласть = ТабличноеПоле.Области[Инд];

		Если Не ТекущаяОбласть.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Прямоугольник Тогда
			Продолжить;
		КонецЕсли;

		Если НЕ(ТекущаяОбласть.СодержитЗначение) Тогда
			Продолжить;
		КонецЕсли;

		ИмяПоказателя      = ТекущаяОбласть.Имя;
		ЗначениеПоказателя = ТекущаяОбласть.Значение;

		СтруктураДанныхПоля.Вставить(ИмяПоказателя, ЗначениеПоказателя);
		
		// Сохраним формат отображения нуля для восстановления представления
		// в поле табличного документа и контроля выгрузки показателя в формате XML
		Если ТипЗнч(ЗначениеПоказателя) = Тип("Число") И ЗначениеПоказателя = 0 Тогда
			ФорматПредставленияНуля = ПолучитьПредставлениеНуляИзСтрокиФормата(ТекущаяОбласть.Формат);
			Если ЗначениеЗаполнено(ФорматПредставленияНуля) Тогда
				СтруктураДанныхПоля.Вставить("ЧН" + ИмяПоказателя, ФорматПредставленияНуля);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

	СтруктураДанныхПоля.Вставить("ОргАдрес", Форма.СтруктураРеквизитовФормы.мАдресвФорматеДляВыгрузки);

	Возврат СтруктураДанныхПоля;

КонецФункции

Процедура ЗаполнитьПоказателиОтчета(Форма, ПоказателиОтчета) Экспорт 
	Префикс = "ПолеТабличногоДокумента";
	
	Для Каждого Группа из Форма.Элементы.Страницы.ПодчиненныеЭлементы Цикл
		Для Каждого ЭлементГруппы Из Группа.ПодчиненныеЭлементы Цикл 
			Если СтрЧислоВхождений(ЭлементГруппы.Имя, Префикс) = 0 Тогда
				Продолжить;
			КонецЕсли;
			
			ПоказателиОтчета.Вставить(ЭлементГруппы.Имя, СобратьДанныеТекущегоТаблПоля(Форма, ЭлементГруппы.Имя));
			
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

Функция РазделТекущейОбласти(Форма, ТекущаяОбласть, ДлИмениОбласти = 13) Экспорт

	Если ТекущаяОбласть = Неопределено Тогда
		Возврат Неопределено; // отсутствует активная область табличного документа
	КонецЕсли;

	ИмяТекущейОбласти   = ТекущаяОбласть.Имя;
	ИмяАктивногоРаздела = Лев(ИмяТекущейОбласти, ДлИмениОбласти);
	
	Для Каждого ЭлементСтруктуры Из Форма.мСтруктураМногострочныхРазделов Цикл
		ИмяГруппы = ЭлементСтруктуры.Ключ;
		СтруктураГруппы = Форма[ЭлементСтруктуры.Значение];

		Если СтруктураГруппы[0].Свойство(ИмяАктивногоРаздела) Тогда
			Возврат ИмяГруппы;
		КонецЕсли;
	КонецЦикла;

	Возврат Неопределено;

КонецФункции

Процедура ДобавитьНеобходимоеКоличествоДопСтрок(Форма, ТекТабличноеПоле, ТекТабличноеПолеИмя, ИсходноеКоличествоСтрокГруппы, ТекущееКоличествоСтрокГруппы, ИмяГруппы, СтруктураГруппы) Экспорт
	
	ИмяОбласти = Форма.СтруктураРеквизитовФормы.мСоответствияМнгЧ[ИмяГруппы];
	
	МногострочнаяЧастьВерх = ТекТабличноеПоле.Области[ИмяОбласти].Верх;
	МногострочнаяЧастьНиз = МногострочнаяЧастьВерх + ИсходноеКоличествоСтрокГруппы - 1;
	
	ОбластьДопСтроки = ТекТабличноеПоле.ПолучитьОбласть("R" + Формат(МногострочнаяЧастьНиз, "ЧГ="));
	
	ТекТабличноеПоле.ВставитьОбласть(ОбластьДопСтроки.Область(), ТекТабличноеПоле.Область(МногострочнаяЧастьВерх + ИсходноеКоличествоСтрокГруппы, , МногострочнаяЧастьВерх + ТекущееКоличествоСтрокГруппы - 1), ТипСмещенияТабличногоДокумента.ПоВертикали);
	
	Для НомСтроки = ИсходноеКоличествоСтрокГруппы По ТекущееКоличествоСтрокГруппы Цикл
		
		НомНовойСтроки = ТекущееКоличествоСтрокГруппы - НомСтроки + ИсходноеКоличествоСтрокГруппы;
		
		Для Каждого Область Из ОбластьДопСтроки.Области Цикл
			
			ОбластьТаблДок = ТекТабличноеПоле.Область(МногострочнаяЧастьВерх + НомНовойСтроки - 1, Область.Лево, МногострочнаяЧастьВерх + НомНовойСтроки - 1, Область.Право);
			
			Если ОбластьТаблДок.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Прямоугольник Тогда
				
				Если ОбластьТаблДок.СодержитЗначение Тогда
					ОбластьТаблДок.Очистить();
				КонецЕсли;
				
				ОбластьТаблДок.Имя = Лев(Область.Имя, НайтиПоследнееВхождение(Область.Имя, "_")) + Формат(НомНовойСтроки, "ЧГ=");
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	ТекТабличноеПоле.Область(ИмяОбласти).Имя = "";
	
	ТекТабличноеПоле.Область(МногострочнаяЧастьВерх, , МногострочнаяЧастьВерх).Имя = ИмяОбласти;
	
КонецПроцедуры

// Возвращает части даты, для формирования полей "День","Месяц","Год" в реготчетах.
//
Функция ПолучитьЧастиДатыДляПодписи(Дата, Язык="uk_UA") Экспорт
	
	Результат = Новый Структура("День,Месяц,МесяцЦифрой,Год,ПоследняяЦифраГода,ДвеПоследниеЦифрыГода");
	
	Результат.День = Формат(День(Дата),"ЧГ=0");
	
	ДатаСтрокой = Формат(Дата,"ДЛФ = 'ДД';Л = uk_UA");
	ПозицияПервогоПробела = Найти(ДатаСтрокой," ");
	ПозицияВторогоПробела = Найти(Сред(ДатаСтрокой,ПозицияПервогоПробела+1)," ");
	Результат.Месяц = Сред(ДатаСтрокой,ПозицияПервогоПробела+1,ПозицияВторогоПробела-1);
	Результат.МесяцЦифрой = Формат(Дата, "ДФ=ММ");
	Результат.Год = Формат(Год(Дата),"ЧГ=0");
	
	Результат.ПоследняяЦифраГода = Сред(Результат.Год,4,1);
	Результат.ДвеПоследниеЦифрыГода = Сред(Результат.Год,3,2);
	
	Возврат Результат;
	
КонецФункции


Функция ОкруглитьЧислоПоФормату(Форма, ИсходноеЧисло) Экспорт 
	
	Перем Делитель;
	
	Если Форма.СоответствиеЕдиницыИзмеренияДелителю.Свойство("Окр" + СтрЗаменить(Форма.СтруктураРеквизитовФормы.ЕдиницаИзмерения, " ", ""), Делитель) Тогда
		
		Возврат Окр(ИсходноеЧисло / Делитель, Форма.СтруктураРеквизитовФормы.ТочностьЕдиницыИзмерения) * Делитель;
		
	КонецЕсли;
	
КонецФункции

Функция СравнитьКраткиеВерсииОтчетов(Версия1, Версия2) Экспорт
	
	// раскладываем версию 1 и преобразуем составляющие к числам
	ЧастиВерсии1 = РегламентированнаяОтчетностьКлиентСервер.РазобратьСтрокуВМассивПоРазделителю(Версия1, ".");
	ЧислоСоставляющихВерсии1 = ЧастиВерсии1.Количество();
	Для Инд = 0 По ЧислоСоставляющихВерсии1 - 1 Цикл
		ЧастьВерсии1 = ЧастиВерсии1[Инд];
		Если НЕ СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ЧастьВерсии1) Тогда
			Возврат Неопределено;
		КонецЕсли;
		ЧастиВерсии1[Инд] = Число(ЧастьВерсии1);
	КонецЦикла;
	
	// раскладываем версию 2 и преобразуем составляющие к числам
	ЧастиВерсии2 = РегламентированнаяОтчетностьКлиентСервер.РазобратьСтрокуВМассивПоРазделителю(Версия2, ".");
	ЧислоСоставляющихВерсии2 = ЧастиВерсии1.Количество();
	Для Инд = 0 По ЧислоСоставляющихВерсии2 - 1 Цикл
		ЧастьВерсии2 = ЧастиВерсии2[Инд];
		Если НЕ СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ЧастьВерсии2) Тогда
			Возврат Неопределено;
		КонецЕсли;
		ЧастиВерсии2[Инд] = Число(ЧастьВерсии2);
	КонецЦикла;
	
	// дополняем массив составляющих нулями, уравнивая число составляющих первой и второй версий
	Если ЧислоСоставляющихВерсии1 > ЧислоСоставляющихВерсии2 Тогда
		Для Инд = ЧислоСоставляющихВерсии2 + 1 По ЧислоСоставляющихВерсии1 Цикл
			ЧастиВерсии2.Добавить(0);
		КонецЦикла;
	ИначеЕсли ЧислоСоставляющихВерсии2 > ЧислоСоставляющихВерсии1 Тогда
		Для Инд = ЧислоСоставляющихВерсии1 + 1 По ЧислоСоставляющихВерсии2 Цикл
			ЧастиВерсии1.Добавить(0);
		КонецЦикла;
	КонецЕсли;
	
	// сравниваем по каждому составляющему
	Для Инд = 0 По ЧислоСоставляющихВерсии1 - 1 Цикл
		ЧастьВерсии1 = ЧастиВерсии1[Инд];
		ЧастьВерсии2 = ЧастиВерсии2[Инд];
		Если ЧастьВерсии1 > ЧастьВерсии2 Тогда
			Возврат -1;
		ИначеЕсли ЧастьВерсии1 < ЧастьВерсии2 Тогда
			Возврат 1;
		КонецЕсли;
	КонецЦикла;
	
	Возврат 0;
	
КонецФункции

Функция ПолучитьКодЯзыкаИнтерфейса() Экспорт
	
	Возврат РегламентированнаяОтчетностьВызовСервера.ПолучитьКодЯзыкаИнтерфейса();
		
КонецФункции

Функция ПолучитьНомерНаПечать(НомерОбъекта, УдалитьПрефиксИнформационнойБазы = Ложь, УдалитьПользовательскийПрефикс = Ложь) Экспорт
	
	Возврат РегламентированнаяОтчетностьВызовСервера.ПолучитьНомерНаПечать(НомерОбъекта, УдалитьПрефиксИнформационнойБазы, УдалитьПользовательскийПрефикс);
		
КонецФункции

Функция НайтиПоследнееВхождение(ГдеИскать, ЧтоИскать) Экспорт
	
	ДлинаСтроки = СтрДлина(ГдеИскать);
	ДлинаИскомого = СтрДлина(ЧтоИскать);
	
	Результат = 0;
	Если ДлинаИскомого = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	Для ж = 0 По ДлинаСтроки - ДлинаИскомого Цикл
		
		Позиция = ДлинаСтроки - ДлинаИскомого + 1 - ж;
		Если Сред(ГдеИскать, Позиция, ДлинаИскомого) = ЧтоИскать Тогда
			Результат = Позиция;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции
