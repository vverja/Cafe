
#Область ПрограммныйИнтерфейс

Процедура ОтразитьУслугиПереработчиковКОформлению(ДополнительныеСвойства, Движения, Отказ) Экспорт
	
	ТаблицаУслугиПереработчиковКОформлению = ДополнительныеСвойства.ТаблицыДляДвижений.ТаблицаУслугиПереработчиковКОформлению;
	
	Если Отказ ИЛИ ТаблицаУслугиПереработчиковКОформлению.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ДвиженияУслугиПереработчиковКОформлению = Движения.УслугиПереработчиковКОформлению;
	ДвиженияУслугиПереработчиковКОформлению.Записывать = Истина;
	ДвиженияУслугиПереработчиковКОформлению.Загрузить(ТаблицаУслугиПереработчиковКОформлению);
	
КонецПроцедуры

Процедура ОтразитьТоварыКОтгрузке(ДополнительныеСвойства, Движения, Отказ) Экспорт

	Таблица = ДополнительныеСвойства.ТаблицыДляДвижений.ТаблицаТоварыКОтгрузке;

	Если Отказ ИЛИ Таблица.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;

	НаборЗаписей = Движения.ТоварыКОтгрузке;
	НаборЗаписей.Записывать = Истина;
	НаборЗаписей.Загрузить(Таблица);

КонецПроцедуры

Процедура ОтразитьДвижениеТоваров(ДополнительныеСвойства, Движения, Отказ) Экспорт

	ТаблицаДвижениеТоваров = ДополнительныеСвойства.ТаблицыДляДвижений.ТаблицаДвижениеТоваров;
	
	Если Отказ ИЛИ ТаблицаДвижениеТоваров.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ДвиженияТоваров = Движения.ДвижениеТоваров;
	ДвиженияТоваров.Записывать = Истина;
	ДвиженияТоваров.Загрузить(ТаблицаДвижениеТоваров);

КонецПроцедуры

Процедура ОтразитьГрафикОтгрузкиТоваров(ДополнительныеСвойства, Движения, Отказ) Экспорт

	ТаблицаГрафикОтгрузки = ДополнительныеСвойства.ТаблицыДляДвижений.ТаблицаГрафикОтгрузкиТоваров;
	
	Если Отказ Или ТаблицаГрафикОтгрузки.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Набор = Движения.ГрафикОтгрузкиТоваров;
	Набор.Записывать = Истина;
	Набор.Загрузить(ТаблицаГрафикОтгрузки);

КонецПроцедуры

Процедура ОтразитьЗаказыКлиентов(ДополнительныеСвойства, Движения, Отказ) Экспорт

	ТаблицаЗаказыКлиентов = ДополнительныеСвойства.ТаблицыДляДвижений.ТаблицаЗаказыКлиентов;
	
	Если Отказ ИЛИ ТаблицаЗаказыКлиентов.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ДвиженияЗаказыКлиентов = Движения.ЗаказыКлиентов;
	ДвиженияЗаказыКлиентов.Записывать = Истина;
	ДвиженияЗаказыКлиентов.Загрузить(ТаблицаЗаказыКлиентов);
	
КонецПроцедуры

Процедура ОтразитьЗаказыНаСборку(ДополнительныеСвойства, Движения, Отказ) Экспорт

	Таблица = ДополнительныеСвойства.ТаблицыДляДвижений.ТаблицаЗаказыНаСборку;
	
	Если Отказ ИЛИ Таблица.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	НаборЗаписей = Движения.ЗаказыНаСборку;
	НаборЗаписей.Записывать = Истина;
	НаборЗаписей.Загрузить(Таблица);
	
КонецПроцедуры

Процедура ОтразитьЗаказыНаПеремещение(ДополнительныеСвойства, Движения, Отказ) Экспорт

	Таблица = ДополнительныеСвойства.ТаблицыДляДвижений.ТаблицаЗаказыНаПеремещение;
	
	Если Отказ ИЛИ Таблица.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	НаборЗаписей = Движения.ЗаказыНаПеремещение;
	НаборЗаписей.Записывать = Истина;
	НаборЗаписей.Загрузить(Таблица);
	
КонецПроцедуры

Процедура ОтразитьЗаказыНаВнутреннееПотребление(ДополнительныеСвойства, Движения, Отказ) Экспорт

	Таблица = ДополнительныеСвойства.ТаблицыДляДвижений.ТаблицаЗаказыНаВнутреннееПотребление;
	
	Если Отказ ИЛИ Таблица.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;

	НаборЗаписей = Движения.ЗаказыНаВнутреннееПотребление;
	НаборЗаписей.Записывать = Истина;
	НаборЗаписей.Загрузить(Таблица);
	
КонецПроцедуры

Процедура ОтразитьТоварыКПоступлению(ДополнительныеСвойства, Движения, Отказ) Экспорт

	ТаблицаТоварыКПоступлению = ДополнительныеСвойства.ТаблицыДляДвижений.ТаблицаТоварыКПоступлению;
	
	Если Отказ ИЛИ ТаблицаТоварыКПоступлению.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ДвиженияТоварыКПоступлению = Движения.ТоварыКПоступлению;
	ДвиженияТоварыКПоступлению.Записывать = Истина;
	ДвиженияТоварыКПоступлению.Загрузить(ТаблицаТоварыКПоступлению);
	
КонецПроцедуры

Процедура ОтразитьЗаказыПоставщикам(ДополнительныеСвойства, Движения, Отказ) Экспорт

	ТаблицаЗаказыПоставщикам = ДополнительныеСвойства.ТаблицыДляДвижений.ТаблицаЗаказыПоставщикам;
	
	Если Отказ ИЛИ ТаблицаЗаказыПоставщикам.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ДвиженияЗаказыПоставщикам = Движения.ЗаказыПоставщикам;
	ДвиженияЗаказыПоставщикам.Записывать = Истина;
	ДвиженияЗаказыПоставщикам.Загрузить(ТаблицаЗаказыПоставщикам);
	
КонецПроцедуры

Процедура ОтразитьЗаявкиНаВозвратТоваровОтКлиентов(ДополнительныеСвойства, Движения, Отказ) Экспорт

	ТаблицаЗаявкиНаВозвратТоваровОтКлиентов = ДополнительныеСвойства.ТаблицыДляДвижений.ТаблицаЗаявкиНаВозвратТоваровОтКлиентов;
	
	Если Отказ ИЛИ ТаблицаЗаявкиНаВозвратТоваровОтКлиентов.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ДвиженияЗаявкиНаВозвратТоваровОтКлиентов = Движения.ЗаявкиНаВозвратТоваровОтКлиентов;
	ДвиженияЗаявкиНаВозвратТоваровОтКлиентов.Записывать = Истина;
	ДвиженияЗаявкиНаВозвратТоваровОтКлиентов.Загрузить(ТаблицаЗаявкиНаВозвратТоваровОтКлиентов);
	
КонецПроцедуры



Функция УстановитьКлючВСтрокахТабличнойЧасти(Объект, ИмяТабличнойЧасти, РеквизитМаксимальныйКодСтроки = "МаксимальныйКодСтроки") Экспорт

	СтрокиБезКлюча = Объект[ИмяТабличнойЧасти].НайтиСтроки(Новый Структура("КодСтроки", 0));
	Если СтрокиБезКлюча.Количество() > 0 Тогда
		
		ТекущийКод = Объект[РеквизитМаксимальныйКодСтроки];
		
		Для Каждого СтрокаТовары Из СтрокиБезКлюча Цикл
			
			ТекущийКод = ТекущийКод + 1;
			СтрокаТовары.КодСтроки = ТекущийКод;
			
		КонецЦикла;
		
		Объект[РеквизитМаксимальныйКодСтроки] = ТекущийКод;
		
	КонецЕсли;

КонецФункции

// Получает минимальную дату отгрузки по неоформленным строкам заказа. Используется в событии обработка заполнения,
// для заполнения даты документа.
//
// Параметры:
//  ЗаказИлиМассивЗаказов - ДокументСсылка - заказ, дату отгрузки кторого необходимо получить.
//  ИмяРегистра - Строка - Имя регистра накопления, содержащего сведения о неоформленных строках заказа.
//  ИмяРаспоряжения - Строка - Имя измерения регистра накопления, содержащего распоряжение (заказ).
//
// Возвращаемое значение:
// Дата - Минимальная дата отгрузки по неоформленным строкам заказа.
//
Функция ПолучитьМинимальнуюДатуОтгрузкиЗаказа(ЗаказИлиМассивЗаказов, ИмяРегистра = "ЗаказыКлиентов", ИмяРаспоряжения = "ЗаказКлиента") Экспорт

	Результат = Неопределено;

	Запрос = Новый Запрос();
	Если ИмяРегистра = "ЗаказыНаСборку" Тогда

		Запрос.Текст =
			"ВЫБРАТЬ ПЕРВЫЕ 1
			|	ТаблицаКОформлению.Период КАК Период
			|ИЗ
			|	РегистрНакопления.ЗаказыНаСборку.Остатки(, ЗаказНаСборку В(&МассивЗаказов)) КАК Отбор
			|
			|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрНакопления.ЗаказыНаСборку КАК ТаблицаКОформлению
			|		ПО Отбор.ЗаказНаСборку = ТаблицаКОформлению.ЗаказНаСборку
			|		 И Отбор.КодСтроки     = ТаблицаКОформлению.КодСтроки
			|		 И Отбор.КОформлениюОстаток > 0
			|		 И ТаблицаКОформлению.КОформлению > 0
			|		 И ТаблицаКОформлению.ВидДвижения = ЗНАЧЕНИЕ(ВидДвиженияНакопления.Приход)
			|		 И ТаблицаКОформлению.Активность
			|		 И Отбор.ТипСборки = ЗНАЧЕНИЕ(Перечисление.ТипыДвиженияЗапасов.Отгрузка)
			|		 И ТаблицаКОформлению.ТипСборки = ЗНАЧЕНИЕ(Перечисление.ТипыДвиженияЗапасов.Отгрузка)
			|
			|УПОРЯДОЧИТЬ ПО
			|	Период";

	Иначе

		Запрос.Текст =
			"ВЫБРАТЬ ПЕРВЫЕ 1
			|	ТаблицаКОформлению.Период КАК Период
			|ИЗ
			|	РегистрНакопления.ЗаказыКлиентов.Остатки(, ЗаказКлиента В(&МассивЗаказов)) КАК Отбор
			|
			|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрНакопления.ЗаказыКлиентов КАК ТаблицаКОформлению
			|		ПО Отбор.ЗаказКлиента = ТаблицаКОформлению.ЗаказКлиента
			|		 И Отбор.КодСтроки    = ТаблицаКОформлению.КодСтроки
			|		 И Отбор.КОформлениюОстаток > 0
			|		 И ТаблицаКОформлению.ВидДвижения = ЗНАЧЕНИЕ(ВидДвиженияНакопления.Приход)
			|		 И ТаблицаКОформлению.КОформлению > 0
			|		 И ТаблицаКОформлению.Активность
			|
			|УПОРЯДОЧИТЬ ПО
			|	Период";

		Запрос.Текст = СтрЗаменить(Запрос.Текст, "ЗаказыКлиентов", ИмяРегистра);
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "ЗаказКлиента", ИмяРаспоряжения);

	КонецЕсли;

	Запрос.УстановитьПараметр("МассивЗаказов", ЗаказИлиМассивЗаказов);

	УстановитьПривилегированныйРежим(Истина);
	Выборка = Запрос.Выполнить().Выбрать();

	Если Выборка.Следующий() Тогда
		Результат = Макс(ТекущаяДатаСеанса(), Выборка.Период);
	КонецЕсли;

	Возврат Результат;

КонецФункции

// Получает максимальную дату отгрузки по неоформленным строкам заказа. Используется в событии обработка заполнения,
// для заполнения даты документа.
//
// Параметры:
//  ЗаказИлиМассивЗаказов - ДокументСсылка - заказ, дату отгрузки кторого необходимо получить.
//  ИмяРегистра - Строка - Имя регистра накопления, содержащего сведения о неоформленных строках заказа.
//  ИмяРаспоряжения - Строка - Имя измерения регистра накопления, содержащего распоряжение (заказ).
//
// Возвращаемое значение:
// Дата - Максимальная дата отгрузки по неоформленным строкам заказа.
//
Функция ПолучитьМаксимальнуюДатуОтгрузкиЗаказа(ЗаказИлиМассивЗаказов, ИмяРегистра = "ЗаказыКлиентов", ИмяРаспоряжения = "ЗаказКлиента") Экспорт

	Результат = Неопределено;

	Запрос = Новый Запрос();
	Если ИмяРегистра = "ЗаказыНаСборку" Тогда

		Запрос.Текст =
			"ВЫБРАТЬ ПЕРВЫЕ 1
			|	ТаблицаКОформлению.Период КАК Период
			|ИЗ
			|	РегистрНакопления.ЗаказыНаСборку.Остатки(, ЗаказНаСборку В(&МассивЗаказов)) КАК Отбор
			|
			|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрНакопления.ЗаказыНаСборку КАК ТаблицаКОформлению
			|		ПО Отбор.ЗаказНаСборку = ТаблицаКОформлению.ЗаказНаСборку
			|		 И Отбор.КодСтроки     = ТаблицаКОформлению.КодСтроки
			|		 И Отбор.КОформлениюОстаток > 0
			|		 И ТаблицаКОформлению.ВидДвижения = ЗНАЧЕНИЕ(ВидДвиженияНакопления.Приход)
			|		 И ТаблицаКОформлению.КОформлению > 0
			|		 И ТаблицаКОформлению.Активность
			|		 И Отбор.ТипСборки = ЗНАЧЕНИЕ(Перечисление.ТипыДвиженияЗапасов.Отгрузка)
			|		 И ТаблицаКОформлению.ТипСборки = ЗНАЧЕНИЕ(Перечисление.ТипыДвиженияЗапасов.Отгрузка)
			|
			|УПОРЯДОЧИТЬ ПО
			|	Период УБЫВ";

	Иначе

		Запрос.Текст =
			"ВЫБРАТЬ ПЕРВЫЕ 1
			|	ТаблицаКОформлению.Период КАК Период
			|ИЗ
			|	РегистрНакопления.ЗаказыКлиентов.Остатки(, ЗаказКлиента В(&МассивЗаказов)) КАК Отбор
			|
			|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрНакопления.ЗаказыКлиентов КАК ТаблицаКОформлению
			|		ПО Отбор.ЗаказКлиента = ТаблицаКОформлению.ЗаказКлиента
			|		 И Отбор.КодСтроки    = ТаблицаКОформлению.КодСтроки
			|		 И Отбор.КОформлениюОстаток > 0
			|		 И ТаблицаКОформлению.ВидДвижения = ЗНАЧЕНИЕ(ВидДвиженияНакопления.Приход)
			|		 И ТаблицаКОформлению.КОформлению > 0
			|		 И ТаблицаКОформлению.Активность
			|
			|УПОРЯДОЧИТЬ ПО
			|	Период УБЫВ";

		Запрос.Текст = СтрЗаменить(Запрос.Текст, "ЗаказыКлиентов", ИмяРегистра);
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "ЗаказКлиента", ИмяРаспоряжения);

	КонецЕсли;

	Запрос.УстановитьПараметр("МассивЗаказов", ЗаказИлиМассивЗаказов);

	УстановитьПривилегированныйРежим(Истина);
	Выборка = Запрос.Выполнить().Выбрать();

	Если Выборка.Следующий() И Выборка.Период >= НачалоДня(ТекущаяДатаСеанса()) Тогда
		Результат = Выборка.Период;
	КонецЕсли;

	Возврат Результат;

КонецФункции

Процедура ПроверитьДатуРаспоряжения(Объект) Экспорт

	ТекДатаРаспоряжения = КонецДня(Объект.Дата);

	// Дата распоряжения не должна быть больше текущей.
	Если ТекДатаРаспоряжения > КонецДня(ТекущаяДата()) Тогда

		ТекДатаРаспоряжения = КонецДня(ТекущаяДата());

	КонецЕсли;

	Если Объект.ДатаРаспоряжения <> ТекДатаРаспоряжения Тогда

		Объект.ДатаРаспоряжения = ТекДатаРаспоряжения;

	КонецЕсли;

КонецПроцедуры

Процедура ОбновитьИнформациюПоЗаказамВФорме(СписокЗаказов,
	                                        ЗаказВШапке,
	                                        НадписьЗаголовок,
	                                        ЭлементыФормы,
	                                        ГруппаКолонокВТабличнойЧасти,
	                                        Знач ТабличнаяЧасть,
	                                        Знач ИмяЗаказаВТабличнойЧасти,
	                                        Знач ИспользоватьЗаказыВТабличнойЧасти,
											НадписьВсегоЗаказов = Неопределено) Экспорт
	
	Если Не ИспользоватьЗаказыВТабличнойЧасти Тогда
		Возврат;
	КонецЕсли;
		
	СписокЗаказов.Очистить();
	Для Каждого ТекСтрока Из ТабличнаяЧасть Цикл
		Если ЗначениеЗаполнено(ТекСтрока[ИмяЗаказаВТабличнойЧасти]) И СписокЗаказов.НайтиПоЗначению(ТекСтрока[ИмяЗаказаВТабличнойЧасти]) = Неопределено Тогда
			СписокЗаказов.Добавить(ТекСтрока[ИмяЗаказаВТабличнойЧасти]);
		КонецЕсли;
	КонецЦикла;
	
	Если ИспользоватьЗаказыВТабличнойЧасти Тогда
		Если СписокЗаказов.Количество() = 1 Тогда
			ЗаказВШапке = СписокЗаказов[0].Значение;
		ИначеЕсли СписокЗаказов.Количество() > 1 Тогда
			ЗаказВШапке = Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	Если СписокЗаказов.Количество() > 1 Тогда
		Если НадписьВсегоЗаказов = Неопределено Тогда
			НадписьВсегоЗаказов = НСтр("ru='Всего заказов';uk='Всього замовлень'");
		КонецЕсли;
		НадписьЗаголовок = НадписьВсегоЗаказов + ": " + СписокЗаказов.Количество();
	КонецЕсли;
	
	Если СписокЗаказов.Количество() <= 1 Тогда
		ЭлементыФормы.СтраницыЗаказ.ТекущаяСтраница = ЭлементыФормы.СтраницаЗаказ;
	Иначе
		ЭлементыФормы.СтраницыЗаказ.ТекущаяСтраница = ЭлементыФормы.СтраницаЗаказы;
	КонецЕсли;
	
	Если ГруппаКолонокВТабличнойЧасти <> Неопределено Тогда
		Если ЗначениеЗаполнено(ЗаказВШапке) Или Не ИспользоватьЗаказыВТабличнойЧасти Тогда
			ГруппаКолонокВТабличнойЧасти.Группировка = ГруппировкаКолонок.Вертикальная;
		Иначе
			ГруппаКолонокВТабличнойЧасти.Группировка = ГруппировкаКолонок.ВЯчейке;
		КонецЕсли;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ЗаполнитьЗаказВШапкеПоЗаказамВТабличнойЧасти(ЗаказВШапке, Знач ТабличнаяЧасть, Знач ИмяЗаказаВТабличнойЧасти) Экспорт
	
	// Заполним заказ в шапке, если в табличной части указан один заказ
	ЗаказыТабличнойЧасти = ТабличнаяЧасть.Выгрузить(,ИмяЗаказаВТабличнойЧасти);
	ЗаказыТабличнойЧасти.Свернуть(ИмяЗаказаВТабличнойЧасти);
	
	Если ЗаказыТабличнойЧасти.Количество() = 1 Тогда
		СтрокаТабличнойЧасти = ЗаказыТабличнойЧасти[0];
		Если ЗначениеЗаполнено(СтрокаТабличнойЧасти[ИмяЗаказаВТабличнойЧасти]) Тогда
			ЗаказВШапке = СтрокаТабличнойЧасти[ИмяЗаказаВТабличнойЧасти];
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

// Заполняет реквизиты шапки по табличным частям
//
// Параметры:
//  СоотвествиеРеквизитов	- Соотвествие - Соотвествие реквизитов шапки и реквизитов табличных частей (ключ - реквизит шапки, значение - реквизит ТЧ)
//  ТабличныеЧасти			- Строка - Список табличных частей из которых нужно получить значения
//  Объект					- ДокументОбъект, ДанныеФормыСтруктура - Объект в котором нужно заполнить реквизиты
//
Процедура ЗаполнитьРеквизитыШапкиПоТабличнымЧастям(СоотвествиеРеквизитов, ТабличныеЧасти, Объект) Экспорт

	СписокТЧ = СтрРазделить(ТабличныеЧасти, ",");
	
	Для каждого КлючИЗначение Из СоотвествиеРеквизитов Цикл
		
		КоличествоЗначений = 0;
		ЗначениеРеквизита = Неопределено;
		
		Для каждого ИмяТЧ Из СписокТЧ Цикл
			
			Для каждого ДанныеСтроки Из Объект[ИмяТЧ] Цикл
				
				Если НЕ ЗначениеЗаполнено(ДанныеСтроки[КлючИЗначение.Значение]) Тогда
					Продолжить;
				КонецЕсли;
				
				Если ДанныеСтроки[КлючИЗначение.Значение] <> ЗначениеРеквизита Тогда
					КоличествоЗначений = КоличествоЗначений + 1;
				КонецЕсли;
				ЗначениеРеквизита = ДанныеСтроки[КлючИЗначение.Значение];
				Если КоличествоЗначений > 1 Тогда
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			
			Если КоличествоЗначений > 1 Тогда
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		Если КоличествоЗначений <> 1 Тогда
			МассивТипов = Новый Массив;
			МассивТипов.Добавить(ТипЗнч(Объект[КлючИЗначение.Ключ]));
			ТипРеквизита = Новый ОписаниеТипов(МассивТипов);
			ЗначениеРеквизита = ТипРеквизита.ПривестиЗначение();
		КонецЕсли; 
		
		Объект[КлючИЗначение.Ключ] = ЗначениеРеквизита;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура УстановитьПризнакиПрисутствияСтрокиВДокументе(ТаблицаТовары, ИмяЗаказаВТабличнойЧасти, МассивКодовСтрок, ИмяРеквизитаКодСтроки = "КодСтроки") Экспорт

	Для Каждого СтрокаТаб Из ТаблицаТовары Цикл
	
		СтрокаТаб.ПрисутствуетВДокументе = Ложь;
		
		Для Каждого ТекСтрока Из МассивКодовСтрок Цикл
			
			Если ТекСтрока[ИмяРеквизитаКодСтроки] = СтрокаТаб[ИмяРеквизитаКодСтроки] 
				И ТекСтрока[ИмяЗаказаВТабличнойЧасти] = СтрокаТаб[ИмяЗаказаВТабличнойЧасти] Тогда
				
				СтрокаТаб.ПрисутствуетВДокументе = Истина;
				Прервать;
				
			КонецЕсли;
			
		КонецЦикла;
		
		СтрокаТаб.СтрокаВыбрана = Не СтрокаТаб.ПрисутствуетВДокументе;
		
	КонецЦикла;
	
КонецПроцедуры

// Устанавливает условное оформление отмененной строки ТЧ в форме Заказа
// Параметры:
//	УсловноеОформление - УсловноеОформлениеКомпоновкиДанных - условное оформление формы;
//	ТаблицаФормы - ТаблицаФормы - элемент формы, связанного с ТЧ, в которой отменяются строки;
//	ИмяЭлементаОтменено - Строка - наименование элемента формы, связанного с признаком отмены строки заказа;
//	ИмяЭлементаПричинаОтмены - Строка - наименование элемента формы, связанного с причиной отмены строки заказа.
//
Процедура УстановитьОформлениеОтмененнойСтроки(УсловноеОформление, ТаблицаФормы, ИмяЭлементаОтменено, ИмяЭлементаПричинаОтмены = "", ИмяПоляВводаЦены = "", ИмяПоляВводаСуммы = "") Экспорт
	
	Элемент = УсловноеОформление.Элементы.Добавить();
	ПутьКТЧ = ТаблицаФормы.ПутьКДанным;
	
	ИсключаяПоля = Новый Массив;
	ИсключаяПоля.Добавить(ИмяЭлементаОтменено);
	Если ЗначениеЗаполнено(ИмяЭлементаПричинаОтмены) Тогда
		ИсключаяПоля.Добавить(ИмяЭлементаПричинаОтмены);
	КонецЕсли;
	ОбщегоНазначенияУТ.ЗаполнитьРекурсивноПоляУсловногоОформления(Элемент.Поля, ТаблицаФормы.ПодчиненныеЭлементы, ИсключаяПоля);
	
	ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКТЧ + ".Отменено");
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Истина;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.ЦветТекстаОтмененнойСтрокиДокумента);
	
	//
	
	Если ЗначениеЗаполнено(ИмяЭлементаПричинаОтмены) Тогда
	
		Элемент = УсловноеОформление.Элементы.Добавить();
		
		ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
		ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлементаПричинаОтмены);
		
		ГруппаОтбора1 = Элемент.Отбор.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
		ГруппаОтбора1.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли;
		
		ОтборЭлемента = ГруппаОтбора1.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКТЧ + ".ПричинаОтмены");
		ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено;
		
		ОтборЭлемента = ГруппаОтбора1.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКТЧ + ".Отменено");
		ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		ОтборЭлемента.ПравоеЗначение = Ложь;
		
		Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Ложь);
		
		//
		
		Элемент = УсловноеОформление.Элементы.Добавить();
		
		ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
		ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлементаПричинаОтмены);
		
		ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКТЧ + ".Отменено");
		ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		ОтборЭлемента.ПравоеЗначение = Ложь;
		
		Элемент.Оформление.УстановитьЗначениеПараметра("ТолькоПросмотр", Истина);
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ИмяПоляВводаЦены) Тогда
		
		Элемент = УсловноеОформление.Элементы.Добавить();
		
		ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
		ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяПоляВводаЦены);
		
		ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКТЧ + ".Отменено");
		ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		ОтборЭлемента.ПравоеЗначение = Истина;
		
		Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Ложь);
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ИмяПоляВводаСуммы) Тогда
		
		Элемент = УсловноеОформление.Элементы.Добавить();
		
		ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
		ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяПоляВводаСуммы);
		
		ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКТЧ + ".Отменено");
		ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		ОтборЭлемента.ПравоеЗначение = Истина;
		
		Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Ложь);
		
	КонецЕсли;

КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ОбновлениеИнформационнойБазы

Функция ПараметрыОбработчикаОбновленияПоЗаполнениюСерийВЗаказах_3_2_2() Экспорт
	
	ПараметрыОбработчикаОбновления = Новый Структура;
	ПараметрыОбработчикаОбновления.Вставить("ИмяТЧТоварыЗаказа", "Товары");
	ПараметрыОбработчикаОбновления.Вставить("ИмяТЧТоварыНакладной", "Товары");
	ПараметрыОбработчикаОбновления.Вставить("ИмяТЧСерииЗаказа", "Серии");
	ПараметрыОбработчикаОбновления.Вставить("РеквизитыПересчета", "КоличествоУпаковок");
	ПараметрыОбработчикаОбновления.Вставить("ПоляПоискаСерийВНакладной", "Номенклатура, Характеристика, Назначение, УдалитьДокументРезерваСерий");
	ПараметрыОбработчикаОбновления.Вставить("ПоляПоискаСерийВЗаказе", "Номенклатура, Характеристика, Назначение");
	ПараметрыОбработчикаОбновления.Вставить("ИмяПоляМаксКодСтроки", "МаксимальныйКодСтроки");
	
	Возврат ПараметрыОбработчикаОбновления;
	
КонецФункции

Процедура ОбработатьСерииНакладной(НакладнаяОбъект, Выборка, МаксимальныеКодыСтрок = Неопределено, ПараметрыОбработчика = Неопределено) Экспорт
	
	Если ПараметрыОбработчика = Неопределено Тогда
		ПараметрыОбработчика = ПараметрыОбработчикаОбновленияПоЗаполнениюСерийВЗаказах_3_2_2();
	КонецЕсли;
	
	СтрокиКУдалению = Новый Массив;
	НакладнаяТЧТовары = НакладнаяОбъект.Товары;
	НакладнаяТЧСерии = НакладнаяОбъект.Серии;
	СтруктураПересчетаСуммыВНакладной = ОбработкаТабличнойЧастиКлиентСервер.СтруктураПересчетаСуммы(ПараметрыОбработчика.РеквизитыПересчета, Неопределено);
	СтруктураПоискаСерийВНакладной = Новый Структура(ПараметрыОбработчика.ПоляПоискаСерийВНакладной);
	
	Пока Выборка.Следующий() Цикл
		
		НакладнаяТекСтрока = НакладнаяОбъект[ПараметрыОбработчика.ИмяТЧТоварыНакладной][Выборка.НомерСтроки - 1];
		
		ОбработатьКодыСтрок = (Не МаксимальныеКодыСтрок = Неопределено)
			И НакладнаяТекСтрока.КодСтроки > 0
			И ЗначениеЗаполнено(Выборка.МаксимальныйКодСтроки);
		
		Если НакладнаяТекСтрока.СтатусУказанияСерий = 14 И ОбработатьКодыСтрок Тогда
			// Обработаем фин.серии, привязанные к одной строке заказа, строки заказа нужно будет разбить
			Если МаксимальныеКодыСтрок[Выборка.ЗаказСсылка] = Неопределено Тогда
				МаксимальныеКодыСтрок.Вставить(Выборка.ЗаказСсылка, Выборка.МаксимальныйКодСтроки);
			КонецЕсли;
			НакладнаяТекСтрока.УдалитьСтарыйКодСтроки = НакладнаяТекСтрока.КодСтроки;
			НакладнаяТекСтрока.КодСтроки = МаксимальныеКодыСтрок[Выборка.ЗаказСсылка] + 1;
			МаксимальныеКодыСтрок[Выборка.ЗаказСсылка] = НакладнаяТекСтрока.КодСтроки;
			
			Продолжить;
			
		КонецЕсли;
		
		ОбработкаТабличнойЧастиКлиентСервер.ЗаполнитьСтруктуруПересчетаСуммы(СтруктураПересчетаСуммыВНакладной, НакладнаяТекСтрока);
		ЗаполнитьЗначенияСвойств(СтруктураПоискаСерийВНакладной, НакладнаяТекСтрока);
		СтрокиСерий = НакладнаяТЧСерии.НайтиСтроки(СтруктураПоискаСерийВНакладной);
		ОстатокПоСтрокеНакладной = НакладнаяТекСтрока.Количество;
		
		Для Каждого СтрокаСерий Из СтрокиСерий Цикл
			
			ОбрабатываемаяСтрокаНакладной = НакладнаяТЧТовары.Добавить();
			ЗаполнитьЗначенияСвойств(ОбрабатываемаяСтрокаНакладной,НакладнаяТекСтрока);
			Если ОбработатьКодыСтрок Тогда
				Если МаксимальныеКодыСтрок[Выборка.ЗаказСсылка] = Неопределено Тогда
					МаксимальныеКодыСтрок.Вставить(Выборка.ЗаказСсылка, Выборка.МаксимальныйКодСтроки);
				КонецЕсли;
				ОбрабатываемаяСтрокаНакладной.УдалитьСтарыйКодСтроки = НакладнаяТекСтрока.КодСтроки;
				ОбрабатываемаяСтрокаНакладной.КодСтроки = МаксимальныеКодыСтрок[Выборка.ЗаказСсылка] + 1;
				МаксимальныеКодыСтрок[Выборка.ЗаказСсылка] = ОбрабатываемаяСтрокаНакладной.КодСтроки;
			КонецЕсли;
			ОбрабатываемаяСтрокаНакладной.ИдентификаторСтроки = Строка(Новый УникальныйИдентификатор);
			
			ДобавляемоеКоличество = Мин(СтрокаСерий.Количество, ОстатокПоСтрокеНакладной);
			
			ОбрабатываемаяСтрокаНакладной.Серия = СтрокаСерий.Серия;
			
			ОбрабатываемаяСтрокаНакладной.Количество = ДобавляемоеКоличество;
			ОстатокПоСтрокеНакладной = ОстатокПоСтрокеНакладной - ДобавляемоеКоличество;
			СтрокаСерий.Количество = СтрокаСерий.Количество - ДобавляемоеКоличество;
			Если СтрокаСерий.Количество = 0 Тогда
				НакладнаяТЧСерии.Удалить(СтрокаСерий);
			КонецЕсли;
			ОбработкаТабличнойЧастиКлиентСервер.ДобавитьСтрокуДляПересчетаСуммы(СтруктураПересчетаСуммыВНакладной, ОбрабатываемаяСтрокаНакладной);
			
			Если ОстатокПоСтрокеНакладной = 0 Тогда
			// В накладной могут остаться серии, относящиеся к другим строкам ТЧ Товары
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		СтрокиКУдалению.Добавить(НакладнаяТекСтрока);
		
		ОбработкаТабличнойЧастиКлиентСервер.ПересчитатьСуммы(СтруктураПересчетаСуммыВНакладной);
		
	КонецЦикла;
	
	Для Каждого Стр Из СтрокиКУдалению Цикл
		НакладнаяТЧТовары.Удалить(Стр);
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбработатьСерииЗаказа(ЗаказОбъект, Выборка, ПараметрыОбработчика = Неопределено) Экспорт
	
	СтрокиКУдалению = Новый Массив;
	
	Если ПараметрыОбработчика = Неопределено Тогда
		ПараметрыОбработчика = ПараметрыОбработчикаОбновленияПоЗаполнениюСерийВЗаказах_3_2_2();
	КонецЕсли;
	
	Выборка.Сбросить();
	
	ВариантОбособленно          = Перечисления.ВариантыОбеспечения.Обособленно;
	ВариантОтгрузитьОбособленно = Перечисления.ВариантыОбеспечения.ОтгрузитьОбособленно;
	ВариантСоСклада             = Перечисления.ВариантыОбеспечения.СоСклада;
	
	
	СтруктураПересчетаСуммыВЗаказе = ОбработкаТабличнойЧастиКлиентСервер.СтруктураПересчетаСуммы(ПараметрыОбработчика.РеквизитыПересчета, Неопределено);
	
	СтруктураПоискаСерийВЗаказе = Новый Структура(ПараметрыОбработчика.ПоляПоискаСерийВЗаказе);
	
	ИмяПоляМаксКодСтроки = ПараметрыОбработчика.ИмяПоляМаксКодСтроки;
	
	СтруктураПоискаСерийВЗаказеССерией = Новый Структура(ПараметрыОбработчика.ПоляПоискаСерийВЗаказе);
	СтруктураПоискаСерийВЗаказеССерией.Вставить("Серия");
	
	ЗаказТЧТовары = ЗаказОбъект[ПараметрыОбработчика.ИмяТЧТоварыЗаказа];
	
	Если ЗаказОбъект.Метаданные().ТабличныеЧасти.Найти(ПараметрыОбработчика.ИмяТЧСерииЗаказа) <> Неопределено Тогда
		ЗаказТЧСерии = ЗаказОбъект[ПараметрыОбработчика.ИмяТЧСерииЗаказа];
	Иначе
		ЗаказТЧСерии = ЗаказОбъект["Удалить" + ПараметрыОбработчика.ИмяТЧСерииЗаказа];
	КонецЕсли;
	
	СтрокиКРаспределениюПоСериям = Новый Массив;
	
	Пока Выборка.СледующийПоЗначениюПоля("ЗаказНомерСтроки") Цикл
		
		Индекс = Выборка.ЗаказНомерСтроки - 1;
		
		ЗаказТекСтрока = ЗаказТЧТовары[Индекс];
		
		
		СтатусУказанияСерий = ЗаказТекСтрока.СтатусУказанияСерий;
		
		Если СтатусУказанияСерий = 12
			Или СтатусУказанияСерий = 16 Тогда
			ЗаказТекСтрока.СтатусУказанияСерий = 0;
			Продолжить;
		КонецЕсли;
		
		ОстатокПоСтрокеЗаказа = ЗаказТекСтрока.Количество;
		
		ЭтоОбособленнаяСтрока = ЗаказТекСтрока.ВариантОбеспечения = ВариантОтгрузитьОбособленно;
		
		Если Не ЗначениеЗаполнено(Выборка.НакладнаяСсылка) Тогда
			
			Если СтатусУказанияСерий = 10 Тогда
				
				СтрокиКРаспределениюПоСериям.Добавить(ЗаказТекСтрока);
				
			ИначеЕсли (СтатусУказанияСерий = 11
				Или СтатусУказанияСерий = 15) Тогда // Реализаций по строке заказа не введено, откатим вариант обеспечения
				
				Если ЭтоОбособленнаяСтрока Тогда
					ЗаказТекСтрока.ВариантОбеспечения = ВариантОбособленно;
					ЗаказТекСтрока.СтатусУказанияСерий = 0;
				Иначе
					ЗаказТекСтрока.ВариантОбеспечения = ВариантСоСклада;
				КонецЕсли;
				
			КонецЕсли;
			
			Продолжить;
			
		КонецЕсли;
		
		ОбработкаТабличнойЧастиКлиентСервер.ЗаполнитьСтруктуруПересчетаСуммы(СтруктураПересчетаСуммыВЗаказе, ЗаказТекСтрока);
		
		Пока Выборка.СледующийПоЗначениюПоля("КодСтроки")
			И ОстатокПоСтрокеЗаказа > 0 Цикл
			
			ОбрабатываемаяСтрокаЗаказа = ЗаказТЧТовары.Добавить();
			ЗаполнитьЗначенияСвойств(ОбрабатываемаяСтрокаЗаказа,ЗаказТекСтрока);
			ОбрабатываемаяСтрокаЗаказа.КодСтроки = Выборка.КодСтроки;
			ОбрабатываемаяСтрокаЗаказа.Количество = 0;
			
			Пока Выборка.Следующий()
				И ОстатокПоСтрокеЗаказа > 0 Цикл // Перебор строк накладных
				
				ОбрабатываемаяСтрокаЗаказа.Серия = Выборка.Серия;
				
				ДобавляемоеКоличество = Мин(ОстатокПоСтрокеЗаказа, Выборка.Количество);
				
				ОбрабатываемаяСтрокаЗаказа.Количество = ОбрабатываемаяСтрокаЗаказа.Количество + ДобавляемоеКоличество;
				
				Если СтатусУказанияСерий = 10
				  Или СтатусУказанияСерий = 11 Тогда
					ОбрабатываемаяСтрокаЗаказа.СтатусУказанияСерий = 10;
				Иначе
					ОбрабатываемаяСтрокаЗаказа.СтатусУказанияСерий = 14;
				КонецЕсли;
				ОбработкаТабличнойЧастиКлиентСервер.ДобавитьСтрокуДляПересчетаСуммы(СтруктураПересчетаСуммыВЗаказе, ОбрабатываемаяСтрокаЗаказа);
				ОстатокПоСтрокеЗаказа = ОстатокПоСтрокеЗаказа - ДобавляемоеКоличество;
				
			КонецЦикла;
			
		КонецЦикла;
		
		Если ОстатокПоСтрокеЗаказа = 0 Тогда
			
			СтрокиКУдалению.Добавить(ЗаказТекСтрока);
			
		Иначе
			
			ЗаказТекСтрока.Количество = ОстатокПоСтрокеЗаказа;
			ЗаказТекСтрока.Серия = Справочники.СерииНоменклатуры.ПустаяСсылка();
			
			Если СтатусУказанияСерий = 10 Тогда
				СтрокиКРаспределениюПоСериям.Добавить(ЗаказТекСтрока);
			Иначе
				
				ЗаказТекСтрока.КодСтроки = ЗаказОбъект[ИмяПоляМаксКодСтроки] + 1;
				ЗаказОбъект[ИмяПоляМаксКодСтроки] = ЗаказТекСтрока.КодСтроки;
				
				Если ЭтоОбособленнаяСтрока Тогда
					ЗаказТекСтрока.ВариантОбеспечения = ВариантОбособленно;
					ЗаказТекСтрока.СтатусУказанияСерий  = 0;
				Иначе
					ЗаказТекСтрока.ВариантОбеспечения = ВариантСоСклада;
					ЗаказТекСтрока.СтатусУказанияСерий  = СтатусУказанияСерий;
				КонецЕсли;
				
			КонецЕсли;
			
			ОбработкаТабличнойЧастиКлиентСервер.ДобавитьСтрокуДляПересчетаСуммы(СтруктураПересчетаСуммыВЗаказе, ЗаказТекСтрока);
			
		КонецЕсли;
		
		ОбработкаТабличнойЧастиКлиентСервер.ПересчитатьСуммы(СтруктураПересчетаСуммыВЗаказе);
		
	КонецЦикла;
	
	// Обработаем неоформленные строки (накладных по ним нет)
	Для Каждого ЗаказТекСтрока Из СтрокиКРаспределениюПоСериям Цикл
		
		ОбработкаТабличнойЧастиКлиентСервер.ЗаполнитьСтруктуруПересчетаСуммы(СтруктураПересчетаСуммыВЗаказе, ЗаказТекСтрока);
		
		Если СтруктураПоискаСерийВЗаказе.Свойство("Назначение")
			И ЗаказОбъект.Метаданные().ТабличныеЧасти[ПараметрыОбработчика.ИмяТЧТоварыЗаказа].Реквизиты.Найти("Назначение") = Неопределено Тогда
			// По некоторым заказам в ТЧ Товары был удален реквизит Назначение, нужно взять его из шапки
			Если ЗаказТекСтрока.ВариантОбеспечения = ВариантОтгрузитьОбособленно Тогда
				СтруктураПоискаСерийВЗаказе.Назначение = ЗаказОбъект.Назначение;
			Иначе
				СтруктураПоискаСерийВЗаказе.Назначение = Справочники.Назначения.ПустаяСсылка();
			КонецЕсли;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(СтруктураПоискаСерийВЗаказе, ЗаказТекСтрока);
		СтрокиСерий = ЗаказТЧСерии.НайтиСтроки(СтруктураПоискаСерийВЗаказе);
		
		ОстатокПоСтрокеЗаказа = ЗаказТекСтрока.Количество;
		
		Для Каждого СтрокаСерий Из СтрокиСерий Цикл
			
			ОбрабатываемаяСтрокаЗаказа = ЗаказТЧТовары.Добавить();
			ЗаполнитьЗначенияСвойств(ОбрабатываемаяСтрокаЗаказа, ЗаказТекСтрока);
			
			ОбрабатываемаяСтрокаЗаказа.КодСтроки = ЗаказОбъект[ИмяПоляМаксКодСтроки] + 1;
			ЗаказОбъект[ИмяПоляМаксКодСтроки] = ОбрабатываемаяСтрокаЗаказа.КодСтроки;
			
			ОбрабатываемаяСтрокаЗаказа.Серия = СтрокаСерий.Серия;
			ДобавляемоеКоличество = Мин(СтрокаСерий.Количество, ОстатокПоСтрокеЗаказа);
			ОбрабатываемаяСтрокаЗаказа.Количество = ДобавляемоеКоличество;
			ОбработкаТабличнойЧастиКлиентСервер.ДобавитьСтрокуДляПересчетаСуммы(СтруктураПересчетаСуммыВЗаказе, ОбрабатываемаяСтрокаЗаказа);
			
			СтрокаСерий.Количество = СтрокаСерий.Количество - ДобавляемоеКоличество;
			Если СтрокаСерий.Количество = 0 Тогда
				ЗаказТЧСерии.Удалить(СтрокаСерий);
			КонецЕсли;
			
			ОстатокПоСтрокеЗаказа = ОстатокПоСтрокеЗаказа - ДобавляемоеКоличество;
			
			Если ОстатокПоСтрокеЗаказа = 0 Тогда
				СтрокиКУдалению.Добавить(ЗаказТекСтрока);
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		ОбработкаТабличнойЧастиКлиентСервер.ПересчитатьСуммы(СтруктураПересчетаСуммыВЗаказе);
		
	КонецЦикла;
	
	Для Каждого Стр Из СтрокиКУдалению Цикл
		ЗаказТЧТовары.Удалить(Стр);
	КонецЦикла;
	
КонецПроцедуры

Функция БлокировкаСвязанныхОбъектов(Выборка, ПрефиксНаЗапись = "", ПрефиксНаЧтение = "") Экспорт
	
	Блокировка = Новый БлокировкаДанных;

	ИмяПоляЗаказСсылка = ПрефиксНаЗапись + "Ссылка";
	ИмяПоляНакладнаяСсылка = ПрефиксНаЧтение + "Ссылка";
	Выборка.Сбросить();

	Пока Выборка.СледующийПоЗначениюПоля(ИмяПоляНакладнаяСсылка) Цикл
		Если ЗначениеЗаполнено(Выборка[ИмяПоляНакладнаяСсылка]) Тогда
			ЭлементБлокировки = Блокировка.Добавить(Выборка[ИмяПоляНакладнаяСсылка].Метаданные().ПолноеИмя());
			ЭлементБлокировки.УстановитьЗначение("Ссылка", Выборка[ИмяПоляНакладнаяСсылка]);
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		КонецЕсли;
	КонецЦикла;
	
	Выборка.Сбросить();
	Выборка.Следующий();
	

	ЭлементБлокировки = Блокировка.Добавить(Выборка[ИмяПоляЗаказСсылка].Метаданные().ПолноеИмя());
	ЭлементБлокировки.УстановитьЗначение("Ссылка", Выборка[ИмяПоляЗаказСсылка]);
	
	Выборка.Сбросить();
	Возврат Блокировка;
	
КонецФункции

Функция БлокировкаЗаказаИНакладных(Выборка, ПрефиксВедущегоПоля = "Заказ", ПрефиксВедомогоПоля = "Накладная") Экспорт
	
	Блокировка = Новый БлокировкаДанных;

	ИмяПоляЗаказСсылка = ПрефиксВедущегоПоля + "Ссылка";
	ИмяПоляНакладнаяСсылка = ПрефиксВедомогоПоля + "Ссылка";
	Выборка.Сбросить();



	Пока Выборка.СледующийПоЗначениюПоля(ИмяПоляНакладнаяСсылка) Цикл
		Если ЗначениеЗаполнено(Выборка[ИмяПоляНакладнаяСсылка]) Тогда
			ЭлементБлокировки = Блокировка.Добавить(Выборка[ИмяПоляНакладнаяСсылка].Метаданные().ПолноеИмя());
			ЭлементБлокировки.УстановитьЗначение("Ссылка", Выборка[ИмяПоляНакладнаяСсылка]);
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		КонецЕсли;
	КонецЦикла;
	
	Выборка.Сбросить();
	Выборка.Следующий();
	

	ЭлементБлокировки = Блокировка.Добавить(Выборка[ИмяПоляЗаказСсылка].Метаданные().ПолноеИмя());
	ЭлементБлокировки.УстановитьЗначение("Ссылка", Выборка[ИмяПоляЗаказСсылка]);
	
	Выборка.Сбросить();
	Возврат Блокировка;
	
КонецФункции

Функция БлокировкаНакладнойИЗаказов(Выборка) Экспорт
	
	Блокировка = Новый БлокировкаДанных;
	
	Выборка.Сбросить();
	Пока Выборка.СледующийПоЗначениюПоля("ЗаказСсылка") Цикл
		Если ЗначениеЗаполнено(Выборка.ЗаказСсылка) Тогда
			ЭлементБлокировки = Блокировка.Добавить(Выборка.ЗаказСсылка.Метаданные().ПолноеИмя());
			ЭлементБлокировки.УстановитьЗначение("Ссылка", Выборка.ЗаказСсылка);
			ЭлементБлокировки.Режим = РежимБлокировкиДанных.Разделяемый;
		КонецЕсли;
	КонецЦикла;
	
	Выборка.Сбросить();
	Выборка.Следующий();
	
	ЭлементБлокировки = Блокировка.Добавить(Выборка.Ссылка.Метаданные().ПолноеИмя());
	ЭлементБлокировки.УстановитьЗначение("Ссылка", Выборка.Ссылка);
	
	Выборка.Сбросить();
	Возврат Блокировка;
	
КонецФункции

Функция ПроверитьПолучитьОбъект(Ссылка,ВерсияДанных,Очередь) Экспорт
	Возврат ОбновлениеИнформационнойБазыУТ.ПроверитьПолучитьОбъект(Ссылка,ВерсияДанных,Очередь);
КонецФункции

Функция ПроверитьИзменениеВерсий(Выборка, ПрефиксПроверяемогоПоля = "") Экспорт
	
	ИмяПоляСсылка = ПрефиксПроверяемогоПоля + "Ссылка";
	ИмяПоляВерсия = ПрефиксПроверяемогоПоля + "ВерсияДанных";
	ВерсииНакладных = Новый Соответствие;
	Ссылки = Новый Массив;
	Пока Выборка.СледующийПоЗначениюПоля(ИмяПоляСсылка) Цикл
		Если ЗначениеЗаполнено(Выборка[ИмяПоляСсылка])
			И ВерсииНакладных[Выборка[ИмяПоляСсылка]] = Неопределено Тогда
			ВерсииНакладных.Вставить(Выборка[ИмяПоляСсылка], Выборка[ИмяПоляВерсия]);

			Ссылки.Добавить(Выборка[ИмяПоляСсылка]);
		КонецЕсли;
	КонецЦикла;
	

	Реквизиты = ОбщегоНазначения.ЗначенияРеквизитовОбъектов(Ссылки, "ВерсияДанных");
	Для Каждого Ссылка Из Ссылки Цикл

		Если Реквизиты[Ссылка].ВерсияДанных <> ВерсииНакладных[Ссылка] Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Выборка.Сбросить();
	Возврат Истина;
	
КонецФункции

Процедура СообщитьОНеудачнойБлокировке(Ссылка) Экспорт
    ОбновлениеИнформационнойБазыУТ.СообщитьОНеудачнойБлокировке(Ссылка);
КонецПроцедуры

Процедура СообщитьОНеудачнойОбработке(Ссылка) Экспорт
    ОбновлениеИнформационнойБазыУТ.СообщитьОНеудачнойОбработке(Ссылка);
КонецПроцедуры

#КонецОбласти

#КонецОбласти